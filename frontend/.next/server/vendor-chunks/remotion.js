"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remotion";
exports.ids = ["vendor-chunks/remotion"];
exports.modules = {

/***/ "(ssr)/./node_modules/remotion/dist/esm/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/remotion/dist/esm/index.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsoluteFill: () => (/* binding */ AbsoluteFill),\n/* harmony export */   AnimatedImage: () => (/* binding */ AnimatedImage),\n/* harmony export */   Artifact: () => (/* binding */ Artifact),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   Composition: () => (/* binding */ Composition),\n/* harmony export */   Config: () => (/* binding */ Config),\n/* harmony export */   Easing: () => (/* binding */ Easing),\n/* harmony export */   Experimental: () => (/* binding */ Experimental),\n/* harmony export */   Folder: () => (/* binding */ Folder),\n/* harmony export */   FolderContext: () => (/* binding */ FolderContext),\n/* harmony export */   Freeze: () => (/* binding */ Freeze),\n/* harmony export */   Html5Audio: () => (/* binding */ Html5Audio),\n/* harmony export */   Html5Video: () => (/* binding */ Html5Video),\n/* harmony export */   IFrame: () => (/* binding */ IFrame),\n/* harmony export */   Img: () => (/* binding */ Img),\n/* harmony export */   Internals: () => (/* binding */ Internals),\n/* harmony export */   Loop: () => (/* binding */ Loop),\n/* harmony export */   OffthreadVideo: () => (/* binding */ OffthreadVideo),\n/* harmony export */   Sequence: () => (/* binding */ Sequence),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   Still: () => (/* binding */ Still),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Video: () => (/* binding */ Video),\n/* harmony export */   cancelRender: () => (/* binding */ cancelRender),\n/* harmony export */   continueRender: () => (/* binding */ continueRender),\n/* harmony export */   delayRender: () => (/* binding */ delayRender),\n/* harmony export */   getInputProps: () => (/* binding */ getInputProps),\n/* harmony export */   getRemotionEnvironment: () => (/* binding */ getRemotionEnvironment),\n/* harmony export */   getStaticFiles: () => (/* binding */ getStaticFiles),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),\n/* harmony export */   measureSpring: () => (/* binding */ measureSpring),\n/* harmony export */   prefetch: () => (/* binding */ prefetch),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   registerRoot: () => (/* binding */ registerRoot),\n/* harmony export */   spring: () => (/* binding */ spring),\n/* harmony export */   staticFile: () => (/* binding */ staticFile),\n/* harmony export */   useBufferState: () => (/* binding */ useBufferState),\n/* harmony export */   useCurrentFrame: () => (/* binding */ useCurrentFrame),\n/* harmony export */   useCurrentScale: () => (/* binding */ useCurrentScale),\n/* harmony export */   useDelayRender: () => (/* binding */ useDelayRender),\n/* harmony export */   useRemotionEnvironment: () => (/* binding */ useRemotionEnvironment),\n/* harmony export */   useVideoConfig: () => (/* binding */ useVideoConfig),\n/* harmony export */   watchStaticFile: () => (/* binding */ watchStaticFile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, {\n      get: all[name],\n      enumerable: true,\n      configurable: true,\n      set: (newValue) => all[name] = () => newValue\n    });\n};\n\n// src/_check-rsc.ts\n\nif (typeof react__WEBPACK_IMPORTED_MODULE_0__.createContext !== \"function\") {\n  const err = [\n    'Remotion requires React.createContext, but it is \"undefined\".',\n    'If you are in a React Server Component, turn it into a client component by adding \"use client\" at the top of the file.',\n    \"\",\n    \"Before:\",\n    '  import {useCurrentFrame} from \"remotion\";',\n    \"\",\n    \"After:\",\n    '  \"use client\";',\n    '  import {useCurrentFrame} from \"remotion\";'\n  ];\n  throw new Error(err.join(`\n`));\n}\n\n// src/Clipper.tsx\nvar Clipper = () => {\n  throw new Error(\"<Clipper> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n\n// src/enable-sequence-stack-traces.ts\n\n\n\n// src/get-remotion-environment.ts\nfunction getNodeEnvString() {\n  return [\"NOD\", \"E_EN\", \"V\"].join(\"\");\n}\nvar getEnvString = () => {\n  return [\"e\", \"nv\"].join(\"\");\n};\nvar getRemotionEnvironment = () => {\n  const isPlayer = typeof window !== \"undefined\" && window.remotion_isPlayer;\n  const isRendering = typeof window !== \"undefined\" && typeof window.process !== \"undefined\" && typeof window.process.env !== \"undefined\" && (window.process[getEnvString()][getNodeEnvString()] === \"test\" || window.process[getEnvString()][getNodeEnvString()] === \"production\" && typeof window !== \"undefined\" && typeof window.remotion_puppeteerTimeout !== \"undefined\");\n  const isStudio = typeof window !== \"undefined\" && window.remotion_isStudio;\n  const isReadOnlyStudio = typeof window !== \"undefined\" && window.remotion_isReadOnlyStudio;\n  return {\n    isStudio,\n    isRendering,\n    isPlayer,\n    isReadOnlyStudio,\n    isClientSideRendering: false\n  };\n};\n\n// src/enable-sequence-stack-traces.ts\nvar originalCreateElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement;\nvar originalJsx = react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx;\nvar componentsToAddStacksTo = [];\nvar enableProxy = (api) => {\n  return new Proxy(api, {\n    apply(target, thisArg, argArray) {\n      if (componentsToAddStacksTo.includes(argArray[0])) {\n        const [first, props, ...rest] = argArray;\n        const newProps = {\n          ...props ?? {},\n          stack: new Error().stack\n        };\n        return Reflect.apply(target, thisArg, [first, newProps, ...rest]);\n      }\n      return Reflect.apply(target, thisArg, argArray);\n    }\n  });\n};\nvar enableSequenceStackTraces = () => {\n  if (!getRemotionEnvironment().isStudio) {\n    return;\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.createElement = enableProxy(originalCreateElement);\n  react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx = enableProxy(originalJsx);\n};\nvar addSequenceStackTraces = (component) => {\n  componentsToAddStacksTo.push(component);\n  enableSequenceStackTraces();\n};\n\n// src/is-player.tsx\n\n\nvar IsPlayerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsPlayerContextProvider = ({\n  children\n}) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, {\n    value: true,\n    children\n  });\n};\nvar useIsPlayer = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);\n};\n\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/version.ts\nvar VERSION = \"4.0.388\";\n\n// src/multiple-versions-warning.ts\nvar checkMultipleRemotionVersions = () => {\n  if (typeof globalThis === \"undefined\") {\n    return;\n  }\n  const set = () => {\n    globalThis.remotion_imported = VERSION;\n    if (typeof window !== \"undefined\") {\n      window.remotion_imported = VERSION;\n    }\n  };\n  const alreadyImported = globalThis.remotion_imported || typeof window !== \"undefined\" && window.remotion_imported;\n  if (alreadyImported) {\n    if (alreadyImported === VERSION) {\n      return;\n    }\n    if (typeof alreadyImported === \"string\" && alreadyImported.includes(\"webcodecs\")) {\n      set();\n      return;\n    }\n    throw new TypeError(`\\uD83D\\uDEA8 Multiple versions of Remotion detected: ${[\n      VERSION,\n      typeof alreadyImported === \"string\" ? alreadyImported : \"an older version\"\n    ].filter(truthy).join(\" and \")}. This will cause things to break in an unexpected way.\nCheck that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \\`npx remotion versions\\` from your terminal to see which versions are mismatching.`);\n  }\n  set();\n};\n\n// src/Null.tsx\nvar Null = () => {\n  throw new Error(\"<Null> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n\n// src/Sequence.tsx\n\n\n// src/AbsoluteFill.tsx\n\n\nvar hasTailwindClassName = ({\n  className,\n  classPrefix,\n  type\n}) => {\n  if (!className) {\n    return false;\n  }\n  if (type === \"exact\") {\n    const split = className.split(\" \");\n    return classPrefix.some((token) => {\n      return split.some((part) => {\n        return part.trim() === token || part.trim().endsWith(`:${token}`) || part.trim().endsWith(`!${token}`);\n      });\n    });\n  }\n  return classPrefix.some((prefix) => {\n    return className.startsWith(prefix) || className.includes(` ${prefix}`) || className.includes(`!${prefix}`) || className.includes(`:${prefix}`);\n  });\n};\nvar AbsoluteFillRefForwarding = (props, ref) => {\n  const { style, ...other } = props;\n  const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      position: \"absolute\",\n      top: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"top-\", \"inset-\"],\n        type: \"prefix\"\n      }) ? undefined : 0,\n      left: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"left-\", \"inset-\"],\n        type: \"prefix\"\n      }) ? undefined : 0,\n      right: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"right-\", \"inset-\"],\n        type: \"prefix\"\n      }) ? undefined : 0,\n      bottom: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"bottom-\", \"inset-\"],\n        type: \"prefix\"\n      }) ? undefined : 0,\n      width: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"w-\"],\n        type: \"prefix\"\n      }) ? undefined : \"100%\",\n      height: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"h-\"],\n        type: \"prefix\"\n      }) ? undefined : \"100%\",\n      display: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\n          \"block\",\n          \"inline-block\",\n          \"inline\",\n          \"flex\",\n          \"inline-flex\",\n          \"flow-root\",\n          \"grid\",\n          \"inline-grid\",\n          \"contents\",\n          \"list-item\",\n          \"hidden\"\n        ],\n        type: \"exact\"\n      }) ? undefined : \"flex\",\n      flexDirection: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\n          \"flex-row\",\n          \"flex-col\",\n          \"flex-row-reverse\",\n          \"flex-col-reverse\"\n        ],\n        type: \"exact\"\n      }) ? undefined : \"column\",\n      ...style\n    };\n  }, [other.className, style]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    ref,\n    style: actualStyle,\n    ...other\n  });\n};\nvar AbsoluteFill = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);\n\n// src/SequenceContext.tsx\n\nvar SequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n\n// src/SequenceManager.tsx\n\n\nvar SequenceManager = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  registerSequence: () => {\n    throw new Error(\"SequenceManagerContext not initialized\");\n  },\n  unregisterSequence: () => {\n    throw new Error(\"SequenceManagerContext not initialized\");\n  },\n  sequences: []\n});\nvar SequenceVisibilityToggleContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  hidden: {},\n  setHidden: () => {\n    throw new Error(\"SequenceVisibilityToggle not initialized\");\n  }\n});\nvar SequenceManagerProvider = ({ children }) => {\n  const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [hidden, setHidden] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq) => {\n    setSequences((seqs) => {\n      return [...seqs, seq];\n    });\n  }, []);\n  const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq) => {\n    setSequences((seqs) => seqs.filter((s) => s.id !== seq));\n  }, []);\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      registerSequence,\n      sequences,\n      unregisterSequence\n    };\n  }, [registerSequence, sequences, unregisterSequence]);\n  const hiddenContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      hidden,\n      setHidden\n    };\n  }, [hidden]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n    value: sequenceContext,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceVisibilityToggleContext.Provider, {\n      value: hiddenContext,\n      children\n    })\n  });\n};\n\n// src/TimelineContext.tsx\n\n\n// src/random.ts\nfunction mulberry32(a) {\n  let t = a + 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n  let i = 0;\n  let chr = 0;\n  let hash = 0;\n  for (i = 0;i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0;\n  }\n  return hash;\n}\nvar random = (seed, dummy) => {\n  if (dummy !== undefined) {\n    throw new TypeError(\"random() takes only one argument\");\n  }\n  if (seed === null) {\n    return Math.random();\n  }\n  if (typeof seed === \"string\") {\n    return mulberry32(hashCode(seed));\n  }\n  if (typeof seed === \"number\") {\n    return mulberry32(seed * 10000000000);\n  }\n  throw new Error(\"random() argument must be a number or a string\");\n};\n\n// src/timeline-position-state.ts\nvar exports_timeline_position_state = {};\n__export(exports_timeline_position_state, {\n  useTimelineSetFrame: () => useTimelineSetFrame,\n  useTimelinePosition: () => useTimelinePosition,\n  usePlayingState: () => usePlayingState,\n  persistCurrentFrame: () => persistCurrentFrame,\n  getInitialFrameState: () => getInitialFrameState,\n  getFrameForComposition: () => getFrameForComposition\n});\n\n\n// src/use-remotion-environment.ts\n\n\n// src/remotion-environment-context.ts\n\nvar RemotionEnvironmentContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n// src/use-remotion-environment.ts\nvar useRemotionEnvironment = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RemotionEnvironmentContext);\n  const [env] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => getRemotionEnvironment());\n  return context ?? env;\n};\n\n// src/use-video.ts\n\n\n// src/CompositionManagerContext.tsx\n\nvar CompositionManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  compositions: [],\n  folders: [],\n  currentCompositionMetadata: null,\n  canvasContent: null\n});\nvar CompositionSetters = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  registerComposition: () => {\n    return;\n  },\n  unregisterComposition: () => {\n    return;\n  },\n  registerFolder: () => {\n    return;\n  },\n  unregisterFolder: () => {\n    return;\n  },\n  setCanvasContent: () => {\n    return;\n  },\n  updateCompositionDefaultProps: () => {\n    return;\n  },\n  onlyRenderComposition: null\n});\n\n// src/ResolveCompositionConfig.tsx\n\n\n// src/EditorProps.tsx\n\n\nvar EditorPropsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  props: {},\n  updateProps: () => {\n    throw new Error(\"Not implemented\");\n  },\n  resetUnsaved: () => {\n    throw new Error(\"Not implemented\");\n  }\n});\nvar editorPropsProviderRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar timeValueRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar EditorPropsProvider = ({ children }) => {\n  const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n  const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({\n    defaultProps,\n    id,\n    newProps\n  }) => {\n    setProps((prev) => {\n      return {\n        ...prev,\n        [id]: typeof newProps === \"function\" ? newProps(prev[id] ?? defaultProps) : newProps\n      };\n    });\n  }, []);\n  const resetUnsaved = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((compositionId) => {\n    setProps((prev) => {\n      if (prev[compositionId]) {\n        const newProps = { ...prev };\n        delete newProps[compositionId];\n        return newProps;\n      }\n      return prev;\n    });\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(editorPropsProviderRef, () => {\n    return {\n      getProps: () => props,\n      setProps\n    };\n  }, [props]);\n  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return { props, updateProps, resetUnsaved };\n  }, [props, resetUnsaved, updateProps]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, {\n    value: ctx,\n    children\n  });\n};\n\n// src/input-props-override.ts\nvar getKey = () => {\n  return `remotion_inputPropsOverride` + window.location.origin;\n};\nvar getInputPropsOverride = () => {\n  if (typeof localStorage === \"undefined\")\n    return null;\n  const override = localStorage.getItem(getKey());\n  if (!override)\n    return null;\n  return JSON.parse(override);\n};\nvar setInputPropsOverride = (override) => {\n  if (typeof localStorage === \"undefined\")\n    return;\n  if (override === null) {\n    localStorage.removeItem(getKey());\n    return;\n  }\n  localStorage.setItem(getKey(), JSON.stringify(override));\n};\n\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithSpecialTypes = ({\n  data,\n  indent,\n  staticBase\n}) => {\n  let customDateUsed = false;\n  let customFileUsed = false;\n  let mapUsed = false;\n  let setUsed = false;\n  try {\n    const serializedString = JSON.stringify(data, function(key, value) {\n      const item = this[key];\n      if (item instanceof Date) {\n        customDateUsed = true;\n        return `${DATE_TOKEN}${item.toISOString()}`;\n      }\n      if (item instanceof Map) {\n        mapUsed = true;\n        return value;\n      }\n      if (item instanceof Set) {\n        setUsed = true;\n        return value;\n      }\n      if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n        customFileUsed = true;\n        return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n      }\n      return value;\n    }, indent);\n    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };\n  } catch (err) {\n    throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n  }\n};\nvar deserializeJSONWithSpecialTypes = (data) => {\n  return JSON.parse(data, (_, value) => {\n    if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n      return new Date(value.replace(DATE_TOKEN, \"\"));\n    }\n    if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n      return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n    }\n    return value;\n  });\n};\nvar serializeThenDeserialize = (props) => {\n  return deserializeJSONWithSpecialTypes(serializeJSONWithSpecialTypes({\n    data: props,\n    indent: 2,\n    staticBase: window.remotion_staticBase\n  }).serializedString);\n};\nvar serializeThenDeserializeInStudio = (props) => {\n  if (getRemotionEnvironment().isStudio) {\n    return serializeThenDeserialize(props);\n  }\n  return props;\n};\n\n// src/config/input-props.ts\nvar didWarnSSRImport = false;\nvar warnOnceSSRImport = () => {\n  if (didWarnSSRImport) {\n    return;\n  }\n  didWarnSSRImport = true;\n  console.warn(\"Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.\");\n  console.warn(\"To hide this warning, don't call this function on the server:\");\n  console.warn(\"  typeof window === 'undefined' ? {} : getInputProps()\");\n};\nvar getInputProps = () => {\n  if (typeof window === \"undefined\") {\n    warnOnceSSRImport();\n    return {};\n  }\n  if (getRemotionEnvironment().isPlayer) {\n    throw new Error(\"You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.\");\n  }\n  const override = getInputPropsOverride();\n  if (override) {\n    return override;\n  }\n  if (typeof window === \"undefined\" || typeof window.remotion_inputProps === \"undefined\") {\n    throw new Error(\"Cannot call `getInputProps()` - window.remotion_inputProps is not set. This API is only available if you are in the Studio, or while you are rendering server-side.\");\n  }\n  const param = window.remotion_inputProps;\n  if (!param) {\n    return {};\n  }\n  const parsed = deserializeJSONWithSpecialTypes(param);\n  return parsed;\n};\n\n// src/nonce.ts\n\nvar NonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  getNonce: () => 0,\n  fastRefreshes: 0,\n  manualRefreshes: 0\n});\nvar SetNonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  increaseManualRefreshes: () => {}\n});\nvar useNonce = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n  const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => context.getNonce());\n  const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (lastContext.current === context) {\n      return;\n    }\n    lastContext.current = context;\n    setNonce(context.getNonce);\n  }, [context]);\n  return nonce;\n};\n\n// src/codec.ts\nvar validCodecs = [\n  \"h264\",\n  \"h265\",\n  \"vp8\",\n  \"vp9\",\n  \"mp3\",\n  \"aac\",\n  \"wav\",\n  \"prores\",\n  \"h264-mkv\",\n  \"h264-ts\",\n  \"gif\"\n];\n\n// src/validation/validate-default-codec.ts\nfunction validateCodec(defaultCodec, location, name) {\n  if (typeof defaultCodec === \"undefined\") {\n    return;\n  }\n  if (typeof defaultCodec !== \"string\") {\n    throw new TypeError(`The \"${name}\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n  }\n  if (!validCodecs.includes(defaultCodec)) {\n    throw new Error(`The \"${name}\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n  }\n}\n\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n  if (typeof amount !== \"number\") {\n    throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n  }\n  if (isNaN(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n  }\n  if (!Number.isFinite(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n  }\n  if (amount % 1 !== 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n  }\n  if (amount <= 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n  }\n}\n\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n  const { allowFloats, component } = options;\n  if (typeof durationInFrames === \"undefined\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n  }\n  if (!allowFloats && durationInFrames % 1 !== 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n  }\n  if (!Number.isFinite(durationInFrames)) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n  }\n}\n\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n  if (typeof fps !== \"number\") {\n    throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n  }\n  if (!Number.isFinite(fps)) {\n    throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n  }\n  if (isNaN(fps)) {\n    throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n  }\n  if (fps <= 0) {\n    throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n  }\n  if (isGif && fps > 50) {\n    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n  }\n}\n\n// src/resolve-video-config.ts\nvar validateCalculated = ({\n  calculated,\n  compositionId,\n  compositionFps,\n  compositionHeight,\n  compositionWidth,\n  compositionDurationInFrames\n}) => {\n  const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition \"${compositionId}\"`;\n  const defaultErrorLocation = `of the \"<Composition />\" component with the id \"${compositionId}\"`;\n  const width = calculated?.width ?? compositionWidth ?? undefined;\n  validateDimension(width, \"width\", calculated?.width ? calculateMetadataErrorLocation : defaultErrorLocation);\n  const height = calculated?.height ?? compositionHeight ?? undefined;\n  validateDimension(height, \"height\", calculated?.height ? calculateMetadataErrorLocation : defaultErrorLocation);\n  const fps = calculated?.fps ?? compositionFps ?? null;\n  validateFps(fps, calculated?.fps ? calculateMetadataErrorLocation : defaultErrorLocation, false);\n  const durationInFrames = calculated?.durationInFrames ?? compositionDurationInFrames ?? null;\n  validateDurationInFrames(durationInFrames, {\n    allowFloats: false,\n    component: `of the \"<Composition />\" component with the id \"${compositionId}\"`\n  });\n  const defaultCodec = calculated?.defaultCodec;\n  validateCodec(defaultCodec, calculateMetadataErrorLocation, \"defaultCodec\");\n  const defaultOutName = calculated?.defaultOutName;\n  const defaultVideoImageFormat = calculated?.defaultVideoImageFormat;\n  const defaultPixelFormat = calculated?.defaultPixelFormat;\n  const defaultProResProfile = calculated?.defaultProResProfile;\n  return {\n    width,\n    height,\n    fps,\n    durationInFrames,\n    defaultCodec,\n    defaultOutName,\n    defaultVideoImageFormat,\n    defaultPixelFormat,\n    defaultProResProfile\n  };\n};\nvar resolveVideoConfig = ({\n  calculateMetadata,\n  signal,\n  defaultProps,\n  inputProps: originalProps,\n  compositionId,\n  compositionDurationInFrames,\n  compositionFps,\n  compositionHeight,\n  compositionWidth\n}) => {\n  const calculatedProm = calculateMetadata ? calculateMetadata({\n    defaultProps,\n    props: originalProps,\n    abortSignal: signal,\n    compositionId,\n    isRendering: getRemotionEnvironment().isRendering\n  }) : null;\n  if (calculatedProm !== null && typeof calculatedProm === \"object\" && \"then\" in calculatedProm) {\n    return calculatedProm.then((c) => {\n      const {\n        height,\n        width,\n        durationInFrames,\n        fps,\n        defaultCodec,\n        defaultOutName,\n        defaultVideoImageFormat,\n        defaultPixelFormat,\n        defaultProResProfile\n      } = validateCalculated({\n        calculated: c,\n        compositionDurationInFrames,\n        compositionFps,\n        compositionHeight,\n        compositionWidth,\n        compositionId\n      });\n      return {\n        width,\n        height,\n        fps,\n        durationInFrames,\n        id: compositionId,\n        defaultProps: serializeThenDeserializeInStudio(defaultProps),\n        props: serializeThenDeserializeInStudio(c.props ?? originalProps),\n        defaultCodec: defaultCodec ?? null,\n        defaultOutName: defaultOutName ?? null,\n        defaultVideoImageFormat: defaultVideoImageFormat ?? null,\n        defaultPixelFormat: defaultPixelFormat ?? null,\n        defaultProResProfile: defaultProResProfile ?? null\n      };\n    });\n  }\n  const data = validateCalculated({\n    calculated: calculatedProm,\n    compositionDurationInFrames,\n    compositionFps,\n    compositionHeight,\n    compositionWidth,\n    compositionId\n  });\n  if (calculatedProm === null) {\n    return {\n      ...data,\n      id: compositionId,\n      defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n      props: serializeThenDeserializeInStudio(originalProps),\n      defaultCodec: null,\n      defaultOutName: null,\n      defaultVideoImageFormat: null,\n      defaultPixelFormat: null,\n      defaultProResProfile: null\n    };\n  }\n  return {\n    ...data,\n    id: compositionId,\n    defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n    props: serializeThenDeserializeInStudio(calculatedProm.props ?? originalProps),\n    defaultCodec: calculatedProm.defaultCodec ?? null,\n    defaultOutName: calculatedProm.defaultOutName ?? null,\n    defaultVideoImageFormat: calculatedProm.defaultVideoImageFormat ?? null,\n    defaultPixelFormat: calculatedProm.defaultPixelFormat ?? null,\n    defaultProResProfile: calculatedProm.defaultProResProfile ?? null\n  };\n};\nvar resolveVideoConfigOrCatch = (params) => {\n  try {\n    const promiseOrReturnValue = resolveVideoConfig(params);\n    return {\n      type: \"success\",\n      result: promiseOrReturnValue\n    };\n  } catch (err) {\n    return {\n      type: \"error\",\n      error: err\n    };\n  }\n};\n\n// src/ResolveCompositionConfig.tsx\n\nvar ResolveCompositionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar resolveCompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar needsResolution = (composition) => {\n  return Boolean(composition.calculateMetadata);\n};\nvar PROPS_UPDATED_EXTERNALLY = \"remotion.propsUpdatedExternally\";\nvar ResolveCompositionConfigInStudio = ({ children }) => {\n  const [currentRenderModalComposition, setCurrentRenderModalComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n  const { fastRefreshes, manualRefreshes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n  if (manualRefreshes) {}\n  const selectedComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return compositions.find((c) => canvasContent && canvasContent.type === \"composition\" && canvasContent.compositionId === c.id);\n  }, [canvasContent, compositions]);\n  const renderModalComposition = compositions.find((c) => c.id === currentRenderModalComposition);\n  const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n  const env = useRemotionEnvironment();\n  const inputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return typeof window === \"undefined\" || env.isPlayer ? {} : getInputProps() ?? {};\n  }, [env.isPlayer]);\n  const [resolvedConfigs, setResolvedConfigs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return selectedComposition ? allEditorProps[selectedComposition.id] ?? {} : {};\n  }, [allEditorProps, selectedComposition]);\n  const renderModalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return renderModalComposition ? allEditorProps[renderModalComposition.id] ?? {} : {};\n  }, [allEditorProps, renderModalComposition]);\n  const hasResolution = Boolean(currentCompositionMetadata);\n  const doResolution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({\n    calculateMetadata,\n    combinedProps,\n    compositionDurationInFrames,\n    compositionFps,\n    compositionHeight,\n    compositionId,\n    compositionWidth,\n    defaultProps\n  }) => {\n    const controller = new AbortController;\n    if (hasResolution) {\n      return controller;\n    }\n    const { signal } = controller;\n    const result = resolveVideoConfigOrCatch({\n      compositionId,\n      calculateMetadata,\n      inputProps: combinedProps,\n      signal,\n      defaultProps,\n      compositionDurationInFrames,\n      compositionFps,\n      compositionHeight,\n      compositionWidth\n    });\n    if (result.type === \"error\") {\n      setResolvedConfigs((r) => ({\n        ...r,\n        [compositionId]: {\n          type: \"error\",\n          error: result.error\n        }\n      }));\n      return controller;\n    }\n    const promOrNot = result.result;\n    if (typeof promOrNot === \"object\" && \"then\" in promOrNot) {\n      setResolvedConfigs((r) => {\n        const prev = r[compositionId];\n        if (prev?.type === \"success\" || prev?.type === \"success-and-refreshing\") {\n          return {\n            ...r,\n            [compositionId]: {\n              type: \"success-and-refreshing\",\n              result: prev.result\n            }\n          };\n        }\n        return {\n          ...r,\n          [compositionId]: {\n            type: \"loading\"\n          }\n        };\n      });\n      promOrNot.then((c) => {\n        if (controller.signal.aborted) {\n          return;\n        }\n        setResolvedConfigs((r) => ({\n          ...r,\n          [compositionId]: {\n            type: \"success\",\n            result: c\n          }\n        }));\n      }).catch((err) => {\n        if (controller.signal.aborted) {\n          return;\n        }\n        setResolvedConfigs((r) => ({\n          ...r,\n          [compositionId]: {\n            type: \"error\",\n            error: err\n          }\n        }));\n      });\n    } else {\n      setResolvedConfigs((r) => ({\n        ...r,\n        [compositionId]: {\n          type: \"success\",\n          result: promOrNot\n        }\n      }));\n    }\n    return controller;\n  }, [hasResolution]);\n  const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(resolveCompositionsRef, () => {\n    return {\n      setCurrentRenderModalComposition: (id) => {\n        setCurrentRenderModalComposition(id);\n      },\n      reloadCurrentlySelectedComposition: () => {\n        if (!currentComposition) {\n          return;\n        }\n        const composition = compositions.find((c) => c.id === currentComposition);\n        if (!composition) {\n          throw new Error(`Could not find composition with id ${currentComposition}`);\n        }\n        const editorProps = allEditorProps[currentComposition] ?? {};\n        const defaultProps = {\n          ...composition.defaultProps ?? {},\n          ...editorProps ?? {}\n        };\n        const props = {\n          ...defaultProps,\n          ...inputProps ?? {}\n        };\n        doResolution({\n          defaultProps,\n          calculateMetadata: composition.calculateMetadata,\n          combinedProps: props,\n          compositionDurationInFrames: composition.durationInFrames ?? null,\n          compositionFps: composition.fps ?? null,\n          compositionHeight: composition.height ?? null,\n          compositionWidth: composition.width ?? null,\n          compositionId: composition.id\n        });\n      }\n    };\n  }, [\n    allEditorProps,\n    compositions,\n    currentComposition,\n    doResolution,\n    inputProps\n  ]);\n  const isTheSame = selectedComposition?.id === renderModalComposition?.id;\n  const currentDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...selectedComposition?.defaultProps ?? {},\n      ...selectedEditorProps ?? {}\n    };\n  }, [selectedComposition?.defaultProps, selectedEditorProps]);\n  const originalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...currentDefaultProps,\n      ...inputProps ?? {}\n    };\n  }, [currentDefaultProps, inputProps]);\n  const canResolve = selectedComposition && needsResolution(selectedComposition);\n  const shouldIgnoreUpdate = typeof window !== \"undefined\" && window.remotion_ignoreFastRefreshUpdate && fastRefreshes <= window.remotion_ignoreFastRefreshUpdate;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (shouldIgnoreUpdate) {\n      return;\n    }\n    if (canResolve) {\n      const controller = doResolution({\n        calculateMetadata: selectedComposition.calculateMetadata,\n        combinedProps: originalProps,\n        compositionDurationInFrames: selectedComposition.durationInFrames ?? null,\n        compositionFps: selectedComposition.fps ?? null,\n        compositionHeight: selectedComposition.height ?? null,\n        compositionWidth: selectedComposition.width ?? null,\n        defaultProps: currentDefaultProps,\n        compositionId: selectedComposition.id\n      });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [\n    canResolve,\n    currentDefaultProps,\n    doResolution,\n    originalProps,\n    selectedComposition?.calculateMetadata,\n    selectedComposition?.durationInFrames,\n    selectedComposition?.fps,\n    selectedComposition?.height,\n    selectedComposition?.id,\n    selectedComposition?.width,\n    shouldIgnoreUpdate\n  ]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (renderModalComposition && !isTheSame) {\n      const combinedProps = {\n        ...renderModalComposition.defaultProps ?? {},\n        ...renderModalProps ?? {},\n        ...inputProps ?? {}\n      };\n      const controller = doResolution({\n        calculateMetadata: renderModalComposition.calculateMetadata,\n        compositionDurationInFrames: renderModalComposition.durationInFrames ?? null,\n        compositionFps: renderModalComposition.fps ?? null,\n        compositionHeight: renderModalComposition.height ?? null,\n        compositionId: renderModalComposition.id,\n        compositionWidth: renderModalComposition.width ?? null,\n        defaultProps: currentDefaultProps,\n        combinedProps\n      });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [\n    currentDefaultProps,\n    doResolution,\n    inputProps,\n    isTheSame,\n    renderModalComposition,\n    renderModalProps\n  ]);\n  const resolvedConfigsIncludingStaticOnes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const staticComps = compositions.filter((c) => {\n      return c.calculateMetadata === null;\n    });\n    return {\n      ...resolvedConfigs,\n      ...staticComps.reduce((acc, curr) => {\n        return {\n          ...acc,\n          [curr.id]: {\n            type: \"success\",\n            result: { ...curr, defaultProps: curr.defaultProps ?? {} }\n          }\n        };\n      }, {})\n    };\n  }, [compositions, resolvedConfigs]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n    value: resolvedConfigsIncludingStaticOnes,\n    children\n  });\n};\nvar useResolvedVideoConfig = (preferredCompositionId) => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);\n  const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n  const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n  const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n  const compositionId = preferredCompositionId ?? currentComposition;\n  const composition = compositions.find((c) => c.id === compositionId);\n  const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return composition ? allEditorProps[composition.id] ?? {} : {};\n  }, [allEditorProps, composition]);\n  const env = useRemotionEnvironment();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!composition) {\n      return null;\n    }\n    if (currentCompositionMetadata) {\n      return {\n        type: \"success\",\n        result: {\n          ...currentCompositionMetadata,\n          id: composition.id,\n          defaultProps: composition.defaultProps ?? {}\n        }\n      };\n    }\n    if (!needsResolution(composition)) {\n      validateDurationInFrames(composition.durationInFrames, {\n        allowFloats: false,\n        component: `in <Composition id=\"${composition.id}\">`\n      });\n      validateFps(composition.fps, `in <Composition id=\"${composition.id}\">`, false);\n      validateDimension(composition.width, \"width\", `in <Composition id=\"${composition.id}\">`);\n      validateDimension(composition.height, \"height\", `in <Composition id=\"${composition.id}\">`);\n      return {\n        type: \"success\",\n        result: {\n          width: composition.width,\n          height: composition.height,\n          fps: composition.fps,\n          id: composition.id,\n          durationInFrames: composition.durationInFrames,\n          defaultProps: composition.defaultProps ?? {},\n          props: {\n            ...composition.defaultProps ?? {},\n            ...selectedEditorProps ?? {},\n            ...typeof window === \"undefined\" || env.isPlayer || !window.remotion_inputProps ? {} : getInputProps() ?? {}\n          },\n          defaultCodec: null,\n          defaultOutName: null,\n          defaultVideoImageFormat: null,\n          defaultPixelFormat: null,\n          defaultProResProfile: null\n        }\n      };\n    }\n    if (!context) {\n      return null;\n    }\n    if (!context[composition.id]) {\n      return null;\n    }\n    return context[composition.id];\n  }, [\n    composition,\n    context,\n    currentCompositionMetadata,\n    selectedEditorProps,\n    env.isPlayer\n  ]);\n};\n\n// src/use-video.ts\nvar useVideo = () => {\n  const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n  const selected = compositions.find((c) => {\n    return canvasContent?.type === \"composition\" && c.id === canvasContent.compositionId;\n  });\n  const resolved = useResolvedVideoConfig(selected?.id ?? null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!resolved) {\n      return null;\n    }\n    if (resolved.type === \"error\") {\n      return null;\n    }\n    if (resolved.type === \"loading\") {\n      return null;\n    }\n    if (!selected) {\n      return null;\n    }\n    return {\n      ...resolved.result,\n      defaultProps: selected.defaultProps ?? {},\n      id: selected.id,\n      ...currentCompositionMetadata ?? {},\n      component: selected.component\n    };\n  }, [currentCompositionMetadata, resolved, selected]);\n};\n\n// src/timeline-position-state.ts\nvar makeKey = () => {\n  return `remotion.time-all`;\n};\nvar persistCurrentFrame = (time) => {\n  localStorage.setItem(makeKey(), JSON.stringify(time));\n};\nvar getInitialFrameState = () => {\n  const item = localStorage.getItem(makeKey()) ?? \"{}\";\n  const obj = JSON.parse(item);\n  return obj;\n};\nvar getFrameForComposition = (composition) => {\n  const item = localStorage.getItem(makeKey()) ?? \"{}\";\n  const obj = JSON.parse(item);\n  if (obj[composition] !== undefined) {\n    return Number(obj[composition]);\n  }\n  if (typeof window === \"undefined\") {\n    return 0;\n  }\n  return window.remotion_initialFrame ?? 0;\n};\nvar useTimelinePosition = () => {\n  const videoConfig = useVideo();\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const env = useRemotionEnvironment();\n  if (!videoConfig) {\n    return typeof window === \"undefined\" ? 0 : window.remotion_initialFrame ?? 0;\n  }\n  const unclamped = state.frame[videoConfig.id] ?? (env.isPlayer ? 0 : getFrameForComposition(videoConfig.id));\n  return Math.min(videoConfig.durationInFrames - 1, unclamped);\n};\nvar useTimelineSetFrame = () => {\n  const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n  return setFrame;\n};\nvar usePlayingState = () => {\n  const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [playing, setPlaying, imperativePlaying], [imperativePlaying, playing, setPlaying]);\n};\n\n// src/use-delay-render.tsx\n\n\n// src/cancel-render.ts\nvar isErrorLike = (err) => {\n  if (err instanceof Error) {\n    return true;\n  }\n  if (err === null) {\n    return false;\n  }\n  if (typeof err !== \"object\") {\n    return false;\n  }\n  if (!(\"stack\" in err)) {\n    return false;\n  }\n  if (typeof err.stack !== \"string\") {\n    return false;\n  }\n  if (!(\"message\" in err)) {\n    return false;\n  }\n  if (typeof err.message !== \"string\") {\n    return false;\n  }\n  return true;\n};\nfunction cancelRenderInternal(scope, err) {\n  let error;\n  if (isErrorLike(err)) {\n    error = err;\n    if (!error.stack) {\n      error.stack = new Error(error.message).stack;\n    }\n  } else if (typeof err === \"string\") {\n    error = Error(err);\n  } else {\n    error = Error(\"Rendering was cancelled\");\n  }\n  if (scope) {\n    scope.remotion_cancelledError = error.stack;\n  }\n  throw error;\n}\nfunction cancelRender(err) {\n  return cancelRenderInternal(typeof window !== \"undefined\" ? window : undefined, err);\n}\n\n// src/log.ts\nvar logLevels = [\"trace\", \"verbose\", \"info\", \"warn\", \"error\"];\nvar getNumberForLogLevel = (level) => {\n  return logLevels.indexOf(level);\n};\nvar isEqualOrBelowLogLevel = (currentLevel, level) => {\n  return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);\n};\nvar transformArgs = ({\n  args,\n  logLevel,\n  tag\n}) => {\n  const arr = [...args];\n  if (getRemotionEnvironment().isRendering && !getRemotionEnvironment().isClientSideRendering) {\n    arr.unshift(Symbol.for(`__remotion_level_${logLevel}`));\n  }\n  if (tag && getRemotionEnvironment().isRendering && !getRemotionEnvironment().isClientSideRendering) {\n    arr.unshift(Symbol.for(`__remotion_tag_${tag}`));\n  }\n  return arr;\n};\nvar verbose = (options, ...args) => {\n  if (isEqualOrBelowLogLevel(options.logLevel, \"verbose\")) {\n    return console.debug(...transformArgs({ args, logLevel: \"verbose\", tag: options.tag }));\n  }\n};\nvar trace = (options, ...args) => {\n  if (isEqualOrBelowLogLevel(options.logLevel, \"trace\")) {\n    return console.debug(...transformArgs({ args, logLevel: \"trace\", tag: options.tag }));\n  }\n};\nvar info = (options, ...args) => {\n  if (isEqualOrBelowLogLevel(options.logLevel, \"info\")) {\n    return console.log(...transformArgs({ args, logLevel: \"info\", tag: options.tag }));\n  }\n};\nvar warn = (options, ...args) => {\n  if (isEqualOrBelowLogLevel(options.logLevel, \"warn\")) {\n    return console.warn(...transformArgs({ args, logLevel: \"warn\", tag: options.tag }));\n  }\n};\nvar error = (options, ...args) => {\n  return console.error(...transformArgs({ args, logLevel: \"error\", tag: options.tag }));\n};\nvar Log = {\n  trace,\n  verbose,\n  info,\n  warn,\n  error\n};\n\n// src/delay-render.ts\nvar handles = [];\nif (typeof window !== \"undefined\") {\n  window.remotion_renderReady = false;\n  if (!window.remotion_delayRenderTimeouts) {\n    window.remotion_delayRenderTimeouts = {};\n  }\n}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\nvar defaultTimeout = 30000;\nvar delayRenderInternal = ({\n  scope,\n  environment,\n  label,\n  options\n}) => {\n  if (typeof label !== \"string\" && label !== null) {\n    throw new Error(\"The label parameter of delayRender() must be a string or undefined, got: \" + JSON.stringify(label));\n  }\n  const handle = Math.random();\n  handles.push(handle);\n  const called = Error().stack?.replace(/^Error/g, \"\") ?? \"\";\n  if (environment.isRendering) {\n    const timeoutToUse = (options?.timeoutInMilliseconds ?? (typeof scope === \"undefined\" ? defaultTimeout : scope.remotion_puppeteerTimeout ?? defaultTimeout)) - 2000;\n    if (typeof scope !== \"undefined\") {\n      const retriesLeft = (options?.retries ?? 0) - (scope.remotion_attempt - 1);\n      scope.remotion_delayRenderTimeouts[handle] = {\n        label: label ?? null,\n        startTime: Date.now(),\n        timeout: setTimeout(() => {\n          const message = [\n            `A delayRender()`,\n            label ? `\"${label}\"` : null,\n            `was called but not cleared after ${timeoutToUse}ms. See https://remotion.dev/docs/timeout for help.`,\n            retriesLeft > 0 ? DELAY_RENDER_RETRIES_LEFT + retriesLeft : null,\n            retriesLeft > 0 ? DELAY_RENDER_RETRY_TOKEN : null,\n            DELAY_RENDER_CALLSTACK_TOKEN,\n            called\n          ].filter(truthy).join(\" \");\n          cancelRenderInternal(scope, Error(message));\n        }, timeoutToUse)\n      };\n    }\n  }\n  if (typeof scope !== \"undefined\") {\n    scope.remotion_renderReady = false;\n  }\n  return handle;\n};\nvar delayRender = (label, options) => {\n  return delayRenderInternal({\n    scope: typeof window !== \"undefined\" ? window : undefined,\n    environment: getRemotionEnvironment(),\n    label: label ?? null,\n    options: options ?? {}\n  });\n};\nvar continueRenderInternal = ({\n  scope,\n  handle,\n  environment,\n  logLevel\n}) => {\n  if (typeof handle === \"undefined\") {\n    throw new TypeError(\"The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.\");\n  }\n  if (typeof handle !== \"number\") {\n    throw new TypeError(\"The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: \" + JSON.stringify(handle));\n  }\n  handles = handles.filter((h) => {\n    if (h === handle) {\n      if (environment.isRendering && scope !== undefined) {\n        if (!scope.remotion_delayRenderTimeouts[handle]) {\n          return false;\n        }\n        const { label, startTime, timeout } = scope.remotion_delayRenderTimeouts[handle];\n        clearTimeout(timeout);\n        const message = [\n          label ? `\"${label}\"` : \"A handle\",\n          DELAY_RENDER_CLEAR_TOKEN,\n          `${Date.now() - startTime}ms`\n        ].filter(truthy).join(\" \");\n        Log.verbose({ logLevel, tag: \"delayRender()\" }, message);\n        delete scope.remotion_delayRenderTimeouts[handle];\n      }\n      return false;\n    }\n    return true;\n  });\n  if (handles.length === 0 && typeof scope !== \"undefined\") {\n    scope.remotion_renderReady = true;\n  }\n};\nvar continueRender = (handle) => {\n  continueRenderInternal({\n    scope: typeof window !== \"undefined\" ? window : undefined,\n    handle,\n    environment: getRemotionEnvironment(),\n    logLevel: typeof window !== \"undefined\" ? window.remotion_logLevel ?? \"info\" : \"info\"\n  });\n};\n\n// src/log-level-context.tsx\n\n\nvar LogLevelContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  logLevel: \"info\",\n  mountTime: 0\n});\nvar useLogLevel = () => {\n  const { logLevel } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n  if (logLevel === null) {\n    throw new Error(\"useLogLevel must be used within a LogLevelProvider\");\n  }\n  return logLevel;\n};\nvar useMountTime = () => {\n  const { mountTime } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n  if (mountTime === null) {\n    throw new Error(\"useMountTime must be used within a LogLevelProvider\");\n  }\n  return mountTime;\n};\n\n// src/use-delay-render.tsx\nvar DelayRenderContextType = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useDelayRender = () => {\n  const environment = useRemotionEnvironment();\n  const scope = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DelayRenderContextType);\n  const logLevel = useLogLevel();\n  const delayRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((label, options) => {\n    return delayRenderInternal({\n      scope: scope ?? (typeof window !== \"undefined\" ? window : undefined),\n      environment,\n      label: label ?? null,\n      options: options ?? {}\n    });\n  }, [environment, scope]);\n  const continueRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((handle) => {\n    continueRenderInternal({\n      scope: scope ?? (typeof window !== \"undefined\" ? window : undefined),\n      handle,\n      environment,\n      logLevel\n    });\n  }, [environment, logLevel, scope]);\n  const cancelRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((err) => {\n    return cancelRenderInternal(scope ?? (typeof window !== \"undefined\" ? window : undefined), err);\n  }, [scope]);\n  return { delayRender: delayRender2, continueRender: continueRender2, cancelRender: cancelRender2 };\n};\n\n// src/TimelineContext.tsx\n\nvar SetTimelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  setFrame: () => {\n    throw new Error(\"default\");\n  },\n  setPlaying: () => {\n    throw new Error(\"default\");\n  }\n});\nvar TimelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  frame: {},\n  playing: false,\n  playbackRate: 1,\n  rootId: \"\",\n  imperativePlaying: {\n    current: false\n  },\n  setPlaybackRate: () => {\n    throw new Error(\"default\");\n  },\n  audioAndVideoTags: { current: [] }\n});\nvar TimelineContextProvider = ({ children, frameState }) => {\n  const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n  const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(random(null)));\n  const [_frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => getInitialFrameState());\n  const frame = frameState ?? _frame;\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  if (typeof window !== \"undefined\") {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      window.remotion_setFrame = (f, composition, attempt) => {\n        window.remotion_attempt = attempt;\n        const id = delayRender2(`Setting the current frame to ${f}`);\n        let asyncUpdate = true;\n        setFrame((s) => {\n          const currentFrame = s[composition] ?? window.remotion_initialFrame;\n          if (currentFrame === f) {\n            asyncUpdate = false;\n            return s;\n          }\n          return {\n            ...s,\n            [composition]: f\n          };\n        });\n        if (asyncUpdate) {\n          requestAnimationFrame(() => continueRender2(id));\n        } else {\n          continueRender2(id);\n        }\n      };\n      window.remotion_isPlayer = false;\n    }, [continueRender2, delayRender2]);\n  }\n  const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      frame,\n      playing,\n      imperativePlaying,\n      rootId: remotionRootId,\n      playbackRate,\n      setPlaybackRate,\n      audioAndVideoTags\n    };\n  }, [frame, playbackRate, playing, remotionRootId]);\n  const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      setFrame,\n      setPlaying\n    };\n  }, []);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n    value: timelineContextValue,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n      value: setTimelineContextValue,\n      children\n    })\n  });\n};\n\n// src/use-video-config.ts\n\n\n// src/CanUseRemotionHooks.tsx\n\n\nvar CanUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar CanUseRemotionHooksProvider = ({ children }) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n    value: true,\n    children\n  });\n};\n\n// src/use-unsafe-video-config.ts\n\nvar useUnsafeVideoConfig = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const ctxWidth = context?.width ?? null;\n  const ctxHeight = context?.height ?? null;\n  const ctxDuration = context?.durationInFrames ?? null;\n  const video = useVideo();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!video) {\n      return null;\n    }\n    const {\n      id,\n      durationInFrames,\n      fps,\n      height,\n      width,\n      defaultProps,\n      props,\n      defaultCodec,\n      defaultOutName,\n      defaultVideoImageFormat,\n      defaultPixelFormat,\n      defaultProResProfile\n    } = video;\n    return {\n      id,\n      width: ctxWidth ?? width,\n      height: ctxHeight ?? height,\n      fps,\n      durationInFrames: ctxDuration ?? durationInFrames,\n      defaultProps,\n      props,\n      defaultCodec,\n      defaultOutName,\n      defaultVideoImageFormat,\n      defaultPixelFormat,\n      defaultProResProfile\n    };\n  }, [ctxDuration, ctxHeight, ctxWidth, video]);\n};\n\n// src/use-video-config.ts\nvar useVideoConfig = () => {\n  const videoConfig = useUnsafeVideoConfig();\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n  const isPlayer = useIsPlayer();\n  if (!videoConfig) {\n    if (typeof window !== \"undefined\" && window.remotion_isPlayer || isPlayer) {\n      throw new Error([\n        \"No video config found. Likely reasons:\",\n        \"- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.\",\n        \"- You have multiple versions of Remotion installed which causes the React context to get lost.\"\n      ].join(\"-\"));\n    }\n    throw new Error(\"No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.\");\n  }\n  if (!context) {\n    throw new Error(\"Called useVideoConfig() outside a Remotion composition.\");\n  }\n  return videoConfig;\n};\n\n// src/freeze.tsx\n\n\n// src/use-current-frame.ts\n\nvar useCurrentFrame = () => {\n  const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n  const env = useRemotionEnvironment();\n  if (!canUseRemotionHooks) {\n    if (env.isPlayer) {\n      throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);\n    }\n    throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);\n  }\n  const frame = useTimelinePosition();\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const contextOffset = context ? context.cumulatedFrom + context.relativeFrom : 0;\n  return frame - contextOffset;\n};\n\n// src/freeze.tsx\n\nvar Freeze = ({\n  frame: frameToFreeze,\n  children,\n  active = true\n}) => {\n  const frame = useCurrentFrame();\n  const videoConfig = useVideoConfig();\n  if (typeof frameToFreeze === \"undefined\") {\n    throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);\n  }\n  if (typeof frameToFreeze !== \"number\") {\n    throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frameToFreeze}`);\n  }\n  if (Number.isNaN(frameToFreeze)) {\n    throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);\n  }\n  if (!Number.isFinite(frameToFreeze)) {\n    throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frameToFreeze}.`);\n  }\n  const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (typeof active === \"boolean\") {\n      return active;\n    }\n    if (typeof active === \"function\") {\n      return active(frame);\n    }\n  }, [active, frame]);\n  const timelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const relativeFrom = sequenceContext?.relativeFrom ?? 0;\n  const timelineValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!isActive) {\n      return timelineContext;\n    }\n    return {\n      ...timelineContext,\n      playing: false,\n      imperativePlaying: {\n        current: false\n      },\n      frame: {\n        [videoConfig.id]: frameToFreeze + relativeFrom\n      }\n    };\n  }, [isActive, timelineContext, videoConfig.id, frameToFreeze, relativeFrom]);\n  const newSequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!sequenceContext) {\n      return null;\n    }\n    if (!isActive) {\n      return sequenceContext;\n    }\n    return {\n      ...sequenceContext,\n      cumulatedFrom: 0\n    };\n  }, [sequenceContext, isActive]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n    value: timelineValue,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n      value: newSequenceContext,\n      children\n    })\n  });\n};\n\n// src/Sequence.tsx\n\nvar RegularSequenceRefForwardingFunction = ({\n  from = 0,\n  durationInFrames = Infinity,\n  children,\n  name,\n  height,\n  width,\n  showInTimeline = true,\n  _remotionInternalLoopDisplay: loopDisplay,\n  _remotionInternalStack: stack,\n  _remotionInternalPremountDisplay: premountDisplay,\n  _remotionInternalPostmountDisplay: postmountDisplay,\n  ...other\n}, ref) => {\n  const { layout = \"absolute-fill\" } = other;\n  const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const cumulatedFrom = parentSequence ? parentSequence.cumulatedFrom + parentSequence.relativeFrom : 0;\n  const nonce = useNonce();\n  if (layout !== \"absolute-fill\" && layout !== \"none\") {\n    throw new TypeError(`The layout prop of <Sequence /> expects either \"absolute-fill\" or \"none\", but you passed: ${layout}`);\n  }\n  if (layout === \"none\" && typeof other.style !== \"undefined\") {\n    throw new TypeError('If layout=\"none\", you may not pass a style.');\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);\n  }\n  if (typeof from !== \"number\") {\n    throw new TypeError(`You passed to the \"from\" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);\n  }\n  if (!Number.isFinite(from)) {\n    throw new TypeError(`The \"from\" prop of a sequence must be finite, but got ${from}.`);\n  }\n  const absoluteFrame = useTimelinePosition();\n  const videoConfig = useVideoConfig();\n  const parentSequenceDuration = parentSequence ? Math.min(parentSequence.durationInFrames - from, durationInFrames) : durationInFrames;\n  const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));\n  const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n  const premounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return parentSequence?.premounting || Boolean(other._remotionInternalIsPremounting);\n  }, [other._remotionInternalIsPremounting, parentSequence?.premounting]);\n  const postmounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return parentSequence?.postmounting || Boolean(other._remotionInternalIsPostmounting);\n  }, [other._remotionInternalIsPostmounting, parentSequence?.postmounting]);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      cumulatedFrom,\n      relativeFrom: from,\n      durationInFrames: actualDurationInFrames,\n      parentFrom: parentSequence?.relativeFrom ?? 0,\n      id,\n      height: height ?? parentSequence?.height ?? null,\n      width: width ?? parentSequence?.width ?? null,\n      premounting,\n      postmounting,\n      premountDisplay: premountDisplay ?? null,\n      postmountDisplay: postmountDisplay ?? null\n    };\n  }, [\n    cumulatedFrom,\n    from,\n    actualDurationInFrames,\n    parentSequence,\n    id,\n    height,\n    width,\n    premounting,\n    postmounting,\n    premountDisplay,\n    postmountDisplay\n  ]);\n  const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return name ?? \"\";\n  }, [name]);\n  const env = useRemotionEnvironment();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!env.isStudio) {\n      return;\n    }\n    registerSequence({\n      from,\n      duration: actualDurationInFrames,\n      id,\n      displayName: timelineClipName,\n      parent: parentSequence?.id ?? null,\n      type: \"sequence\",\n      rootId,\n      showInTimeline,\n      nonce,\n      loopDisplay,\n      stack: stack ?? null,\n      premountDisplay: premountDisplay ?? null,\n      postmountDisplay: postmountDisplay ?? null\n    });\n    return () => {\n      unregisterSequence(id);\n    };\n  }, [\n    durationInFrames,\n    id,\n    name,\n    registerSequence,\n    timelineClipName,\n    unregisterSequence,\n    parentSequence?.id,\n    actualDurationInFrames,\n    rootId,\n    from,\n    showInTimeline,\n    nonce,\n    loopDisplay,\n    stack,\n    premountDisplay,\n    postmountDisplay,\n    env.isStudio\n  ]);\n  const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);\n  const content = absoluteFrame < cumulatedFrom + from ? null : absoluteFrame > endThreshold ? null : children;\n  const styleIfThere = other.layout === \"none\" ? undefined : other.style;\n  const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      flexDirection: undefined,\n      ...width ? { width } : {},\n      ...height ? { height } : {},\n      ...styleIfThere ?? {}\n    };\n  }, [height, styleIfThere, width]);\n  if (ref !== null && layout === \"none\") {\n    throw new TypeError('It is not supported to pass both a `ref` and `layout=\"none\"` to <Sequence />.');\n  }\n  const isSequenceHidden = hidden[id] ?? false;\n  if (isSequenceHidden) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n    value: contextValue,\n    children: content === null ? null : other.layout === \"none\" ? content : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n      ref,\n      style: defaultStyle,\n      className: other.className,\n      children: content\n    })\n  });\n};\nvar RegularSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(RegularSequenceRefForwardingFunction);\nvar PremountedPostmountedSequenceRefForwardingFunction = (props, ref) => {\n  const frame = useCurrentFrame();\n  if (props.layout === \"none\") {\n    throw new Error('`<Sequence>` with `premountFor` and `postmountFor` props does not support layout=\"none\"');\n  }\n  const {\n    style: passedStyle,\n    from = 0,\n    durationInFrames = Infinity,\n    premountFor = 0,\n    postmountFor = 0,\n    styleWhilePremounted,\n    styleWhilePostmounted,\n    ...otherProps\n  } = props;\n  const endThreshold = Math.ceil(from + durationInFrames - 1);\n  const premountingActive = frame < from && frame >= from - premountFor;\n  const postmountingActive = frame > endThreshold && frame <= endThreshold + postmountFor;\n  const freezeFrame = premountingActive ? from : postmountingActive ? from + durationInFrames - 1 : 0;\n  const isFreezingActive = premountingActive || postmountingActive;\n  const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...passedStyle,\n      opacity: premountingActive || postmountingActive ? 0 : 1,\n      pointerEvents: premountingActive || postmountingActive ? \"none\" : passedStyle?.pointerEvents ?? undefined,\n      ...premountingActive ? styleWhilePremounted : {},\n      ...postmountingActive ? styleWhilePostmounted : {}\n    };\n  }, [\n    passedStyle,\n    premountingActive,\n    postmountingActive,\n    styleWhilePremounted,\n    styleWhilePostmounted\n  ]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Freeze, {\n    frame: freezeFrame,\n    active: isFreezingActive,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      ref,\n      from,\n      durationInFrames,\n      style,\n      _remotionInternalPremountDisplay: premountFor,\n      _remotionInternalPostmountDisplay: postmountFor,\n      _remotionInternalIsPremounting: premountingActive,\n      _remotionInternalIsPostmounting: postmountingActive,\n      ...otherProps\n    })\n  });\n};\nvar PremountedPostmountedSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PremountedPostmountedSequenceRefForwardingFunction);\nvar SequenceRefForwardingFunction = (props, ref) => {\n  const env = useRemotionEnvironment();\n  if (props.layout !== \"none\" && !env.isRendering) {\n    if (props.premountFor || props.postmountFor) {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PremountedPostmountedSequence, {\n        ...props,\n        ref\n      });\n    }\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RegularSequence, {\n    ...props,\n    ref\n  });\n};\nvar Sequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);\n// src/animated-image/AnimatedImage.tsx\n\n\n// src/animated-image/canvas.tsx\n\n\nvar calcArgs = (fit, frameSize, canvasSize) => {\n  switch (fit) {\n    case \"fill\": {\n      return [\n        0,\n        0,\n        frameSize.width,\n        frameSize.height,\n        0,\n        0,\n        canvasSize.width,\n        canvasSize.height\n      ];\n    }\n    case \"contain\": {\n      const ratio = Math.min(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n      const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n      const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n      return [\n        0,\n        0,\n        frameSize.width,\n        frameSize.height,\n        centerX,\n        centerY,\n        frameSize.width * ratio,\n        frameSize.height * ratio\n      ];\n    }\n    case \"cover\": {\n      const ratio = Math.max(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n      const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n      const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n      return [\n        0,\n        0,\n        frameSize.width,\n        frameSize.height,\n        centerX,\n        centerY,\n        frameSize.width * ratio,\n        frameSize.height * ratio\n      ];\n    }\n    default:\n      throw new Error(\"Unknown fit: \" + fit);\n  }\n};\nvar CanvasRefForwardingFunction = ({ width, height, fit, className, style }, ref) => {\n  const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((imageData) => {\n    const canvas = canvasRef.current;\n    const canvasWidth = width ?? imageData.displayWidth;\n    const canvasHeight = height ?? imageData.displayHeight;\n    if (!canvas) {\n      throw new Error(\"Canvas ref is not set\");\n    }\n    const ctx = canvasRef.current?.getContext(\"2d\");\n    if (!ctx) {\n      throw new Error(\"Could not get 2d context\");\n    }\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    ctx.drawImage(imageData, ...calcArgs(fit, {\n      height: imageData.displayHeight,\n      width: imageData.displayWidth\n    }, {\n      width: canvasWidth,\n      height: canvasHeight\n    }));\n  }, [fit, height, width]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return {\n      draw,\n      getCanvas: () => {\n        if (!canvasRef.current) {\n          throw new Error(\"Canvas ref is not set\");\n        }\n        return canvasRef.current;\n      },\n      clear: () => {\n        const ctx = canvasRef.current?.getContext(\"2d\");\n        if (!ctx) {\n          throw new Error(\"Could not get 2d context\");\n        }\n        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n      }\n    };\n  }, [draw]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"canvas\", {\n    ref: canvasRef,\n    className,\n    style\n  });\n};\nvar Canvas = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CanvasRefForwardingFunction);\n\n// src/animated-image/decode-image.ts\nvar CACHE_SIZE = 5;\nvar getActualTime = ({\n  loopBehavior,\n  durationFound,\n  timeInSec\n}) => {\n  return loopBehavior === \"loop\" ? durationFound ? timeInSec % durationFound : timeInSec : Math.min(timeInSec, durationFound || Infinity);\n};\nvar decodeImage = async ({\n  resolvedSrc,\n  signal,\n  currentTime,\n  initialLoopBehavior\n}) => {\n  if (typeof ImageDecoder === \"undefined\") {\n    throw new Error(\"Your browser does not support the WebCodecs ImageDecoder API.\");\n  }\n  const res = await fetch(resolvedSrc, { signal });\n  const { body } = res;\n  if (!body) {\n    throw new Error(\"Got no body\");\n  }\n  const decoder = new ImageDecoder({\n    data: body,\n    type: res.headers.get(\"Content-Type\") || \"image/gif\"\n  });\n  await decoder.completed;\n  const { selectedTrack } = decoder.tracks;\n  if (!selectedTrack) {\n    throw new Error(\"No selected track\");\n  }\n  const cache = [];\n  let durationFound = null;\n  const getFrameByIndex = async (frameIndex) => {\n    const foundInCache = cache.find((c) => c.frameIndex === frameIndex);\n    if (foundInCache && foundInCache.frame) {\n      return foundInCache;\n    }\n    const frame = await decoder.decode({\n      frameIndex,\n      completeFramesOnly: true\n    });\n    if (foundInCache) {\n      foundInCache.frame = frame.image;\n    } else {\n      cache.push({\n        frame: frame.image,\n        frameIndex,\n        timeInSeconds: frame.image.timestamp / 1e6\n      });\n    }\n    return {\n      frame: frame.image,\n      frameIndex,\n      timeInSeconds: frame.image.timestamp / 1e6\n    };\n  };\n  const clearCache = (closeToTimeInSec) => {\n    const itemsInCache = cache.filter((c) => c.frame);\n    const sortByClosestToCurrentTime = itemsInCache.sort((a, b) => {\n      const aDiff = Math.abs(a.timeInSeconds - closeToTimeInSec);\n      const bDiff = Math.abs(b.timeInSeconds - closeToTimeInSec);\n      return aDiff - bDiff;\n    });\n    for (let i = 0;i < sortByClosestToCurrentTime.length; i++) {\n      if (i < CACHE_SIZE) {\n        continue;\n      }\n      const item = sortByClosestToCurrentTime[i];\n      item.frame = null;\n    }\n  };\n  const ensureFrameBeforeAndAfter = async ({\n    timeInSec,\n    loopBehavior\n  }) => {\n    const actualTimeInSec = getActualTime({\n      durationFound,\n      loopBehavior,\n      timeInSec\n    });\n    const framesBefore = cache.filter((c) => c.timeInSeconds <= actualTimeInSec);\n    const biggestIndex = framesBefore.map((c) => c.frameIndex).reduce((a, b) => Math.max(a, b), 0);\n    let i = biggestIndex;\n    while (true) {\n      const f = await getFrameByIndex(i);\n      i++;\n      if (!f.frame) {\n        throw new Error(\"No frame found\");\n      }\n      if (!f.frame.duration) {\n        break;\n      }\n      if (i === selectedTrack.frameCount && durationFound === null) {\n        const duration = (f.frame.timestamp + f.frame.duration) / 1e6;\n        durationFound = duration;\n      }\n      if (f.timeInSeconds > actualTimeInSec || i === selectedTrack.frameCount) {\n        break;\n      }\n    }\n    if (selectedTrack.frameCount - biggestIndex < 3 && loopBehavior === \"loop\") {\n      await getFrameByIndex(0);\n    }\n    clearCache(actualTimeInSec);\n  };\n  await ensureFrameBeforeAndAfter({\n    timeInSec: currentTime,\n    loopBehavior: initialLoopBehavior\n  });\n  await ensureFrameBeforeAndAfter({\n    timeInSec: currentTime,\n    loopBehavior: initialLoopBehavior\n  });\n  const getFrame = async (timeInSec, loopBehavior) => {\n    if (durationFound !== null && timeInSec > durationFound && loopBehavior === \"clear-after-finish\") {\n      return null;\n    }\n    const actualTimeInSec = getActualTime({\n      loopBehavior,\n      durationFound,\n      timeInSec\n    });\n    await ensureFrameBeforeAndAfter({ timeInSec: actualTimeInSec, loopBehavior });\n    const itemsInCache = cache.filter((c) => c.frame);\n    const closest = itemsInCache.reduce((a, b) => {\n      const aDiff = Math.abs(a.timeInSeconds - actualTimeInSec);\n      const bDiff = Math.abs(b.timeInSeconds - actualTimeInSec);\n      return aDiff < bDiff ? a : b;\n    });\n    if (!closest.frame) {\n      throw new Error(\"No frame found\");\n    }\n    return closest;\n  };\n  return {\n    getFrame,\n    frameCount: selectedTrack.frameCount\n  };\n};\n\n// src/animated-image/resolve-image-source.tsx\nvar resolveAnimatedImageSource = (src) => {\n  if (typeof window === \"undefined\") {\n    return src;\n  }\n  return new URL(src, window.origin).href;\n};\n\n// src/animated-image/AnimatedImage.tsx\n\nvar AnimatedImage = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({\n  src,\n  width,\n  height,\n  onError,\n  loopBehavior = \"loop\",\n  playbackRate = 1,\n  fit = \"fill\",\n  ...props\n}, canvasRef) => {\n  const mountState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ isMounted: true });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = mountState;\n    current.isMounted = true;\n    return () => {\n      current.isMounted = false;\n    };\n  }, []);\n  const resolvedSrc = resolveAnimatedImageSource(src);\n  const [imageDecoder, setImageDecoder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  const [decodeHandle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => delayRender2(`Rendering <AnimatedImage/> with src=\"${resolvedSrc}\"`));\n  const frame = useCurrentFrame();\n  const { fps } = useVideoConfig();\n  const currentTime = frame / playbackRate / fps;\n  const currentTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentTime);\n  currentTimeRef.current = currentTime;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(canvasRef, () => {\n    const c = ref.current?.getCanvas();\n    if (!c) {\n      throw new Error(\"Canvas ref is not set\");\n    }\n    return c;\n  }, []);\n  const [initialLoopBehavior] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => loopBehavior);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const controller = new AbortController;\n    decodeImage({\n      resolvedSrc,\n      signal: controller.signal,\n      currentTime: currentTimeRef.current,\n      initialLoopBehavior\n    }).then((d) => {\n      setImageDecoder(d);\n      continueRender2(decodeHandle);\n    }).catch((err) => {\n      if (err.name === \"AbortError\") {\n        continueRender2(decodeHandle);\n        return;\n      }\n      if (onError) {\n        onError?.(err);\n        continueRender2(decodeHandle);\n      } else {\n        cancelRender(err);\n      }\n    });\n    return () => {\n      controller.abort();\n    };\n  }, [\n    resolvedSrc,\n    decodeHandle,\n    onError,\n    initialLoopBehavior,\n    continueRender2\n  ]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!imageDecoder) {\n      return;\n    }\n    const delay = delayRender2(`Rendering frame at ${currentTime} of <AnimatedImage src=\"${src}\"/>`);\n    imageDecoder.getFrame(currentTime, loopBehavior).then((videoFrame) => {\n      if (mountState.current.isMounted) {\n        if (videoFrame === null) {\n          ref.current?.clear();\n        } else {\n          ref.current?.draw(videoFrame.frame);\n        }\n      }\n      continueRender2(delay);\n    }).catch((err) => {\n      if (onError) {\n        onError(err);\n        continueRender2(delay);\n      } else {\n        cancelRender(err);\n      }\n    });\n  }, [\n    currentTime,\n    imageDecoder,\n    loopBehavior,\n    onError,\n    src,\n    continueRender2,\n    delayRender2\n  ]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Canvas, {\n    ref,\n    width,\n    height,\n    fit,\n    ...props\n  });\n});\n// src/Artifact.tsx\n\n\n// src/RenderAssetManager.tsx\n\n\n\n// src/validation/validate-artifact.ts\nvar validateArtifactFilename = (filename) => {\n  if (typeof filename !== \"string\") {\n    throw new TypeError(`The \"filename\" must be a string, but you passed a value of type ${typeof filename}`);\n  }\n  if (filename.trim() === \"\") {\n    throw new Error(\"The `filename` must not be empty\");\n  }\n  if (!filename.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {\n    throw new Error('The `filename` must match \"/^([0-9a-zA-Z-!_.*\\'()/:&$@=;+,?]+)/g\". Use forward slashes only, even on Windows.');\n  }\n};\nvar validateContent = (content) => {\n  if (typeof content !== \"string\" && !(content instanceof Uint8Array)) {\n    throw new TypeError(`The \"content\" must be a string or Uint8Array, but you passed a value of type ${typeof content}`);\n  }\n  if (typeof content === \"string\" && content.trim() === \"\") {\n    throw new Error(\"The `content` must not be empty\");\n  }\n};\nvar validateRenderAsset = (artifact) => {\n  if (artifact.type !== \"artifact\") {\n    return;\n  }\n  validateArtifactFilename(artifact.filename);\n  if (artifact.contentType === \"thumbnail\") {\n    return;\n  }\n  validateContent(artifact.content);\n};\n\n// src/RenderAssetManager.tsx\n\nvar RenderAssetManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  registerRenderAsset: () => {\n    return;\n  },\n  unregisterRenderAsset: () => {\n    return;\n  },\n  renderAssets: []\n});\nvar RenderAssetManagerProvider = ({ children, collectAssets }) => {\n  const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((renderAsset) => {\n    validateRenderAsset(renderAsset);\n    setRenderAssets((assets) => {\n      return [...assets, renderAsset];\n    });\n  }, []);\n  if (collectAssets) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(collectAssets, () => {\n      return {\n        collectAssets: () => {\n          (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync)(() => {\n            setRenderAssets([]);\n          });\n          return renderAssets;\n        }\n      };\n    }, [renderAssets]);\n  }\n  const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n    setRenderAssets((assts) => {\n      return assts.filter((a) => a.id !== id);\n    });\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (typeof window !== \"undefined\") {\n      window.remotion_collectAssets = () => {\n        setRenderAssets([]);\n        return renderAssets;\n      };\n    }\n  }, [renderAssets]);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      registerRenderAsset,\n      unregisterRenderAsset,\n      renderAssets\n    };\n  }, [renderAssets, registerRenderAsset, unregisterRenderAsset]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n    value: contextValue,\n    children\n  });\n};\n\n// src/Artifact.tsx\nvar ArtifactThumbnail = Symbol(\"Thumbnail\");\nvar Artifact = ({ filename, content, downloadBehavior }) => {\n  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n  const env = useRemotionEnvironment();\n  const frame = useCurrentFrame();\n  const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n    return String(Math.random());\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!env.isRendering) {\n      return;\n    }\n    if (content instanceof Uint8Array) {\n      registerRenderAsset({\n        type: \"artifact\",\n        id,\n        content: btoa(new TextDecoder(\"utf8\").decode(content)),\n        filename,\n        frame,\n        contentType: \"binary\",\n        downloadBehavior: downloadBehavior ?? null\n      });\n    } else if (content === ArtifactThumbnail) {\n      registerRenderAsset({\n        type: \"artifact\",\n        id,\n        filename,\n        frame,\n        contentType: \"thumbnail\",\n        downloadBehavior: downloadBehavior ?? null\n      });\n    } else {\n      registerRenderAsset({\n        type: \"artifact\",\n        id,\n        content,\n        filename,\n        frame,\n        contentType: \"text\",\n        downloadBehavior: downloadBehavior ?? null\n      });\n    }\n    return () => {\n      return unregisterRenderAsset(id);\n    };\n  }, [\n    content,\n    env.isRendering,\n    filename,\n    frame,\n    id,\n    registerRenderAsset,\n    unregisterRenderAsset,\n    downloadBehavior\n  ]);\n  return null;\n};\nArtifact.Thumbnail = ArtifactThumbnail;\n// src/audio/Audio.tsx\n\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc) => {\n  if (typeof window === \"undefined\") {\n    return relativeSrc;\n  }\n  if (relativeSrc.startsWith(\"http://\") || relativeSrc.startsWith(\"https://\") || relativeSrc.startsWith(\"file://\") || relativeSrc.startsWith(\"blob:\") || relativeSrc.startsWith(\"data:\")) {\n    return relativeSrc;\n  }\n  return new URL(relativeSrc, window.origin).href;\n};\n\n// src/calculate-media-duration.ts\nvar calculateMediaDuration = ({\n  trimAfter,\n  mediaDurationInFrames,\n  playbackRate,\n  trimBefore\n}) => {\n  let duration = mediaDurationInFrames;\n  if (typeof trimAfter !== \"undefined\") {\n    duration = trimAfter;\n  }\n  if (typeof trimBefore !== \"undefined\") {\n    duration -= trimBefore;\n  }\n  const actualDuration = duration / playbackRate;\n  return Math.floor(actualDuration);\n};\n\n// src/loop/index.tsx\n\n\nvar LoopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useLoop = () => {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LoopContext);\n};\nvar Loop = ({ durationInFrames, times = Infinity, children, name, ...props }) => {\n  const currentFrame = useCurrentFrame();\n  const { durationInFrames: compDuration } = useVideoConfig();\n  validateDurationInFrames(durationInFrames, {\n    component: \"of the <Loop /> component\",\n    allowFloats: true\n  });\n  if (typeof times !== \"number\") {\n    throw new TypeError(`You passed to \"times\" an argument of type ${typeof times}, but it must be a number.`);\n  }\n  if (times !== Infinity && times % 1 !== 0) {\n    throw new TypeError(`The \"times\" prop of a loop must be an integer, but got ${times}.`);\n  }\n  if (times < 0) {\n    throw new TypeError(`The \"times\" prop of a loop must be at least 0, but got ${times}`);\n  }\n  const maxTimes = Math.ceil(compDuration / durationInFrames);\n  const actualTimes = Math.min(maxTimes, times);\n  const style = props.layout === \"none\" ? undefined : props.style;\n  const maxFrame = durationInFrames * (actualTimes - 1);\n  const iteration = Math.floor(currentFrame / durationInFrames);\n  const start = iteration * durationInFrames;\n  const from = Math.min(start, maxFrame);\n  const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      numberOfTimes: actualTimes,\n      startOffset: -from,\n      durationInFrames\n    };\n  }, [actualTimes, durationInFrames, from]);\n  const loopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      iteration: Math.floor(currentFrame / durationInFrames),\n      durationInFrames\n    };\n  }, [currentFrame, durationInFrames]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LoopContext.Provider, {\n    value: loopContext,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      durationInFrames,\n      from,\n      name: name ?? \"<Loop>\",\n      _remotionInternalLoopDisplay: loopDisplay,\n      layout: props.layout,\n      style,\n      children\n    })\n  });\n};\nLoop.useLoop = useLoop;\n\n// src/prefetch.ts\n\n\n// src/playback-logging.ts\nvar playbackLogging = ({\n  logLevel,\n  tag,\n  message,\n  mountTime\n}) => {\n  const tags = [mountTime ? Date.now() - mountTime + \"ms \" : null, tag].filter(Boolean).join(\" \");\n  Log.trace({ logLevel, tag: null }, `[${tags}]`, message);\n};\n\n// src/prefetch-state.tsx\n\n\nvar PreloadContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar preloads = {};\nvar updaters = [];\nvar setPreloads = (updater) => {\n  preloads = updater(preloads);\n  updaters.forEach((u) => u());\n};\nvar PrefetchProvider = ({ children }) => {\n  const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => preloads);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const updaterFunction = () => {\n      _setPreloads(preloads);\n    };\n    updaters.push(updaterFunction);\n    return () => {\n      updaters = updaters.filter((u) => u !== updaterFunction);\n    };\n  }, []);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n    value: _preloads,\n    children\n  });\n};\n\n// src/prefetch.ts\nvar removeAndGetHashFragment = (src) => {\n  const hashIndex = src.indexOf(\"#\");\n  if (hashIndex === -1) {\n    return null;\n  }\n  return hashIndex;\n};\nvar getSrcWithoutHash = (src) => {\n  const hashIndex = removeAndGetHashFragment(src);\n  if (hashIndex === null) {\n    return src;\n  }\n  return src.slice(0, hashIndex);\n};\nvar usePreload = (src) => {\n  const preloads2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);\n  const hashFragmentIndex = removeAndGetHashFragment(src);\n  const withoutHashFragment = getSrcWithoutHash(src);\n  if (!preloads2[withoutHashFragment]) {\n    return src;\n  }\n  if (hashFragmentIndex !== null) {\n    return preloads2[withoutHashFragment] + src.slice(hashFragmentIndex);\n  }\n  return preloads2[withoutHashFragment];\n};\nvar blobToBase64 = function(blob) {\n  const reader = new FileReader;\n  return new Promise((resolve, reject) => {\n    reader.onload = function() {\n      const dataUrl = reader.result;\n      resolve(dataUrl);\n    };\n    reader.onerror = (err) => {\n      return reject(err);\n    };\n    reader.readAsDataURL(blob);\n  });\n};\nvar getBlobFromReader = async ({\n  reader,\n  contentType,\n  contentLength,\n  onProgress\n}) => {\n  let receivedLength = 0;\n  const chunks = [];\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    chunks.push(value);\n    receivedLength += value.length;\n    if (onProgress) {\n      onProgress({ loadedBytes: receivedLength, totalBytes: contentLength });\n    }\n  }\n  const chunksAll = new Uint8Array(receivedLength);\n  let position = 0;\n  for (const chunk of chunks) {\n    chunksAll.set(chunk, position);\n    position += chunk.length;\n  }\n  return new Blob([chunksAll], {\n    type: contentType ?? undefined\n  });\n};\nvar prefetch = (src, options) => {\n  const method = options?.method ?? \"blob-url\";\n  const logLevel = options?.logLevel ?? \"info\";\n  const srcWithoutHash = getSrcWithoutHash(src);\n  if (getRemotionEnvironment().isRendering) {\n    return {\n      free: () => {\n        return;\n      },\n      waitUntilDone: () => Promise.resolve(srcWithoutHash)\n    };\n  }\n  Log.verbose({ logLevel, tag: \"prefetch\" }, `Starting prefetch ${srcWithoutHash}`);\n  let canceled = false;\n  let objectUrl = null;\n  let resolve = () => {\n    return;\n  };\n  let reject = () => {\n    return;\n  };\n  const waitUntilDone = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  const controller = new AbortController;\n  let canBeAborted = true;\n  fetch(srcWithoutHash, {\n    signal: controller.signal,\n    credentials: options?.credentials ?? undefined\n  }).then((res) => {\n    canBeAborted = false;\n    if (canceled) {\n      return null;\n    }\n    if (!res.ok) {\n      throw new Error(`HTTP error, status = ${res.status}`);\n    }\n    const headerContentType = res.headers.get(\"Content-Type\");\n    const contentType = options?.contentType ?? headerContentType;\n    const hasProperContentType = contentType && (contentType.startsWith(\"video/\") || contentType.startsWith(\"audio/\") || contentType.startsWith(\"image/\"));\n    if (!hasProperContentType) {\n      console.warn(`Called prefetch() on ${srcWithoutHash} which returned a \"Content-Type\" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);\n    }\n    if (!res.body) {\n      throw new Error(`HTTP response of ${srcWithoutHash} has no body`);\n    }\n    const reader = res.body.getReader();\n    return getBlobFromReader({\n      reader,\n      contentType: options?.contentType ?? headerContentType ?? null,\n      contentLength: res.headers.get(\"Content-Length\") ? parseInt(res.headers.get(\"Content-Length\"), 10) : null,\n      onProgress: options?.onProgress\n    });\n  }).then((buf) => {\n    if (!buf) {\n      return;\n    }\n    const actualBlob = options?.contentType ? new Blob([buf], { type: options.contentType }) : buf;\n    if (method === \"base64\") {\n      return blobToBase64(actualBlob);\n    }\n    return URL.createObjectURL(actualBlob);\n  }).then((url) => {\n    if (canceled) {\n      return;\n    }\n    playbackLogging({\n      logLevel,\n      tag: \"prefetch\",\n      message: `Finished prefetch ${srcWithoutHash} with method ${method}`,\n      mountTime: null\n    });\n    objectUrl = url;\n    setPreloads((p) => ({\n      ...p,\n      [srcWithoutHash]: objectUrl\n    }));\n    resolve(objectUrl);\n  }).catch((err) => {\n    if (err?.message.includes(\"free() called\")) {\n      return;\n    }\n    reject(err);\n  });\n  return {\n    free: () => {\n      playbackLogging({\n        logLevel,\n        tag: \"prefetch\",\n        message: `Freeing ${srcWithoutHash}`,\n        mountTime: null\n      });\n      if (objectUrl) {\n        if (method === \"blob-url\") {\n          URL.revokeObjectURL(objectUrl);\n        }\n        setPreloads((p) => {\n          const copy = { ...p };\n          delete copy[srcWithoutHash];\n          return copy;\n        });\n      } else {\n        canceled = true;\n        if (canBeAborted) {\n          try {\n            controller.abort(new Error(\"free() called\"));\n          } catch {}\n        }\n      }\n    },\n    waitUntilDone: () => {\n      return waitUntilDone;\n    }\n  };\n};\n\n// src/validate-media-props.ts\nvar validateMediaProps = (props, component) => {\n  if (typeof props.volume !== \"number\" && typeof props.volume !== \"function\" && typeof props.volume !== \"undefined\") {\n    throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);\n  }\n  if (typeof props.volume === \"number\" && props.volume < 0) {\n    throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);\n  }\n  if (typeof props.playbackRate !== \"number\" && typeof props.playbackRate !== \"undefined\") {\n    throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);\n  }\n  if (typeof props.playbackRate === \"number\" && (isNaN(props.playbackRate) || !Number.isFinite(props.playbackRate) || props.playbackRate <= 0)) {\n    throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);\n  }\n};\n\n// src/validate-start-from-props.ts\nvar validateStartFromProps = (startFrom, endAt) => {\n  if (typeof startFrom !== \"undefined\") {\n    if (typeof startFrom !== \"number\") {\n      throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);\n    }\n    if (isNaN(startFrom) || startFrom === Infinity) {\n      throw new TypeError(\"startFrom prop can not be NaN or Infinity.\");\n    }\n    if (startFrom < 0) {\n      throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);\n    }\n  }\n  if (typeof endAt !== \"undefined\") {\n    if (typeof endAt !== \"number\") {\n      throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);\n    }\n    if (isNaN(endAt)) {\n      throw new TypeError(\"endAt prop can not be NaN.\");\n    }\n    if (endAt <= 0) {\n      throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);\n    }\n  }\n  if (endAt < startFrom) {\n    throw new TypeError(\"endAt prop must be greater than startFrom prop.\");\n  }\n};\nvar validateTrimProps = (trimBefore, trimAfter) => {\n  if (typeof trimBefore !== \"undefined\") {\n    if (typeof trimBefore !== \"number\") {\n      throw new TypeError(`type of trimBefore prop must be a number, instead got type ${typeof trimBefore}.`);\n    }\n    if (isNaN(trimBefore) || trimBefore === Infinity) {\n      throw new TypeError(\"trimBefore prop can not be NaN or Infinity.\");\n    }\n    if (trimBefore < 0) {\n      throw new TypeError(`trimBefore must be greater than equal to 0 instead got ${trimBefore}.`);\n    }\n  }\n  if (typeof trimAfter !== \"undefined\") {\n    if (typeof trimAfter !== \"number\") {\n      throw new TypeError(`type of trimAfter prop must be a number, instead got type ${typeof trimAfter}.`);\n    }\n    if (isNaN(trimAfter)) {\n      throw new TypeError(\"trimAfter prop can not be NaN.\");\n    }\n    if (trimAfter <= 0) {\n      throw new TypeError(`trimAfter must be a positive number, instead got ${trimAfter}.`);\n    }\n  }\n  if (trimAfter <= trimBefore) {\n    throw new TypeError(\"trimAfter prop must be greater than trimBefore prop.\");\n  }\n};\nvar validateMediaTrimProps = ({\n  startFrom,\n  endAt,\n  trimBefore,\n  trimAfter\n}) => {\n  if (typeof startFrom !== \"undefined\" && typeof trimBefore !== \"undefined\") {\n    throw new TypeError(\"Cannot use both startFrom and trimBefore props. Use trimBefore instead as startFrom is deprecated.\");\n  }\n  if (typeof endAt !== \"undefined\" && typeof trimAfter !== \"undefined\") {\n    throw new TypeError(\"Cannot use both endAt and trimAfter props. Use trimAfter instead as endAt is deprecated.\");\n  }\n  const hasNewProps = typeof trimBefore !== \"undefined\" || typeof trimAfter !== \"undefined\";\n  const hasOldProps = typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\";\n  if (hasNewProps) {\n    validateTrimProps(trimBefore, trimAfter);\n  } else if (hasOldProps) {\n    validateStartFromProps(startFrom, endAt);\n  }\n};\nvar resolveTrimProps = ({\n  startFrom,\n  endAt,\n  trimBefore,\n  trimAfter\n}) => {\n  const trimBeforeValue = trimBefore ?? startFrom ?? undefined;\n  const trimAfterValue = trimAfter ?? endAt ?? undefined;\n  return { trimBeforeValue, trimAfterValue };\n};\n\n// src/video/duration-state.tsx\n\n\nvar durationReducer = (state, action) => {\n  switch (action.type) {\n    case \"got-duration\": {\n      const absoluteSrc = getAbsoluteSrc(action.src);\n      if (state[absoluteSrc] === action.durationInSeconds) {\n        return state;\n      }\n      return {\n        ...state,\n        [absoluteSrc]: action.durationInSeconds\n      };\n    }\n    default:\n      return state;\n  }\n};\nvar DurationsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  durations: {},\n  setDurations: () => {\n    throw new Error(\"context missing\");\n  }\n});\nvar DurationsContextProvider = ({ children }) => {\n  const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      durations,\n      setDurations\n    };\n  }, [durations]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, {\n    value,\n    children\n  });\n};\n\n// src/audio/AudioForPreview.tsx\n\n\n// src/get-cross-origin-value.ts\nvar getCrossOriginValue = ({\n  crossOrigin,\n  requestsVideoFrame\n}) => {\n  if (crossOrigin !== undefined && crossOrigin !== null) {\n    return crossOrigin;\n  }\n  if (requestsVideoFrame) {\n    return \"anonymous\";\n  }\n  return;\n};\n\n// src/use-amplification.ts\n\n\n// src/audio/shared-audio-tags.tsx\n\n\n// src/play-and-handle-not-allowed-error.ts\nvar playAndHandleNotAllowedError = ({\n  mediaRef,\n  mediaType,\n  onAutoPlayError,\n  logLevel,\n  mountTime,\n  reason,\n  isPlayer\n}) => {\n  const { current } = mediaRef;\n  if (!current) {\n    return;\n  }\n  playbackLogging({\n    logLevel,\n    tag: \"play\",\n    message: `Attempting to play ${current.src}. Reason: ${reason}`,\n    mountTime\n  });\n  const prom = current.play();\n  if (!prom.catch) {\n    return;\n  }\n  prom.catch((err) => {\n    if (!current) {\n      return;\n    }\n    if (err.message.includes(\"request was interrupted by a call to pause\")) {\n      return;\n    }\n    if (err.message.includes(\"The operation was aborted.\")) {\n      return;\n    }\n    if (err.message.includes(\"The fetching process for the media resource was aborted by the user agent\")) {\n      return;\n    }\n    if (err.message.includes(\"request was interrupted by a new load request\")) {\n      return;\n    }\n    if (err.message.includes(\"because the media was removed from the document\")) {\n      return;\n    }\n    if (err.message.includes(\"user didn't interact with the document\") && current.muted) {\n      return;\n    }\n    console.log(`Could not play ${mediaType} due to following error: `, err);\n    if (!current.muted) {\n      if (onAutoPlayError) {\n        onAutoPlayError();\n        return;\n      }\n      if (mediaType === \"video\" && isPlayer) {\n        Log.info({ logLevel, tag: \"<\" + mediaType + \">\" }, `The video will be muted and we'll retry playing it.`);\n        Log.info({ logLevel, tag: \"<\" + mediaType + \">\" }, \"Use onAutoPlayError() to handle this error yourself.\");\n        current.muted = true;\n        current.play();\n      }\n    }\n  });\n};\n\n// src/audio/shared-element-source-node.ts\nvar makeSharedElementSourceNode = ({\n  audioContext,\n  ref\n}) => {\n  let connected = null;\n  return {\n    attemptToConnect: () => {\n      if (!connected && ref.current) {\n        const mediaElementSourceNode = audioContext.createMediaElementSource(ref.current);\n        connected = mediaElementSourceNode;\n      }\n    },\n    get: () => {\n      if (!connected) {\n        throw new Error(\"Audio element not connected\");\n      }\n      return connected;\n    }\n  };\n};\n\n// src/audio/use-audio-context.ts\n\nvar warned = false;\nvar warnOnce = (logLevel) => {\n  if (warned) {\n    return;\n  }\n  warned = true;\n  if (typeof window !== \"undefined\") {\n    Log.warn({ logLevel, tag: null }, \"AudioContext is not supported in this browser\");\n  }\n};\nvar useSingletonAudioContext = (logLevel, latencyHint) => {\n  const env = useRemotionEnvironment();\n  const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (env.isRendering) {\n      return null;\n    }\n    if (typeof AudioContext === \"undefined\") {\n      warnOnce(logLevel);\n      return null;\n    }\n    return new AudioContext({\n      latencyHint,\n      sampleRate: 48000\n    });\n  }, [logLevel, latencyHint, env.isRendering]);\n  return audioContext;\n};\n\n// src/audio/shared-audio-tags.tsx\n\nvar EMPTY_AUDIO = \"data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\";\nvar compareProps = (obj1, obj2) => {\n  const keysA = Object.keys(obj1).sort();\n  const keysB = Object.keys(obj2).sort();\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  for (let i = 0;i < keysA.length; i++) {\n    if (keysA[i] !== keysB[i]) {\n      return false;\n    }\n    if (obj1[keysA[i]] !== obj2[keysB[i]]) {\n      return false;\n    }\n  }\n  return true;\n};\nvar didPropChange = (key, newProp, prevProp) => {\n  if (key === \"src\" && !prevProp.startsWith(\"data:\") && !newProp.startsWith(\"data:\")) {\n    return new URL(prevProp, window.origin).toString() !== new URL(newProp, window.origin).toString();\n  }\n  if (prevProp === newProp) {\n    return false;\n  }\n  return true;\n};\nvar SharedAudioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar SharedAudioContextProvider = ({ children, numberOfAudioTags, audioLatencyHint }) => {\n  const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);\n  if (numberOfAudioTags !== initialNumberOfAudioTags) {\n    throw new Error(\"The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.\");\n  }\n  const logLevel = useLogLevel();\n  const audioContext = useSingletonAudioContext(logLevel, audioLatencyHint);\n  const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return new Array(numberOfAudioTags).fill(true).map(() => {\n      const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n      return {\n        id: Math.random(),\n        ref,\n        mediaElementSourceNode: audioContext ? makeSharedElementSourceNode({\n          audioContext,\n          ref\n        }) : null\n      };\n    });\n  }, [audioContext, numberOfAudioTags]);\n  const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));\n  const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    refs.forEach(({ ref, id }) => {\n      const data = audios.current?.find((a) => a.id === id);\n      const { current } = ref;\n      if (!current) {\n        return;\n      }\n      if (data === undefined) {\n        current.src = EMPTY_AUDIO;\n        return;\n      }\n      if (!data) {\n        throw new TypeError(\"Expected audio data to be there\");\n      }\n      Object.keys(data.props).forEach((key) => {\n        if (didPropChange(key, data.props[key], current[key])) {\n          current[key] = data.props[key];\n        }\n      });\n    });\n  }, [refs]);\n  const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options) => {\n    const { aud, audioId, premounting } = options;\n    const found = audios.current?.find((a) => a.audioId === audioId);\n    if (found) {\n      return found;\n    }\n    const firstFreeAudio = takenAudios.current.findIndex((a) => a === false);\n    if (firstFreeAudio === -1) {\n      throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Html5Audio /> tags at the same time. With the current settings, the maximum amount of <Html5Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#using-the-numberofsharedaudiotags-prop for more information on how to increase this limit.`);\n    }\n    const { id, ref, mediaElementSourceNode } = refs[firstFreeAudio];\n    const cloned = [...takenAudios.current];\n    cloned[firstFreeAudio] = id;\n    takenAudios.current = cloned;\n    const newElem = {\n      props: aud,\n      id,\n      el: ref,\n      audioId,\n      mediaElementSourceNode,\n      premounting\n    };\n    audios.current?.push(newElem);\n    rerenderAudios();\n    return newElem;\n  }, [numberOfAudioTags, refs, rerenderAudios]);\n  const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n    const cloned = [...takenAudios.current];\n    const index = refs.findIndex((r) => r.id === id);\n    if (index === -1) {\n      throw new TypeError(\"Error occured in \");\n    }\n    cloned[index] = false;\n    takenAudios.current = cloned;\n    audios.current = audios.current?.filter((a) => a.id !== id);\n    rerenderAudios();\n  }, [refs, rerenderAudios]);\n  const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({\n    aud,\n    audioId,\n    id,\n    premounting\n  }) => {\n    let changed = false;\n    audios.current = audios.current?.map((prevA) => {\n      if (prevA.id === id) {\n        const isTheSame = compareProps(aud, prevA.props) && prevA.premounting === premounting;\n        if (isTheSame) {\n          return prevA;\n        }\n        changed = true;\n        return {\n          ...prevA,\n          props: aud,\n          premounting,\n          audioId\n        };\n      }\n      return prevA;\n    });\n    if (changed) {\n      rerenderAudios();\n    }\n  }, [rerenderAudios]);\n  const mountTime = useMountTime();\n  const env = useRemotionEnvironment();\n  const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    refs.forEach((ref) => {\n      const audio = audios.current.find((a) => a.el === ref.ref);\n      if (audio?.premounting) {\n        return;\n      }\n      playAndHandleNotAllowedError({\n        mediaRef: ref.ref,\n        mediaType: \"audio\",\n        onAutoPlayError: null,\n        logLevel,\n        mountTime,\n        reason: \"playing all audios\",\n        isPlayer: env.isPlayer\n      });\n    });\n    audioContext?.resume();\n  }, [audioContext, logLevel, mountTime, refs, env.isPlayer]);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      registerAudio,\n      unregisterAudio,\n      updateAudio,\n      playAllAudios,\n      numberOfAudioTags,\n      audioContext\n    };\n  }, [\n    numberOfAudioTags,\n    playAllAudios,\n    registerAudio,\n    unregisterAudio,\n    updateAudio,\n    audioContext\n  ]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, {\n    value,\n    children: [\n      refs.map(({ id, ref }) => {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n          ref,\n          preload: \"metadata\",\n          src: EMPTY_AUDIO\n        }, id);\n      }),\n      children\n    ]\n  });\n};\nvar useSharedAudio = ({\n  aud,\n  audioId,\n  premounting\n}) => {\n  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n    if (ctx && ctx.numberOfAudioTags > 0) {\n      return ctx.registerAudio({ aud, audioId, premounting });\n    }\n    const el = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    const mediaElementSourceNode = ctx?.audioContext ? makeSharedElementSourceNode({\n      audioContext: ctx.audioContext,\n      ref: el\n    }) : null;\n    return {\n      el,\n      id: Math.random(),\n      props: aud,\n      audioId,\n      mediaElementSourceNode,\n      premounting\n    };\n  });\n  const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n  if (typeof document !== \"undefined\") {\n    effectToUse(() => {\n      if (ctx && ctx.numberOfAudioTags > 0) {\n        ctx.updateAudio({ id: elem.id, aud, audioId, premounting });\n      }\n    }, [aud, ctx, elem.id, audioId, premounting]);\n    effectToUse(() => {\n      return () => {\n        if (ctx && ctx.numberOfAudioTags > 0) {\n          ctx.unregisterAudio(elem.id);\n        }\n      };\n    }, [ctx, elem.id]);\n  }\n  return elem;\n};\n\n// src/is-approximately-the-same.ts\nvar FLOATING_POINT_ERROR_THRESHOLD = 0.00001;\nvar isApproximatelyTheSame = (num1, num2) => {\n  return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;\n};\n\n// src/video/video-fragment.ts\n\nvar toSeconds = (time, fps) => {\n  return Math.round(time / fps * 100) / 100;\n};\nvar isSafari = () => {\n  if (typeof window === \"undefined\") {\n    return false;\n  }\n  const isAppleWebKit = /AppleWebKit/.test(window.navigator.userAgent);\n  if (!isAppleWebKit) {\n    return false;\n  }\n  const isNotChrome = !window.navigator.userAgent.includes(\"Chrome/\");\n  return isNotChrome;\n};\nvar isIosSafari = () => {\n  if (typeof window === \"undefined\") {\n    return false;\n  }\n  const isIpadIPodIPhone = /iP(ad|od|hone)/i.test(window.navigator.userAgent);\n  return isIpadIPodIPhone && isSafari();\n};\nvar isIOSSafariAndBlob = (actualSrc) => {\n  return isIosSafari() && actualSrc.startsWith(\"blob:\");\n};\nvar getVideoFragmentStart = ({\n  actualFrom,\n  fps\n}) => {\n  return toSeconds(Math.max(0, -actualFrom), fps);\n};\nvar getVideoFragmentEnd = ({\n  duration,\n  fps\n}) => {\n  return toSeconds(duration, fps);\n};\nvar appendVideoFragment = ({\n  actualSrc,\n  actualFrom,\n  duration,\n  fps\n}) => {\n  if (isIOSSafariAndBlob(actualSrc)) {\n    return actualSrc;\n  }\n  if (actualSrc.startsWith(\"data:\")) {\n    return actualSrc;\n  }\n  const existingHash = Boolean(new URL(actualSrc, (typeof window === \"undefined\" ? null : window.location.href) ?? \"http://localhost:3000\").hash);\n  if (existingHash) {\n    return actualSrc;\n  }\n  if (!Number.isFinite(actualFrom)) {\n    return actualSrc;\n  }\n  const withStartHash = `${actualSrc}#t=${getVideoFragmentStart({ actualFrom, fps })}`;\n  if (!Number.isFinite(duration)) {\n    return withStartHash;\n  }\n  return `${withStartHash},${getVideoFragmentEnd({ duration, fps })}`;\n};\nvar isSubsetOfDuration = ({\n  prevStartFrom,\n  newStartFrom,\n  prevDuration,\n  newDuration,\n  fps\n}) => {\n  const previousFrom = getVideoFragmentStart({ actualFrom: prevStartFrom, fps });\n  const newFrom = getVideoFragmentStart({ actualFrom: newStartFrom, fps });\n  const previousEnd = getVideoFragmentEnd({ duration: prevDuration, fps });\n  const newEnd = getVideoFragmentEnd({ duration: newDuration, fps });\n  if (newFrom < previousFrom) {\n    return false;\n  }\n  if (newEnd > previousEnd) {\n    return false;\n  }\n  return true;\n};\nvar useAppendVideoFragment = ({\n  actualSrc: initialActualSrc,\n  actualFrom: initialActualFrom,\n  duration: initialDuration,\n  fps\n}) => {\n  const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);\n  const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);\n  const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);\n  if (!isSubsetOfDuration({\n    prevStartFrom: actualFromRef.current,\n    newStartFrom: initialActualFrom,\n    prevDuration: actualDuration.current,\n    newDuration: initialDuration,\n    fps\n  }) || initialActualSrc !== actualSrc.current) {\n    actualFromRef.current = initialActualFrom;\n    actualDuration.current = initialDuration;\n    actualSrc.current = initialActualSrc;\n  }\n  const appended = appendVideoFragment({\n    actualSrc: actualSrc.current,\n    actualFrom: actualFromRef.current,\n    duration: actualDuration.current,\n    fps\n  });\n  return appended;\n};\n\n// src/use-amplification.ts\nvar warned2 = false;\nvar warnSafariOnce = (logLevel) => {\n  if (warned2) {\n    return;\n  }\n  warned2 = true;\n  Log.warn({ logLevel, tag: null }, \"In Safari, setting a volume and a playback rate at the same time is buggy.\");\n  Log.warn({ logLevel, tag: null }, \"In Desktop Safari, only volumes <= 1 will be applied.\");\n  Log.warn({ logLevel, tag: null }, logLevel, \"In Mobile Safari, the volume will be ignored and set to 1 if a playbackRate is set.\");\n};\nvar useVolume = ({\n  mediaRef,\n  volume,\n  logLevel,\n  source,\n  shouldUseWebAudioApi\n}) => {\n  const audioStuffRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const currentVolumeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(volume);\n  currentVolumeRef.current = volume;\n  const sharedAudioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  if (!sharedAudioContext) {\n    throw new Error(\"useAmplification must be used within a SharedAudioContext\");\n  }\n  const { audioContext } = sharedAudioContext;\n  if (typeof window !== \"undefined\") {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      if (!audioContext) {\n        return;\n      }\n      if (!mediaRef.current) {\n        return;\n      }\n      if (!shouldUseWebAudioApi) {\n        return;\n      }\n      if (mediaRef.current.playbackRate !== 1 && isSafari()) {\n        warnSafariOnce(logLevel);\n        return;\n      }\n      if (!source) {\n        return;\n      }\n      const gainNode = new GainNode(audioContext, {\n        gain: currentVolumeRef.current\n      });\n      source.attemptToConnect();\n      source.get().connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      audioStuffRef.current = {\n        gainNode\n      };\n      Log.trace({ logLevel, tag: null }, `Starting to amplify ${mediaRef.current?.src}. Gain = ${currentVolumeRef.current}, playbackRate = ${mediaRef.current?.playbackRate}`);\n      return () => {\n        audioStuffRef.current = null;\n        gainNode.disconnect();\n        source.get().disconnect();\n      };\n    }, [logLevel, mediaRef, audioContext, source, shouldUseWebAudioApi]);\n  }\n  if (audioStuffRef.current) {\n    const valueToSet = volume;\n    if (!isApproximatelyTheSame(audioStuffRef.current.gainNode.gain.value, valueToSet)) {\n      audioStuffRef.current.gainNode.gain.value = valueToSet;\n      Log.trace({ logLevel, tag: null }, `Setting gain to ${valueToSet} for ${mediaRef.current?.src}`);\n    }\n  }\n  const safariCase = isSafari() && mediaRef.current && mediaRef.current?.playbackRate !== 1;\n  const shouldUseTraditionalVolume = safariCase || !shouldUseWebAudioApi;\n  if (shouldUseTraditionalVolume && mediaRef.current && !isApproximatelyTheSame(volume, mediaRef.current?.volume)) {\n    mediaRef.current.volume = Math.min(volume, 1);\n  }\n  return audioStuffRef;\n};\n\n// src/use-media-in-timeline.ts\n\n\n// src/audio/use-audio-frame.ts\n\nvar useMediaStartsAt = () => {\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const startsAt = Math.min(0, parentSequence?.relativeFrom ?? 0);\n  return startsAt;\n};\nvar useFrameForVolumeProp = (behavior) => {\n  const loop = Loop.useLoop();\n  const frame = useCurrentFrame();\n  const startsAt = useMediaStartsAt();\n  if (behavior === \"repeat\" || loop === null) {\n    return frame + startsAt;\n  }\n  return frame + startsAt + loop.durationInFrames * loop.iteration;\n};\n\n// src/get-asset-file-name.ts\nvar getAssetDisplayName = (filename) => {\n  if (/data:|blob:/.test(filename.substring(0, 5))) {\n    return \"Data URL\";\n  }\n  const splitted = filename.split(\"/\").map((s) => s.split(\"\\\\\")).flat(1);\n  return splitted[splitted.length - 1];\n};\n\n// src/volume-prop.ts\nvar evaluateVolume = ({\n  frame,\n  volume,\n  mediaVolume = 1\n}) => {\n  if (typeof volume === \"number\") {\n    return volume * mediaVolume;\n  }\n  if (typeof volume === \"undefined\") {\n    return Number(mediaVolume);\n  }\n  const evaluated = volume(frame) * mediaVolume;\n  if (typeof evaluated !== \"number\") {\n    throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);\n  }\n  if (Number.isNaN(evaluated)) {\n    throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);\n  }\n  if (!Number.isFinite(evaluated)) {\n    throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);\n  }\n  return Math.max(0, evaluated);\n};\n\n// src/use-media-in-timeline.ts\nvar didWarn = {};\nvar warnOnce2 = (message) => {\n  if (didWarn[message]) {\n    return;\n  }\n  console.warn(message);\n  didWarn[message] = true;\n};\nvar useBasicMediaInTimeline = ({\n  volume,\n  mediaVolume,\n  mediaType,\n  src,\n  displayName,\n  trimBefore,\n  trimAfter,\n  playbackRate\n}) => {\n  if (!src) {\n    throw new Error(\"No src passed\");\n  }\n  const startsAt = useMediaStartsAt();\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const videoConfig = useVideoConfig();\n  const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => volume);\n  const mediaDuration = calculateMediaDuration({\n    mediaDurationInFrames: videoConfig.durationInFrames,\n    playbackRate,\n    trimBefore,\n    trimAfter\n  });\n  const duration = parentSequence ? Math.min(parentSequence.durationInFrames, mediaDuration) : mediaDuration;\n  const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (typeof volume === \"number\") {\n      return volume;\n    }\n    return new Array(Math.floor(Math.max(0, duration + startsAt))).fill(true).map((_, i) => {\n      return evaluateVolume({\n        frame: i + startsAt,\n        volume,\n        mediaVolume\n      });\n    }).join(\",\");\n  }, [duration, startsAt, volume, mediaVolume]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (typeof volume === \"number\" && volume !== initialVolume) {\n      warnOnce2(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/audio/volume`);\n    }\n  }, [initialVolume, mediaType, src, volume]);\n  const doesVolumeChange = typeof volume === \"function\";\n  const nonce = useNonce();\n  const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const env = useRemotionEnvironment();\n  return {\n    volumes,\n    duration,\n    doesVolumeChange,\n    nonce,\n    rootId,\n    isStudio: env.isStudio,\n    finalDisplayName: displayName ?? getAssetDisplayName(src)\n  };\n};\nvar useMediaInTimeline = ({\n  volume,\n  mediaVolume,\n  src,\n  mediaType,\n  playbackRate,\n  displayName,\n  id,\n  stack,\n  showInTimeline,\n  premountDisplay,\n  postmountDisplay,\n  loopDisplay\n}) => {\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const startsAt = useMediaStartsAt();\n  const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n  const {\n    volumes,\n    duration,\n    doesVolumeChange,\n    nonce,\n    rootId,\n    isStudio,\n    finalDisplayName\n  } = useBasicMediaInTimeline({\n    volume,\n    mediaVolume,\n    mediaType,\n    src,\n    displayName,\n    trimAfter: undefined,\n    trimBefore: undefined,\n    playbackRate\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!src) {\n      throw new Error(\"No src passed\");\n    }\n    if (!isStudio && window.process?.env?.NODE_ENV !== \"test\") {\n      return;\n    }\n    if (!showInTimeline) {\n      return;\n    }\n    registerSequence({\n      type: mediaType,\n      src,\n      id,\n      duration,\n      from: 0,\n      parent: parentSequence?.id ?? null,\n      displayName: finalDisplayName,\n      rootId,\n      volume: volumes,\n      showInTimeline: true,\n      nonce,\n      startMediaFrom: 0 - startsAt,\n      doesVolumeChange,\n      loopDisplay,\n      playbackRate,\n      stack,\n      premountDisplay,\n      postmountDisplay\n    });\n    return () => {\n      unregisterSequence(id);\n    };\n  }, [\n    duration,\n    id,\n    parentSequence,\n    src,\n    registerSequence,\n    unregisterSequence,\n    volumes,\n    doesVolumeChange,\n    nonce,\n    mediaType,\n    startsAt,\n    playbackRate,\n    stack,\n    showInTimeline,\n    premountDisplay,\n    postmountDisplay,\n    isStudio,\n    loopDisplay,\n    rootId,\n    finalDisplayName\n  ]);\n};\n\n// src/use-media-playback.ts\n\n\n// src/buffer-until-first-frame.ts\n\n\n// src/use-buffer-state.ts\n\n\n// src/buffering.tsx\n\n\nvar useBufferManager = (logLevel, mountTime) => {\n  const [blocks, setBlocks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [onBufferingCallbacks, setOnBufferingCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [onResumeCallbacks, setOnResumeCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const addBlock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((block) => {\n    setBlocks((b) => [...b, block]);\n    return {\n      unblock: () => {\n        setBlocks((b) => {\n          const newArr = b.filter((bx) => bx !== block);\n          if (newArr.length === b.length) {\n            return b;\n          }\n          return newArr;\n        });\n      }\n    };\n  }, []);\n  const listenForBuffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback) => {\n    setOnBufferingCallbacks((c) => [...c, callback]);\n    return {\n      remove: () => {\n        setOnBufferingCallbacks((c) => c.filter((cb) => cb !== callback));\n      }\n    };\n  }, []);\n  const listenForResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback) => {\n    setOnResumeCallbacks((c) => [...c, callback]);\n    return {\n      remove: () => {\n        setOnResumeCallbacks((c) => c.filter((cb) => cb !== callback));\n      }\n    };\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (blocks.length > 0) {\n      onBufferingCallbacks.forEach((c) => c());\n      playbackLogging({\n        logLevel,\n        message: \"Player is entering buffer state\",\n        mountTime,\n        tag: \"player\"\n      });\n    }\n  }, [blocks]);\n  if (typeof window !== \"undefined\") {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      if (blocks.length === 0) {\n        onResumeCallbacks.forEach((c) => c());\n        playbackLogging({\n          logLevel,\n          message: \"Player is exiting buffer state\",\n          mountTime,\n          tag: \"player\"\n        });\n      }\n    }, [blocks]);\n  }\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return { addBlock, listenForBuffering, listenForResume, buffering };\n  }, [addBlock, buffering, listenForBuffering, listenForResume]);\n};\nvar BufferingContextReact = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar BufferingProvider = ({ children }) => {\n  const { logLevel, mountTime } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LogLevelContext);\n  const bufferManager = useBufferManager(logLevel ?? \"info\", mountTime);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n    value: bufferManager,\n    children\n  });\n};\nvar useIsPlayerBuffering = (bufferManager) => {\n  const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(bufferManager.buffering.current);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const onBuffer = () => {\n      setIsBuffering(true);\n    };\n    const onResume = () => {\n      setIsBuffering(false);\n    };\n    bufferManager.listenForBuffering(onBuffer);\n    bufferManager.listenForResume(onResume);\n    return () => {\n      bufferManager.listenForBuffering(() => {\n        return;\n      });\n      bufferManager.listenForResume(() => {\n        return;\n      });\n    };\n  }, [bufferManager]);\n  return isBuffering;\n};\n\n// src/use-buffer-state.ts\nvar useBufferState = () => {\n  const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n  const addBlock = buffer ? buffer.addBlock : null;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    delayPlayback: () => {\n      if (!addBlock) {\n        throw new Error(\"Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state\");\n      }\n      const { unblock } = addBlock({\n        id: String(Math.random())\n      });\n      return { unblock };\n    }\n  }), [addBlock]);\n};\n\n// src/buffer-until-first-frame.ts\nvar isSafariWebkit = () => {\n  const isSafari2 = /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent);\n  return isSafari2;\n};\nvar useBufferUntilFirstFrame = ({\n  mediaRef,\n  mediaType,\n  onVariableFpsVideoDetected,\n  pauseWhenBuffering,\n  logLevel,\n  mountTime\n}) => {\n  const bufferingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const { delayPlayback } = useBufferState();\n  const bufferUntilFirstFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((requestedTime) => {\n    if (mediaType !== \"video\") {\n      return;\n    }\n    if (!pauseWhenBuffering) {\n      return;\n    }\n    const current = mediaRef.current;\n    if (!current) {\n      return;\n    }\n    if (current.readyState >= current.HAVE_FUTURE_DATA && !isSafariWebkit()) {\n      playbackLogging({\n        logLevel,\n        message: `Not using buffer until first frame, because readyState is ${current.readyState} and is not Safari or Desktop Chrome`,\n        mountTime,\n        tag: \"buffer\"\n      });\n      return;\n    }\n    if (!current.requestVideoFrameCallback) {\n      playbackLogging({\n        logLevel,\n        message: `Not using buffer until first frame, because requestVideoFrameCallback is not supported`,\n        mountTime,\n        tag: \"buffer\"\n      });\n      return;\n    }\n    bufferingRef.current = true;\n    playbackLogging({\n      logLevel,\n      message: `Buffering ${mediaRef.current?.src} until the first frame is received`,\n      mountTime,\n      tag: \"buffer\"\n    });\n    const playback = delayPlayback();\n    const unblock = () => {\n      playback.unblock();\n      current.removeEventListener(\"ended\", unblock, {\n        once: true\n      });\n      current.removeEventListener(\"pause\", unblock, {\n        once: true\n      });\n      bufferingRef.current = false;\n    };\n    const onEndedOrPauseOrCanPlay = () => {\n      unblock();\n    };\n    current.requestVideoFrameCallback((_, info2) => {\n      const differenceFromRequested = Math.abs(info2.mediaTime - requestedTime);\n      if (differenceFromRequested > 0.5) {\n        onVariableFpsVideoDetected();\n      }\n      unblock();\n    });\n    current.addEventListener(\"ended\", onEndedOrPauseOrCanPlay, { once: true });\n    current.addEventListener(\"pause\", onEndedOrPauseOrCanPlay, { once: true });\n    current.addEventListener(\"canplay\", onEndedOrPauseOrCanPlay, {\n      once: true\n    });\n  }, [\n    delayPlayback,\n    logLevel,\n    mediaRef,\n    mediaType,\n    mountTime,\n    onVariableFpsVideoDetected,\n    pauseWhenBuffering\n  ]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      isBuffering: () => bufferingRef.current,\n      bufferUntilFirstFrame\n    };\n  }, [bufferUntilFirstFrame]);\n};\n\n// src/media-tag-current-time-timestamp.ts\n\nvar useCurrentTimeOfMediaTagWithUpdateTimeStamp = (mediaRef) => {\n  const lastUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n    time: mediaRef.current?.currentTime ?? 0,\n    lastUpdate: performance.now()\n  });\n  const nowCurrentTime = mediaRef.current?.currentTime ?? null;\n  if (nowCurrentTime !== null) {\n    if (lastUpdate.current.time !== nowCurrentTime) {\n      lastUpdate.current.time = nowCurrentTime;\n      lastUpdate.current.lastUpdate = performance.now();\n    }\n  }\n  return lastUpdate;\n};\n\n// src/seek.ts\nvar seek = ({\n  mediaRef,\n  time,\n  logLevel,\n  why,\n  mountTime\n}) => {\n  const timeToSet = isIosSafari() ? Number(time.toFixed(1)) : time;\n  playbackLogging({\n    logLevel,\n    tag: \"seek\",\n    message: `Seeking from ${mediaRef.currentTime} to ${timeToSet}. src= ${mediaRef.src} Reason: ${why}`,\n    mountTime\n  });\n  mediaRef.currentTime = timeToSet;\n  return timeToSet;\n};\n\n// src/use-media-buffering.ts\n\nvar useMediaBuffering = ({\n  element,\n  shouldBuffer,\n  isPremounting,\n  isPostmounting,\n  logLevel,\n  mountTime,\n  src\n}) => {\n  const buffer = useBufferState();\n  const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let cleanupFns = [];\n    const { current } = element;\n    if (!current) {\n      return;\n    }\n    if (!shouldBuffer) {\n      return;\n    }\n    if (isPremounting || isPostmounting) {\n      if ((isPremounting || isPostmounting) && current.readyState < current.HAVE_FUTURE_DATA) {\n        if (!navigator.userAgent.includes(\"Firefox/\")) {\n          playbackLogging({\n            logLevel,\n            message: `Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox. Element is premounted ${current.playbackRate}`,\n            tag: \"load\",\n            mountTime\n          });\n          const previousPlaybackRate = current.playbackRate;\n          current.load();\n          current.playbackRate = previousPlaybackRate;\n        }\n      }\n      return;\n    }\n    const cleanup = (reason) => {\n      let didDoSomething = false;\n      cleanupFns.forEach((fn) => {\n        fn(reason);\n        didDoSomething = true;\n      });\n      cleanupFns = [];\n      setIsBuffering((previous) => {\n        if (previous) {\n          didDoSomething = true;\n        }\n        return false;\n      });\n      if (didDoSomething) {\n        playbackLogging({\n          logLevel,\n          message: `Unmarking as buffering: ${current.src}. Reason: ${reason}`,\n          tag: \"buffer\",\n          mountTime\n        });\n      }\n    };\n    const blockMedia = (reason) => {\n      setIsBuffering(true);\n      playbackLogging({\n        logLevel,\n        message: `Marking as buffering: ${current.src}. Reason: ${reason}`,\n        tag: \"buffer\",\n        mountTime\n      });\n      const { unblock } = buffer.delayPlayback();\n      const onCanPlay = () => {\n        cleanup('\"canplay\" was fired');\n        init();\n      };\n      const onError = () => {\n        cleanup('\"error\" event was occurred');\n        init();\n      };\n      current.addEventListener(\"canplay\", onCanPlay, {\n        once: true\n      });\n      cleanupFns.push(() => {\n        current.removeEventListener(\"canplay\", onCanPlay);\n      });\n      current.addEventListener(\"error\", onError, {\n        once: true\n      });\n      cleanupFns.push(() => {\n        current.removeEventListener(\"error\", onError);\n      });\n      cleanupFns.push((cleanupReason) => {\n        playbackLogging({\n          logLevel,\n          message: `Unblocking ${current.src} from buffer. Reason: ${cleanupReason}`,\n          tag: \"buffer\",\n          mountTime\n        });\n        unblock();\n      });\n    };\n    const init = () => {\n      if (current.readyState < current.HAVE_FUTURE_DATA) {\n        blockMedia(`readyState is ${current.readyState}, which is less than HAVE_FUTURE_DATA`);\n        if (!navigator.userAgent.includes(\"Firefox/\")) {\n          playbackLogging({\n            logLevel,\n            message: `Calling .load() on ${src} because readyState is ${current.readyState} and it is not Firefox. ${current.playbackRate}`,\n            tag: \"load\",\n            mountTime\n          });\n          const previousPlaybackRate = current.playbackRate;\n          current.load();\n          current.playbackRate = previousPlaybackRate;\n        }\n      } else {\n        const onWaiting = () => {\n          blockMedia('\"waiting\" event was fired');\n        };\n        current.addEventListener(\"waiting\", onWaiting);\n        cleanupFns.push(() => {\n          current.removeEventListener(\"waiting\", onWaiting);\n        });\n      }\n    };\n    init();\n    return () => {\n      cleanup(\"element was unmounted or prop changed\");\n    };\n  }, [\n    buffer,\n    src,\n    element,\n    isPremounting,\n    isPostmounting,\n    logLevel,\n    shouldBuffer,\n    mountTime\n  ]);\n  return isBuffering;\n};\n\n// src/use-request-video-callback-time.ts\n\nvar useRequestVideoCallbackTime = ({\n  mediaRef,\n  mediaType,\n  lastSeek,\n  onVariableFpsVideoDetected\n}) => {\n  const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = mediaRef;\n    if (current) {\n      currentTime.current = {\n        time: current.currentTime,\n        lastUpdate: performance.now()\n      };\n    } else {\n      currentTime.current = null;\n      return;\n    }\n    if (mediaType !== \"video\") {\n      currentTime.current = null;\n      return;\n    }\n    const videoTag = current;\n    if (!videoTag.requestVideoFrameCallback) {\n      return;\n    }\n    let cancel = () => {\n      return;\n    };\n    const request = () => {\n      if (!videoTag) {\n        return;\n      }\n      const cb = videoTag.requestVideoFrameCallback((_, info2) => {\n        if (currentTime.current !== null) {\n          const difference = Math.abs(currentTime.current.time - info2.mediaTime);\n          const differenceToLastSeek = Math.abs(lastSeek.current === null ? Infinity : info2.mediaTime - lastSeek.current);\n          if (difference > 0.5 && differenceToLastSeek > 0.5 && info2.mediaTime > currentTime.current.time) {\n            onVariableFpsVideoDetected();\n          }\n        }\n        currentTime.current = {\n          time: info2.mediaTime,\n          lastUpdate: performance.now()\n        };\n        request();\n      });\n      cancel = () => {\n        videoTag.cancelVideoFrameCallback(cb);\n        cancel = () => {\n          return;\n        };\n      };\n    };\n    request();\n    return () => {\n      cancel();\n    };\n  }, [lastSeek, mediaRef, mediaType, onVariableFpsVideoDetected]);\n  return currentTime;\n};\n\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n  const { extrapolateLeft, extrapolateRight, easing } = options;\n  let result = input;\n  const [inputMin, inputMax] = inputRange;\n  const [outputMin, outputMax] = outputRange;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\") {\n      return result;\n    }\n    if (extrapolateLeft === \"clamp\") {\n      result = inputMin;\n    } else if (extrapolateLeft === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateLeft === \"extend\") {}\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\") {\n      return result;\n    }\n    if (extrapolateRight === \"clamp\") {\n      result = inputMax;\n    } else if (extrapolateRight === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateRight === \"extend\") {}\n  }\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n  result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\nfunction findRange(input, inputRange) {\n  let i;\n  for (i = 1;i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\nfunction checkValidInputRange(arr) {\n  for (let i = 1;i < arr.length; ++i) {\n    if (!(arr[i] > arr[i - 1])) {\n      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction checkInfiniteRange(name, arr) {\n  if (arr.length < 2) {\n    throw new Error(name + \" must have at least 2 elements\");\n  }\n  for (const element of arr) {\n    if (typeof element !== \"number\") {\n      throw new Error(`${name} must contain only numbers`);\n    }\n    if (!Number.isFinite(element)) {\n      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n  if (typeof input === \"undefined\") {\n    throw new Error(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new Error(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new Error(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n  }\n  checkInfiniteRange(\"inputRange\", inputRange);\n  checkInfiniteRange(\"outputRange\", outputRange);\n  checkValidInputRange(inputRange);\n  const easing = options?.easing ?? ((num) => num);\n  let extrapolateLeft = \"extend\";\n  if (options?.extrapolateLeft !== undefined) {\n    extrapolateLeft = options.extrapolateLeft;\n  }\n  let extrapolateRight = \"extend\";\n  if (options?.extrapolateRight !== undefined) {\n    extrapolateRight = options.extrapolateRight;\n  }\n  if (typeof input !== \"number\") {\n    throw new TypeError(\"Cannot interpolate an input which is not a number\");\n  }\n  const range = findRange(input, inputRange);\n  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {\n    easing,\n    extrapolateLeft,\n    extrapolateRight\n  });\n}\n\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);\n};\nvar getMediaTime = ({\n  fps,\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  const expectedFrame = getExpectedMediaFrameUncorrected({\n    frame,\n    playbackRate,\n    startFrom\n  });\n  const msPerFrame = 1000 / fps;\n  return expectedFrame * msPerFrame / 1000;\n};\n\n// src/warn-about-non-seekable-media.ts\nvar alreadyWarned = {};\nvar warnAboutNonSeekableMedia = (ref, type) => {\n  if (ref === null) {\n    return;\n  }\n  if (ref.seekable.length === 0) {\n    return;\n  }\n  if (ref.seekable.length > 1) {\n    return;\n  }\n  if (alreadyWarned[ref.src]) {\n    return;\n  }\n  const range = { start: ref.seekable.start(0), end: ref.seekable.end(0) };\n  if (range.start === 0 && range.end === 0) {\n    const msg = [\n      `The media ${ref.src} cannot be seeked. This could be one of few reasons:`,\n      \"1) The media resource was replaced while the video is playing but it was not loaded yet.\",\n      \"2) The media does not support seeking.\",\n      \"3) The media was loaded with security headers prventing it from being included.\",\n      \"Please see https://remotion.dev/docs/non-seekable-media for assistance.\"\n    ].join(`\n`);\n    if (type === \"console-error\") {\n      console.error(msg);\n    } else if (type === \"console-warning\") {\n      console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);\n    } else {\n      throw new Error(msg);\n    }\n    alreadyWarned[ref.src] = true;\n  }\n};\n\n// src/use-media-playback.ts\nvar useMediaPlayback = ({\n  mediaRef,\n  src,\n  mediaType,\n  playbackRate: localPlaybackRate,\n  onlyWarnForMediaSeekingError,\n  acceptableTimeshift,\n  pauseWhenBuffering,\n  isPremounting,\n  isPostmounting,\n  onAutoPlayError\n}) => {\n  const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const frame = useCurrentFrame();\n  const absoluteFrame = useTimelinePosition();\n  const [playing] = usePlayingState();\n  const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n  const { fps } = useVideoConfig();\n  const mediaStartsAt = useMediaStartsAt();\n  const lastSeekDueToShift = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const lastSeek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const logLevel = useLogLevel();\n  const mountTime = useMountTime();\n  if (!buffering) {\n    throw new Error(\"useMediaPlayback must be used inside a <BufferingContext>\");\n  }\n  const isVariableFpsVideoMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  const onVariableFpsVideoDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (!src) {\n      return;\n    }\n    if (isVariableFpsVideoMap.current[src]) {\n      return;\n    }\n    Log.verbose({ logLevel, tag: null }, `Detected ${src} as a variable FPS video. Disabling buffering while seeking.`);\n    isVariableFpsVideoMap.current[src] = true;\n  }, [logLevel, src]);\n  const rvcCurrentTime = useRequestVideoCallbackTime({\n    mediaRef,\n    mediaType,\n    lastSeek,\n    onVariableFpsVideoDetected\n  });\n  const mediaTagCurrentTime = useCurrentTimeOfMediaTagWithUpdateTimeStamp(mediaRef);\n  const desiredUnclampedTime = getMediaTime({\n    frame,\n    playbackRate: localPlaybackRate,\n    startFrom: -mediaStartsAt,\n    fps\n  });\n  const isMediaTagBuffering = useMediaBuffering({\n    element: mediaRef,\n    shouldBuffer: pauseWhenBuffering,\n    isPremounting,\n    isPostmounting,\n    logLevel,\n    mountTime,\n    src: src ?? null\n  });\n  const { bufferUntilFirstFrame, isBuffering } = useBufferUntilFirstFrame({\n    mediaRef,\n    mediaType,\n    onVariableFpsVideoDetected,\n    pauseWhenBuffering,\n    logLevel,\n    mountTime\n  });\n  const playbackRate = localPlaybackRate * globalPlaybackRate;\n  const acceptableTimeShiftButLessThanDuration = (() => {\n    const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK = 0.45;\n    const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK + 0.2;\n    const defaultAcceptableTimeshift = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION;\n    if (mediaRef.current?.duration) {\n      return Math.min(mediaRef.current.duration, acceptableTimeshift ?? defaultAcceptableTimeshift);\n    }\n    return acceptableTimeshift ?? defaultAcceptableTimeshift;\n  })();\n  const isPlayerBuffering = useIsPlayerBuffering(buffering);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (mediaRef.current?.paused) {\n      return;\n    }\n    if (!playing) {\n      playbackLogging({\n        logLevel,\n        tag: \"pause\",\n        message: `Pausing ${mediaRef.current?.src} because ${isPremounting ? \"media is premounting\" : isPostmounting ? \"media is postmounting\" : \"Player is not playing\"}`,\n        mountTime\n      });\n      mediaRef.current?.pause();\n      return;\n    }\n    const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n    const playerBufferingNotStateButLive = buffering.buffering.current;\n    if (playerBufferingNotStateButLive && !isMediaTagBufferingOrStalled) {\n      playbackLogging({\n        logLevel,\n        tag: \"pause\",\n        message: `Pausing ${mediaRef.current?.src} because player is buffering but media tag is not`,\n        mountTime\n      });\n      mediaRef.current?.pause();\n    }\n  }, [\n    isBuffering,\n    isMediaTagBuffering,\n    buffering,\n    isPlayerBuffering,\n    isPremounting,\n    logLevel,\n    mediaRef,\n    mediaType,\n    mountTime,\n    playing,\n    isPostmounting\n  ]);\n  const env = useRemotionEnvironment();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    const playbackRateToSet = Math.max(0, playbackRate);\n    if (mediaRef.current && mediaRef.current.playbackRate !== playbackRateToSet) {\n      mediaRef.current.playbackRate = playbackRateToSet;\n    }\n  }, [mediaRef, playbackRate]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const tagName = mediaType === \"audio\" ? \"<Html5Audio>\" : \"<Html5Video>\";\n    if (!mediaRef.current) {\n      throw new Error(`No ${mediaType} ref found`);\n    }\n    if (!src) {\n      throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);\n    }\n    const { duration } = mediaRef.current;\n    const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration) ? Math.min(duration, desiredUnclampedTime) : desiredUnclampedTime;\n    const mediaTagTime = mediaTagCurrentTime.current.time;\n    const rvcTime = rvcCurrentTime.current?.time ?? null;\n    const isVariableFpsVideo = isVariableFpsVideoMap.current[src];\n    const timeShiftMediaTag = Math.abs(shouldBeTime - mediaTagTime);\n    const timeShiftRvcTag = rvcTime ? Math.abs(shouldBeTime - rvcTime) : null;\n    const mostRecentTimeshift = rvcCurrentTime.current?.lastUpdate && rvcCurrentTime.current.time > mediaTagCurrentTime.current.lastUpdate ? timeShiftRvcTag : timeShiftMediaTag;\n    const timeShift = timeShiftRvcTag && !isVariableFpsVideo ? mostRecentTimeshift : timeShiftMediaTag;\n    if (timeShift > acceptableTimeShiftButLessThanDuration && lastSeekDueToShift.current !== shouldBeTime) {\n      lastSeek.current = seek({\n        mediaRef: mediaRef.current,\n        time: shouldBeTime,\n        logLevel,\n        why: `because time shift is too big. shouldBeTime = ${shouldBeTime}, isTime = ${mediaTagTime}, requestVideoCallbackTime = ${rvcTime}, timeShift = ${timeShift}${isVariableFpsVideo ? \", isVariableFpsVideo = true\" : \"\"}, isPremounting = ${isPremounting}, isPostmounting = ${isPostmounting}, pauseWhenBuffering = ${pauseWhenBuffering}`,\n        mountTime\n      });\n      lastSeekDueToShift.current = lastSeek.current;\n      if (playing) {\n        if (playbackRate > 0) {\n          bufferUntilFirstFrame(shouldBeTime);\n        }\n        if (mediaRef.current.paused) {\n          playAndHandleNotAllowedError({\n            mediaRef,\n            mediaType,\n            onAutoPlayError,\n            logLevel,\n            mountTime,\n            reason: \"player is playing but media tag is paused, and just seeked\",\n            isPlayer: env.isPlayer\n          });\n        }\n      }\n      if (!onlyWarnForMediaSeekingError) {\n        warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? \"console-warning\" : \"console-error\");\n      }\n      return;\n    }\n    const seekThreshold = playing ? 0.15 : 0.01;\n    const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > seekThreshold;\n    const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n    const isSomethingElseBuffering = buffering.buffering.current && !isMediaTagBufferingOrStalled;\n    if (!playing || isSomethingElseBuffering) {\n      if (makesSenseToSeek) {\n        lastSeek.current = seek({\n          mediaRef: mediaRef.current,\n          time: shouldBeTime,\n          logLevel,\n          why: `not playing or something else is buffering. time offset is over seek threshold (${seekThreshold})`,\n          mountTime\n        });\n      }\n      return;\n    }\n    if (!playing || buffering.buffering.current) {\n      return;\n    }\n    const pausedCondition = mediaRef.current.paused && !mediaRef.current.ended;\n    const firstFrameCondition = absoluteFrame === 0;\n    if (pausedCondition || firstFrameCondition) {\n      const reason = pausedCondition ? \"media tag is paused\" : \"absolute frame is 0\";\n      if (makesSenseToSeek) {\n        lastSeek.current = seek({\n          mediaRef: mediaRef.current,\n          time: shouldBeTime,\n          logLevel,\n          why: `is over timeshift threshold (threshold = ${seekThreshold}) and ${reason}`,\n          mountTime\n        });\n      }\n      playAndHandleNotAllowedError({\n        mediaRef,\n        mediaType,\n        onAutoPlayError,\n        logLevel,\n        mountTime,\n        reason: `player is playing and ${reason}`,\n        isPlayer: env.isPlayer\n      });\n      if (!isVariableFpsVideo && playbackRate > 0) {\n        bufferUntilFirstFrame(shouldBeTime);\n      }\n    }\n  }, [\n    absoluteFrame,\n    acceptableTimeShiftButLessThanDuration,\n    bufferUntilFirstFrame,\n    buffering.buffering,\n    rvcCurrentTime,\n    logLevel,\n    desiredUnclampedTime,\n    isBuffering,\n    isMediaTagBuffering,\n    mediaRef,\n    mediaType,\n    onlyWarnForMediaSeekingError,\n    playbackRate,\n    playing,\n    src,\n    onAutoPlayError,\n    isPremounting,\n    isPostmounting,\n    pauseWhenBuffering,\n    mountTime,\n    mediaTagCurrentTime,\n    env.isPlayer\n  ]);\n};\n\n// src/use-media-tag.ts\n\nvar useMediaTag = ({\n  mediaRef,\n  id,\n  mediaType,\n  onAutoPlayError,\n  isPremounting,\n  isPostmounting\n}) => {\n  const { audioAndVideoTags, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const logLevel = useLogLevel();\n  const mountTime = useMountTime();\n  const env = useRemotionEnvironment();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const tag = {\n      id,\n      play: (reason) => {\n        if (!imperativePlaying.current) {\n          return;\n        }\n        if (isPremounting || isPostmounting) {\n          return;\n        }\n        return playAndHandleNotAllowedError({\n          mediaRef,\n          mediaType,\n          onAutoPlayError,\n          logLevel,\n          mountTime,\n          reason,\n          isPlayer: env.isPlayer\n        });\n      }\n    };\n    audioAndVideoTags.current.push(tag);\n    return () => {\n      audioAndVideoTags.current = audioAndVideoTags.current.filter((a) => a.id !== id);\n    };\n  }, [\n    audioAndVideoTags,\n    id,\n    mediaRef,\n    mediaType,\n    onAutoPlayError,\n    imperativePlaying,\n    isPremounting,\n    isPostmounting,\n    logLevel,\n    mountTime,\n    env.isPlayer\n  ]);\n};\n\n// src/volume-position-state.ts\n\nvar MediaVolumeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  mediaMuted: false,\n  mediaVolume: 1\n});\nvar SetMediaVolumeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  setMediaMuted: () => {\n    throw new Error(\"default\");\n  },\n  setMediaVolume: () => {\n    throw new Error(\"default\");\n  }\n});\nvar useMediaVolumeState = () => {\n  const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n  const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [mediaVolume, setMediaVolume];\n  }, [mediaVolume, setMediaVolume]);\n};\nvar useMediaMutedState = () => {\n  const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n  const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [mediaMuted, setMediaMuted];\n  }, [mediaMuted, setMediaMuted]);\n};\n\n// src/volume-safeguard.ts\nvar warnAboutTooHighVolume = (volume) => {\n  if (volume >= 100) {\n    throw new Error(`Volume was set to ${volume}, but regular volume is 1, not 100. Did you forget to divide by 100? Set a volume of less than 100 to dismiss this error.`);\n  }\n};\n\n// src/audio/AudioForPreview.tsx\n\nvar AudioForDevelopmentForwardRefFunction = (props, ref) => {\n  const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);\n  if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {\n    throw new Error(\"Cannot change the behavior for pre-mounting audio tags dynamically.\");\n  }\n  const logLevel = useLogLevel();\n  const {\n    volume,\n    muted,\n    playbackRate,\n    shouldPreMountAudioTags,\n    src,\n    onDuration,\n    acceptableTimeShiftInSeconds,\n    _remotionInternalNeedsDurationCalculation,\n    _remotionInternalNativeLoopPassed,\n    _remotionInternalStack,\n    allowAmplificationDuringRender,\n    name,\n    pauseWhenBuffering,\n    showInTimeline,\n    loopVolumeCurveBehavior,\n    stack,\n    crossOrigin,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    toneFrequency,\n    useWebAudioApi,\n    onError,\n    onNativeError,\n    audioStreamIndex,\n    ...nativeProps\n  } = props;\n  const _propsValid = true;\n  if (!_propsValid) {\n    throw new Error(\"typecheck error\");\n  }\n  const [mediaVolume] = useMediaVolumeState();\n  const [mediaMuted] = useMediaMutedState();\n  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n  if (!src) {\n    throw new TypeError(\"No 'src' was passed to <Html5Audio>.\");\n  }\n  const preloadedSrc = usePreload(src);\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));\n  const isSequenceHidden = hidden[timelineId] ?? false;\n  const userPreferredVolume = evaluateVolume({\n    frame: volumePropFrame,\n    volume,\n    mediaVolume\n  });\n  warnAboutTooHighVolume(userPreferredVolume);\n  const crossOriginValue = getCrossOriginValue({\n    crossOrigin,\n    requestsVideoFrame: false\n  });\n  const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n      src: preloadedSrc,\n      loop: _remotionInternalNativeLoopPassed,\n      crossOrigin: crossOriginValue,\n      ...nativeProps\n    };\n  }, [\n    _remotionInternalNativeLoopPassed,\n    isSequenceHidden,\n    mediaMuted,\n    muted,\n    nativeProps,\n    preloadedSrc,\n    userPreferredVolume,\n    crossOriginValue\n  ]);\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `audio-${random(src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}-muted:${props.muted}-loop:${props.loop}`, [\n    src,\n    sequenceContext?.relativeFrom,\n    sequenceContext?.cumulatedFrom,\n    sequenceContext?.durationInFrames,\n    props.muted,\n    props.loop\n  ]);\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  if (!context) {\n    throw new Error(\"SharedAudioContext not found\");\n  }\n  const { el: audioRef, mediaElementSourceNode } = useSharedAudio({\n    aud: propsToPass,\n    audioId: id,\n    premounting: Boolean(sequenceContext?.premounting)\n  });\n  useMediaInTimeline({\n    volume,\n    mediaVolume,\n    src,\n    mediaType: \"audio\",\n    playbackRate: playbackRate ?? 1,\n    displayName: name ?? null,\n    id: timelineId,\n    stack: _remotionInternalStack,\n    showInTimeline,\n    premountDisplay: sequenceContext?.premountDisplay ?? null,\n    postmountDisplay: sequenceContext?.postmountDisplay ?? null,\n    loopDisplay: undefined\n  });\n  useMediaPlayback({\n    mediaRef: audioRef,\n    src,\n    mediaType: \"audio\",\n    playbackRate: playbackRate ?? 1,\n    onlyWarnForMediaSeekingError: false,\n    acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n    isPremounting: Boolean(sequenceContext?.premounting),\n    isPostmounting: Boolean(sequenceContext?.postmounting),\n    pauseWhenBuffering,\n    onAutoPlayError: null\n  });\n  useMediaTag({\n    id: timelineId,\n    isPostmounting: Boolean(sequenceContext?.postmounting),\n    isPremounting: Boolean(sequenceContext?.premounting),\n    mediaRef: audioRef,\n    mediaType: \"audio\",\n    onAutoPlayError: null\n  });\n  useVolume({\n    logLevel,\n    mediaRef: audioRef,\n    source: mediaElementSourceNode,\n    volume: userPreferredVolume,\n    shouldUseWebAudioApi: useWebAudioApi ?? false\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return audioRef.current;\n  }, [audioRef]);\n  const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n  currentOnDurationCallback.current = onDuration;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = audioRef;\n    if (!current) {\n      return;\n    }\n    if (current.duration) {\n      currentOnDurationCallback.current?.(current.src, current.duration);\n      return;\n    }\n    const onLoadedMetadata = () => {\n      currentOnDurationCallback.current?.(current.src, current.duration);\n    };\n    current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n    return () => {\n      current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n    };\n  }, [audioRef, src]);\n  if (initialShouldPreMountAudioElements) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n    ref: audioRef,\n    preload: \"metadata\",\n    crossOrigin: crossOriginValue,\n    ...propsToPass\n  });\n};\nvar AudioForPreview = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);\n\n// src/audio/AudioForRendering.tsx\n\n\nvar AudioForRenderingRefForwardingFunction = (props, ref) => {\n  const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const {\n    volume: volumeProp,\n    playbackRate,\n    allowAmplificationDuringRender,\n    onDuration,\n    toneFrequency,\n    _remotionInternalNeedsDurationCalculation,\n    _remotionInternalNativeLoopPassed,\n    acceptableTimeShiftInSeconds,\n    name,\n    onNativeError,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    loopVolumeCurveBehavior,\n    pauseWhenBuffering,\n    audioStreamIndex,\n    ...nativeProps\n  } = props;\n  const absoluteFrame = useTimelinePosition();\n  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n  const frame = useCurrentFrame();\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `audio-${random(props.src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}`, [\n    props.src,\n    sequenceContext?.relativeFrom,\n    sequenceContext?.cumulatedFrom,\n    sequenceContext?.durationInFrames\n  ]);\n  const volume = evaluateVolume({\n    volume: volumeProp,\n    frame: volumePropFrame,\n    mediaVolume: 1\n  });\n  warnAboutTooHighVolume(volume);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return audioRef.current;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!props.src) {\n      throw new Error(\"No src passed\");\n    }\n    if (!window.remotion_audioEnabled) {\n      return;\n    }\n    if (props.muted) {\n      return;\n    }\n    if (volume <= 0) {\n      return;\n    }\n    registerRenderAsset({\n      type: \"audio\",\n      src: getAbsoluteSrc(props.src),\n      id,\n      frame: absoluteFrame,\n      volume,\n      mediaFrame: frame,\n      playbackRate: props.playbackRate ?? 1,\n      toneFrequency: toneFrequency ?? 1,\n      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n      audioStreamIndex: audioStreamIndex ?? 0\n    });\n    return () => unregisterRenderAsset(id);\n  }, [\n    props.muted,\n    props.src,\n    registerRenderAsset,\n    absoluteFrame,\n    id,\n    unregisterRenderAsset,\n    volume,\n    volumePropFrame,\n    frame,\n    playbackRate,\n    props.playbackRate,\n    toneFrequency,\n    sequenceContext?.relativeFrom,\n    audioStreamIndex\n  ]);\n  const { src } = props;\n  const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (window.process?.env?.NODE_ENV === \"test\") {\n      return;\n    }\n    if (!needsToRenderAudioTag) {\n      return;\n    }\n    const newHandle = delayRender2(\"Loading <Html5Audio> duration with src=\" + src, {\n      retries: delayRenderRetries ?? undefined,\n      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n    });\n    const { current } = audioRef;\n    const didLoad = () => {\n      if (current?.duration) {\n        onDuration(current.src, current.duration);\n      }\n      continueRender2(newHandle);\n    };\n    if (current?.duration) {\n      onDuration(current.src, current.duration);\n      continueRender2(newHandle);\n    } else {\n      current?.addEventListener(\"loadedmetadata\", didLoad, { once: true });\n    }\n    return () => {\n      current?.removeEventListener(\"loadedmetadata\", didLoad);\n      continueRender2(newHandle);\n    };\n  }, [\n    src,\n    onDuration,\n    needsToRenderAudioTag,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    continueRender2,\n    delayRender2\n  ]);\n  if (!needsToRenderAudioTag) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n    ref: audioRef,\n    ...nativeProps,\n    onError: onNativeError\n  });\n};\nvar AudioForRendering = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);\n\n// src/audio/Audio.tsx\n\nvar AudioRefForwardingFunction = (props, ref) => {\n  const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  const {\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter,\n    name,\n    stack,\n    pauseWhenBuffering,\n    showInTimeline,\n    onError: onRemotionError,\n    ...otherProps\n  } = props;\n  const { loop, ...propsOtherThanLoop } = props;\n  const { fps } = useVideoConfig();\n  const environment = useRemotionEnvironment();\n  const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n  if (typeof props.src !== \"string\") {\n    throw new TypeError(`The \\`<Html5Audio>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n  }\n  const preloadedSrc = usePreload(props.src);\n  const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n    console.log(e.currentTarget.error);\n    const errMessage = `Could not play audio with src ${preloadedSrc}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;\n    if (loop) {\n      if (onRemotionError) {\n        onRemotionError(new Error(errMessage));\n        return;\n      }\n      cancelRender(new Error(errMessage));\n    } else {\n      onRemotionError?.(new Error(errMessage));\n      console.warn(errMessage);\n    }\n  }, [loop, onRemotionError, preloadedSrc]);\n  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds) => {\n    setDurations({ type: \"got-duration\", durationInSeconds, src });\n  }, [setDurations]);\n  const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props.src)];\n  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });\n  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter\n  });\n  if (loop && durationFetched !== undefined) {\n    if (!Number.isFinite(durationFetched)) {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {\n        ...propsOtherThanLoop,\n        ref,\n        _remotionInternalNativeLoopPassed: true\n      });\n    }\n    const duration = durationFetched * fps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n      layout: \"none\",\n      durationInFrames: calculateMediaDuration({\n        trimAfter: trimAfterValue,\n        mediaDurationInFrames: duration,\n        playbackRate: props.playbackRate ?? 1,\n        trimBefore: trimBeforeValue\n      }),\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {\n        ...propsOtherThanLoop,\n        ref,\n        _remotionInternalNativeLoopPassed: true\n      })\n    });\n  }\n  if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      layout: \"none\",\n      from: 0 - (trimBeforeValue ?? 0),\n      showInTimeline: false,\n      durationInFrames: trimAfterValue,\n      name,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {\n        _remotionInternalNeedsDurationCalculation: Boolean(loop),\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        ...otherProps,\n        ref\n      })\n    });\n  }\n  validateMediaProps({ playbackRate: props.playbackRate, volume: props.volume }, \"Html5Audio\");\n  if (environment.isRendering) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, {\n      onDuration,\n      ...props,\n      ref,\n      onNativeError: onError,\n      _remotionInternalNeedsDurationCalculation: Boolean(loop)\n    });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForPreview, {\n    _remotionInternalNativeLoopPassed: props._remotionInternalNativeLoopPassed ?? false,\n    _remotionInternalStack: stack ?? null,\n    shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0,\n    ...props,\n    ref,\n    onNativeError: onError,\n    onDuration,\n    pauseWhenBuffering: pauseWhenBuffering ?? false,\n    _remotionInternalNeedsDurationCalculation: Boolean(loop),\n    showInTimeline: showInTimeline ?? true\n  });\n};\nvar Html5Audio = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);\naddSequenceStackTraces(Html5Audio);\nvar Audio = Html5Audio;\n// src/Composition.tsx\n\n\n\n// src/Folder.tsx\n\n\n// src/validation/validate-folder-name.ts\nvar getRegex = () => /^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isFolderNameValid = (name) => name.match(getRegex());\nvar validateFolderName = (name) => {\n  if (name === undefined || name === null) {\n    throw new TypeError(\"You must pass a name to a <Folder />.\");\n  }\n  if (typeof name !== \"string\") {\n    throw new TypeError(`The \"name\" you pass into <Folder /> must be a string. Got: ${typeof name}`);\n  }\n  if (!isFolderNameValid(name)) {\n    throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);\n  }\n};\nvar invalidFolderNameErrorMessage = `Folder name must match ${String(getRegex())}`;\n\n// src/Folder.tsx\n\nvar FolderContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  folderName: null,\n  parentName: null\n});\nvar Folder = ({ name, children }) => {\n  const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n  const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n  validateFolderName(name);\n  const parentNameArr = [parent.parentName, parent.folderName].filter(truthy);\n  const parentName = parentNameArr.length === 0 ? null : parentNameArr.join(\"/\");\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      folderName: name,\n      parentName\n    };\n  }, [name, parentName]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    registerFolder(name, parentName);\n    return () => {\n      unregisterFolder(name, parentName);\n    };\n  }, [name, parent.folderName, parentName, registerFolder, unregisterFolder]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, {\n    value,\n    children\n  });\n};\n\n// src/loading-indicator.tsx\n\nvar rotate = {\n  transform: `rotate(90deg)`\n};\nvar ICON_SIZE = 40;\nvar label = {\n  color: \"white\",\n  fontSize: 14,\n  fontFamily: \"sans-serif\"\n};\nvar container = {\n  justifyContent: \"center\",\n  alignItems: \"center\"\n};\nvar Loading = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, {\n    style: container,\n    id: \"remotion-comp-loading\",\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", {\n        type: \"text/css\",\n        children: `\n\t\t\t\t@keyframes anim {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t\tto {\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#remotion-comp-loading {\n\t\t\t\t\tanimation: anim 2s;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t}\n\t\t\t`\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n        width: ICON_SIZE,\n        height: ICON_SIZE,\n        viewBox: \"-100 -100 400 400\",\n        style: rotate,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n          fill: \"#555\",\n          stroke: \"#555\",\n          strokeWidth: \"100\",\n          strokeLinejoin: \"round\",\n          d: \"M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z\"\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", {\n        style: label,\n        children: [\n          \"Resolving \",\n          \"<Suspense>\",\n          \"...\"\n        ]\n      })\n    ]\n  });\n};\n\n// src/portal-node.ts\nvar _portalNode = null;\nvar portalNode = () => {\n  if (!_portalNode) {\n    if (typeof document === \"undefined\") {\n      throw new Error(\"Tried to call an API that only works in the browser from outside the browser\");\n    }\n    _portalNode = document.createElement(\"div\");\n    _portalNode.style.position = \"absolute\";\n    _portalNode.style.top = \"0px\";\n    _portalNode.style.left = \"0px\";\n    _portalNode.style.right = \"0px\";\n    _portalNode.style.bottom = \"0px\";\n    _portalNode.style.width = \"100%\";\n    _portalNode.style.height = \"100%\";\n    _portalNode.style.display = \"flex\";\n    _portalNode.style.flexDirection = \"column\";\n    const containerNode = document.createElement(\"div\");\n    containerNode.style.position = \"fixed\";\n    containerNode.style.top = -999999 + \"px\";\n    containerNode.appendChild(_portalNode);\n    document.body.appendChild(containerNode);\n  }\n  return _portalNode;\n};\n\n// src/use-lazy-component.ts\n\nvar useLazyComponent = ({\n  compProps,\n  componentName,\n  noSuspense\n}) => {\n  const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (\"component\" in compProps) {\n      if (typeof document === \"undefined\" || noSuspense) {\n        return compProps.component;\n      }\n      if (typeof compProps.component === \"undefined\") {\n        throw new Error(`A value of \\`undefined\\` was passed to the \\`component\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n      }\n      return compProps.component;\n    }\n    if (\"lazyComponent\" in compProps && typeof compProps.lazyComponent !== \"undefined\") {\n      if (typeof compProps.lazyComponent === \"undefined\") {\n        throw new Error(`A value of \\`undefined\\` was passed to the \\`lazyComponent\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n      }\n      return react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);\n    }\n    throw new Error(\"You must pass either 'component' or 'lazyComponent'\");\n  }, [compProps.component, compProps.lazyComponent]);\n  return lazy;\n};\n\n// src/validation/validate-composition-id.ts\nvar getRegex2 = () => /^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isCompositionIdValid = (id) => id.match(getRegex2());\nvar validateCompositionId = (id) => {\n  if (!isCompositionIdValid(id)) {\n    throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${id}`);\n  }\n};\nvar invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex2())}`;\n\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId) => {\n  if (!defaultProps) {\n    return;\n  }\n  if (typeof defaultProps !== \"object\") {\n    throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n  }\n  if (Array.isArray(defaultProps)) {\n    throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n  }\n};\n\n// src/Composition.tsx\n\nvar Fallback = () => {\n  const { continueRender: continueRender2, delayRender: delayRender2 } = useDelayRender();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const fallback = delayRender2(\"Waiting for Root component to unsuspend\");\n    return () => continueRender2(fallback);\n  }, [continueRender2, delayRender2]);\n  return null;\n};\nvar InnerComposition = ({\n  width,\n  height,\n  fps,\n  durationInFrames,\n  id,\n  defaultProps,\n  schema,\n  ...compProps\n}) => {\n  const compManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n  const { registerComposition, unregisterComposition } = compManager;\n  const video = useVideo();\n  const lazy = useLazyComponent({\n    compProps,\n    componentName: \"Composition\",\n    noSuspense: false\n  });\n  const nonce = useNonce();\n  const isPlayer = useIsPlayer();\n  const environment = useRemotionEnvironment();\n  const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n  if (typeof window !== \"undefined\") {\n    window.remotion_seenCompositionIds = Array.from(new Set([...window.remotion_seenCompositionIds ?? [], id]));\n  }\n  if (canUseComposition) {\n    if (isPlayer) {\n      throw new Error(\"<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n    }\n    throw new Error(\"<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n  }\n  const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!id) {\n      throw new Error(\"No id for composition passed.\");\n    }\n    validateCompositionId(id);\n    validateDefaultAndInputProps(defaultProps, \"defaultProps\", id);\n    registerComposition({\n      durationInFrames: durationInFrames ?? undefined,\n      fps: fps ?? undefined,\n      height: height ?? undefined,\n      width: width ?? undefined,\n      id,\n      folderName,\n      component: lazy,\n      defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n      nonce,\n      parentFolderName: parentName,\n      schema: schema ?? null,\n      calculateMetadata: compProps.calculateMetadata ?? null\n    });\n    return () => {\n      unregisterComposition(id);\n    };\n  }, [\n    durationInFrames,\n    fps,\n    height,\n    lazy,\n    id,\n    folderName,\n    defaultProps,\n    width,\n    nonce,\n    parentName,\n    schema,\n    compProps.calculateMetadata,\n    registerComposition,\n    unregisterComposition\n  ]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    window.dispatchEvent(new CustomEvent(PROPS_UPDATED_EXTERNALLY, {\n      detail: {\n        resetUnsaved: id\n      }\n    }));\n  }, [defaultProps, id]);\n  const resolved = useResolvedVideoConfig(id);\n  if (environment.isStudio && video && video.component === lazy && video.id === id) {\n    const Comp = lazy;\n    if (resolved === null || resolved.type !== \"success\" && resolved.type !== \"success-and-refreshing\") {\n      return null;\n    }\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}),\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n          ...resolved.result.props ?? {}\n        })\n      })\n    }), portalNode());\n  }\n  if (environment.isRendering && video && video.component === lazy && video.id === id) {\n    const Comp = lazy;\n    if (resolved === null || resolved.type !== \"success\" && resolved.type !== \"success-and-refreshing\") {\n      return null;\n    }\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}),\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n          ...resolved.result.props ?? {}\n        })\n      })\n    }), portalNode());\n  }\n  return null;\n};\nvar Composition = (props2) => {\n  const { onlyRenderComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n  if (onlyRenderComposition && onlyRenderComposition !== props2.id) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerComposition, {\n    ...props2\n  });\n};\n// src/bezier.ts\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nfunction a(aA1, aA2) {\n  return 1 - 3 * aA2 + 3 * aA1;\n}\nfunction b(aA1, aA2) {\n  return 3 * aA2 - 6 * aA1;\n}\nfunction c(aA1) {\n  return 3 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n  return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n  return 3 * a(aA1, aA2) * aT * aT + 2 * b(aA1, aA2) * aT + c(aA1);\n}\nfunction binarySubdivide({\n  aX,\n  _aA,\n  _aB,\n  mX1,\n  mX2\n}) {\n  let currentX;\n  let currentT;\n  let i = 0;\n  let aA = _aA;\n  let aB = _aB;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  let aGuessT = _aGuessT;\n  for (let i = 0;i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error(\"bezier x values must be in [0, 1] range\");\n  }\n  const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (let i = 0;i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n  function getTForX(aX) {\n    let intervalStart = 0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n    for (;currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    }\n    if (initialSlope === 0) {\n      return guessForT;\n    }\n    return binarySubdivide({\n      aX,\n      _aA: intervalStart,\n      _aB: intervalStart + kSampleStepSize,\n      mX1,\n      mX2\n    });\n  }\n  return function(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x;\n    }\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n\n// src/easing.ts\nclass Easing {\n  static step0(n) {\n    return n > 0 ? 1 : 0;\n  }\n  static step1(n) {\n    return n >= 1 ? 1 : 0;\n  }\n  static linear(t) {\n    return t;\n  }\n  static ease(t) {\n    return Easing.bezier(0.42, 0, 1, 1)(t);\n  }\n  static quad(t) {\n    return t * t;\n  }\n  static cubic(t) {\n    return t * t * t;\n  }\n  static poly(n) {\n    return (t) => t ** n;\n  }\n  static sin(t) {\n    return 1 - Math.cos(t * Math.PI / 2);\n  }\n  static circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n  static exp(t) {\n    return 2 ** (10 * (t - 1));\n  }\n  static elastic(bounciness = 1) {\n    const p = bounciness * Math.PI;\n    return (t) => 1 - Math.cos(t * Math.PI / 2) ** 3 * Math.cos(t * p);\n  }\n  static back(s = 1.70158) {\n    return (t) => t * t * ((s + 1) * t - s);\n  }\n  static bounce(t) {\n    if (t < 1 / 2.75) {\n      return 7.5625 * t * t;\n    }\n    if (t < 2 / 2.75) {\n      const t2_ = t - 1.5 / 2.75;\n      return 7.5625 * t2_ * t2_ + 0.75;\n    }\n    if (t < 2.5 / 2.75) {\n      const t2_ = t - 2.25 / 2.75;\n      return 7.5625 * t2_ * t2_ + 0.9375;\n    }\n    const t2 = t - 2.625 / 2.75;\n    return 7.5625 * t2 * t2 + 0.984375;\n  }\n  static bezier(x1, y1, x2, y2) {\n    return bezier(x1, y1, x2, y2);\n  }\n  static in(easing) {\n    return easing;\n  }\n  static out(easing) {\n    return (t) => 1 - easing(1 - t);\n  }\n  static inOut(easing) {\n    return (t) => {\n      if (t < 0.5) {\n        return easing(t * 2) / 2;\n      }\n      return 1 - easing((1 - t) * 2) / 2;\n    };\n  }\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n\n// src/get-static-files.ts\nvar warnedServer = false;\nvar warnedPlayer = false;\nvar warnServerOnce = () => {\n  if (warnedServer) {\n    return;\n  }\n  warnedServer = true;\n  console.warn(\"Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.\");\n};\nvar warnPlayerOnce = () => {\n  if (warnedPlayer) {\n    return;\n  }\n  warnedPlayer = true;\n  console.warn(\"Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.\");\n};\nvar getStaticFiles = () => {\n  if (ENABLE_V5_BREAKING_CHANGES) {\n    throw new Error(\"getStaticFiles() has moved into the `@remotion/studio` package. Update your imports.\");\n  }\n  if (typeof document === \"undefined\") {\n    warnServerOnce();\n    return [];\n  }\n  if (window.remotion_isPlayer) {\n    warnPlayerOnce();\n    return [];\n  }\n  return window.remotion_staticFiles;\n};\n// src/IFrame.tsx\n\n\nvar IFrameRefForwarding = ({\n  onLoad,\n  onError,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  ...props2\n}, ref) => {\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => delayRender2(`Loading <IFrame> with source ${props2.src}`, {\n    retries: delayRenderRetries ?? undefined,\n    timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n  }));\n  const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n    continueRender2(handle);\n    onLoad?.(e);\n  }, [handle, onLoad, continueRender2]);\n  const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n    continueRender2(handle);\n    if (onError) {\n      onError(e);\n    } else {\n      console.error(\"Error loading iframe:\", e, \"Handle the event using the onError() prop to make this message disappear.\");\n    }\n  }, [handle, onError, continueRender2]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"iframe\", {\n    referrerPolicy: \"strict-origin-when-cross-origin\",\n    ...props2,\n    ref,\n    onError: didGetError,\n    onLoad: didLoad\n  });\n};\nvar IFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);\n// src/Img.tsx\n\n\nfunction exponentialBackoff(errorCount) {\n  return 1000 * 2 ** (errorCount - 1);\n}\nvar ImgRefForwarding = ({\n  onError,\n  maxRetries = 2,\n  src,\n  pauseWhenLoading,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  onImageFrame,\n  crossOrigin,\n  ...props2\n}, ref) => {\n  const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  const { delayPlayback } = useBufferState();\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  if (!src) {\n    throw new Error('No \"src\" prop was passed to <Img>.');\n  }\n  const _propsValid = true;\n  if (!_propsValid) {\n    throw new Error(\"typecheck error\");\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return imageRef.current;\n  }, []);\n  const actualSrc = usePreload(src);\n  const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timeout) => {\n    if (!imageRef.current) {\n      return;\n    }\n    const currentSrc = imageRef.current.src;\n    setTimeout(() => {\n      if (!imageRef.current) {\n        return;\n      }\n      const newSrc = imageRef.current?.src;\n      if (newSrc !== currentSrc) {\n        return;\n      }\n      imageRef.current.removeAttribute(\"src\");\n      imageRef.current.setAttribute(\"src\", newSrc);\n    }, timeout);\n  }, []);\n  const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n    if (!errors.current) {\n      return;\n    }\n    errors.current[imageRef.current?.src] = (errors.current[imageRef.current?.src] ?? 0) + 1;\n    if (onError && (errors.current[imageRef.current?.src] ?? 0) > maxRetries) {\n      onError(e);\n      return;\n    }\n    if ((errors.current[imageRef.current?.src] ?? 0) <= maxRetries) {\n      const backoff = exponentialBackoff(errors.current[imageRef.current?.src] ?? 0);\n      console.warn(`Could not load image with source ${imageRef.current?.src}, retrying again in ${backoff}ms`);\n      retryIn(backoff);\n      return;\n    }\n    cancelRender(\"Error loading image with src: \" + imageRef.current?.src);\n  }, [maxRetries, onError, retryIn]);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  if (typeof window !== \"undefined\") {\n    const isPremounting = Boolean(sequenceContext?.premounting);\n    const isPostmounting = Boolean(sequenceContext?.postmounting);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      if (window.process?.env?.NODE_ENV === \"test\") {\n        if (imageRef.current) {\n          imageRef.current.src = actualSrc;\n        }\n        return;\n      }\n      const { current } = imageRef;\n      if (!current) {\n        return;\n      }\n      const newHandle = delayRender2(\"Loading <Img> with src=\" + actualSrc, {\n        retries: delayRenderRetries ?? undefined,\n        timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n      });\n      const unblock = pauseWhenLoading && !isPremounting && !isPostmounting ? delayPlayback().unblock : () => {\n        return;\n      };\n      let unmounted = false;\n      const onComplete = () => {\n        if (unmounted) {\n          continueRender2(newHandle);\n          return;\n        }\n        if ((errors.current[imageRef.current?.src] ?? 0) > 0) {\n          delete errors.current[imageRef.current?.src];\n          console.info(`Retry successful - ${imageRef.current?.src} is now loaded`);\n        }\n        if (current) {\n          onImageFrame?.(current);\n        }\n        unblock();\n        continueRender2(newHandle);\n      };\n      if (!imageRef.current) {\n        onComplete();\n        return;\n      }\n      current.src = actualSrc;\n      current.decode().then(onComplete).catch((err) => {\n        console.warn(err);\n        if (current.complete) {\n          onComplete();\n        } else {\n          current.addEventListener(\"load\", onComplete);\n        }\n      });\n      return () => {\n        unmounted = true;\n        current.removeEventListener(\"load\", onComplete);\n        unblock();\n        continueRender2(newHandle);\n      };\n    }, [\n      actualSrc,\n      delayPlayback,\n      delayRenderRetries,\n      delayRenderTimeoutInMilliseconds,\n      pauseWhenLoading,\n      isPremounting,\n      isPostmounting,\n      onImageFrame,\n      continueRender2,\n      delayRender2\n    ]);\n  }\n  const crossOriginValue = getCrossOriginValue({\n    crossOrigin,\n    requestsVideoFrame: false\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", {\n    ...props2,\n    ref: imageRef,\n    crossOrigin: crossOriginValue,\n    onError: didGetError,\n    decoding: \"sync\"\n  });\n};\nvar Img = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);\n// src/internals.ts\n\n\n// src/CompositionManager.tsx\n\nvar compositionsRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n\n// src/CompositionManagerProvider.tsx\n\n\nvar CompositionManagerProvider = ({\n  children,\n  onlyRenderComposition,\n  currentCompositionMetadata,\n  initialCompositions,\n  initialCanvasContent\n}) => {\n  const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialCanvasContent);\n  const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialCompositions);\n  const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);\n  const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updateComps) => {\n    setCompositions((comps) => {\n      const updated = updateComps(comps);\n      currentcompositionsRef.current = updated;\n      return updated;\n    });\n  }, []);\n  const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((comp) => {\n    updateCompositions((comps) => {\n      if (comps.find((c2) => c2.id === comp.id)) {\n        throw new Error(`Multiple composition with id ${comp.id} are registered.`);\n      }\n      const value = [...comps, comp].slice().sort((a2, b2) => a2.nonce - b2.nonce);\n      return value;\n    });\n  }, [updateCompositions]);\n  const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n    setCompositions((comps) => {\n      return comps.filter((c2) => c2.id !== id);\n    });\n  }, []);\n  const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent) => {\n    setFolders((prevFolders) => {\n      return [\n        ...prevFolders,\n        {\n          name,\n          parent\n        }\n      ];\n    });\n  }, []);\n  const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent) => {\n    setFolders((prevFolders) => {\n      return prevFolders.filter((p) => !(p.name === name && p.parent === parent));\n    });\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, () => {\n    return {\n      getCompositions: () => currentcompositionsRef.current\n    };\n  }, []);\n  const updateCompositionDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, newDefaultProps) => {\n    setCompositions((comps) => {\n      const updated = comps.map((c2) => {\n        if (c2.id === id) {\n          return {\n            ...c2,\n            defaultProps: newDefaultProps\n          };\n        }\n        return c2;\n      });\n      return updated;\n    });\n  }, []);\n  const compositionManagerSetters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      registerComposition,\n      unregisterComposition,\n      registerFolder,\n      unregisterFolder,\n      setCanvasContent,\n      updateCompositionDefaultProps,\n      onlyRenderComposition\n    };\n  }, [\n    registerComposition,\n    registerFolder,\n    unregisterComposition,\n    unregisterFolder,\n    updateCompositionDefaultProps,\n    onlyRenderComposition\n  ]);\n  const compositionManagerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      compositions,\n      folders,\n      currentCompositionMetadata,\n      canvasContent\n    };\n  }, [compositions, folders, currentCompositionMetadata, canvasContent]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n    value: compositionManagerContextValue,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionSetters.Provider, {\n      value: compositionManagerSetters,\n      children\n    })\n  });\n};\n\n// src/default-css.ts\nvar exports_default_css = {};\n__export(exports_default_css, {\n  makeDefaultPreviewCSS: () => makeDefaultPreviewCSS,\n  injectCSS: () => injectCSS,\n  OBJECTFIT_CONTAIN_CLASS_NAME: () => OBJECTFIT_CONTAIN_CLASS_NAME\n});\nvar injected = {};\nvar injectCSS = (css) => {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n  if (injected[css]) {\n    return;\n  }\n  const head = document.head || document.getElementsByTagName(\"head\")[0];\n  const style = document.createElement(\"style\");\n  style.appendChild(document.createTextNode(css));\n  head.prepend(style);\n  injected[css] = true;\n};\nvar OBJECTFIT_CONTAIN_CLASS_NAME = \"__remotion_objectfitcontain\";\nvar makeDefaultPreviewCSS = (scope, backgroundColor) => {\n  if (!scope) {\n    return `\n    * {\n      box-sizing: border-box;\n    }\n    body {\n      margin: 0;\n\t    background-color: ${backgroundColor};\n    }\n    .${OBJECTFIT_CONTAIN_CLASS_NAME} {\n      object-fit: contain;\n    }\n    `;\n  }\n  return `\n    ${scope} * {\n      box-sizing: border-box;\n    }\n    ${scope} *:-webkit-full-screen {\n      width: 100%;\n      height: 100%;\n    }\n    ${scope} .${OBJECTFIT_CONTAIN_CLASS_NAME} {\n      object-fit: contain;\n    }\n  `;\n};\n\n// src/get-preview-dom-element.ts\nvar REMOTION_STUDIO_CONTAINER_ELEMENT = \"__remotion-studio-container\";\nvar getPreviewDomElement = () => {\n  return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);\n};\n\n// src/max-video-cache-size.ts\n\nvar MaxMediaCacheSizeContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n// src/register-root.ts\nvar Root = null;\nvar listeners = [];\nvar registerRoot = (comp) => {\n  if (!comp) {\n    throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);\n  }\n  if (Root) {\n    throw new Error(\"registerRoot() was called more than once.\");\n  }\n  Root = comp;\n  listeners.forEach((l) => {\n    l(comp);\n  });\n};\nvar getRoot = () => {\n  return Root;\n};\nvar waitForRoot = (fn) => {\n  if (Root) {\n    fn(Root);\n    return () => {\n      return;\n    };\n  }\n  listeners.push(fn);\n  return () => {\n    listeners = listeners.filter((l) => l !== fn);\n  };\n};\n\n// src/RemotionRoot.tsx\n\n\n// src/use-media-enabled.tsx\n\n\nvar MediaEnabledContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useVideoEnabled = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaEnabledContext);\n  if (!context) {\n    return window.remotion_videoEnabled;\n  }\n  if (context.videoEnabled === null) {\n    return window.remotion_videoEnabled;\n  }\n  return context.videoEnabled;\n};\nvar useAudioEnabled = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaEnabledContext);\n  if (!context) {\n    return window.remotion_audioEnabled;\n  }\n  if (context.audioEnabled === null) {\n    return window.remotion_audioEnabled;\n  }\n  return context.audioEnabled;\n};\nvar MediaEnabledProvider = ({\n  children,\n  videoEnabled,\n  audioEnabled\n}) => {\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ videoEnabled, audioEnabled }), [videoEnabled, audioEnabled]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MediaEnabledContext.Provider, {\n    value,\n    children\n  });\n};\n\n// src/RemotionRoot.tsx\n\nvar RemotionRootContexts = ({\n  children,\n  numberOfAudioTags,\n  logLevel,\n  audioLatencyHint,\n  videoEnabled,\n  audioEnabled,\n  frameState\n}) => {\n  const [fastRefreshes, setFastRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  const [manualRefreshes, setManualRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let counter = 0;\n    return {\n      getNonce: () => counter++,\n      fastRefreshes,\n      manualRefreshes\n    };\n  }, [fastRefreshes, manualRefreshes]);\n  const setNonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      increaseManualRefreshes: () => {\n        setManualRefreshes((i) => i + 1);\n      }\n    };\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (true) {\n      if (__webpack_module__.hot) {\n        __webpack_module__.hot.addStatusHandler((status) => {\n          if (status === \"idle\") {\n            setFastRefreshes((i) => i + 1);\n          }\n        });\n      }\n    }\n  }, []);\n  const logging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return { logLevel, mountTime: Date.now() };\n  }, [logLevel]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n    value: logging,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n      value: nonceContext,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetNonceContext.Provider, {\n        value: setNonceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContextProvider, {\n          frameState,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MediaEnabledProvider, {\n            videoEnabled,\n            audioEnabled,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, {\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, {\n                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, {\n                    numberOfAudioTags,\n                    audioLatencyHint,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, {\n                      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingProvider, {\n                        children\n                      })\n                    })\n                  })\n                })\n              })\n            })\n          })\n        })\n      })\n    })\n  });\n};\n\n// src/setup-env-variables.ts\nvar getEnvVariables = () => {\n  if (getRemotionEnvironment().isRendering) {\n    const param = window.remotion_envVariables;\n    if (!param) {\n      return {};\n    }\n    return { ...JSON.parse(param), NODE_ENV: \"production\" };\n  }\n  if (false) {}\n  return {\n    NODE_ENV: \"production\"\n  };\n};\nvar setupEnvVariables = () => {\n  const env = getEnvVariables();\n  if (!window.process) {\n    window.process = {};\n  }\n  if (!window.process.env) {\n    window.process.env = {};\n  }\n  Object.keys(env).forEach((key) => {\n    window.process.env[key] = env[key];\n  });\n};\n\n// src/use-current-scale.ts\n\nvar CurrentScaleContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar PreviewSizeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  setSize: () => {\n    return;\n  },\n  size: { size: \"auto\", translation: { x: 0, y: 0 } }\n});\nvar calculateScale = ({\n  canvasSize,\n  compositionHeight,\n  compositionWidth,\n  previewSize\n}) => {\n  const heightRatio = canvasSize.height / compositionHeight;\n  const widthRatio = canvasSize.width / compositionWidth;\n  const ratio = Math.min(heightRatio, widthRatio);\n  if (previewSize === \"auto\") {\n    if (ratio === 0) {\n      return 1;\n    }\n    return ratio;\n  }\n  return Number(previewSize);\n};\nvar useCurrentScale = (options) => {\n  const hasContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CurrentScaleContext);\n  const zoomContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreviewSizeContext);\n  const config = useUnsafeVideoConfig();\n  const env = useRemotionEnvironment();\n  if (hasContext === null || config === null || zoomContext === null) {\n    if (options?.dontThrowIfOutsideOfRemotion) {\n      return 1;\n    }\n    if (env.isRendering) {\n      return 1;\n    }\n    throw new Error([\n      \"useCurrentScale() was called outside of a Remotion context.\",\n      \"This hook can only be called in a component that is being rendered by Remotion.\",\n      \"If you want to this hook to return 1 outside of Remotion, pass {dontThrowIfOutsideOfRemotion: true} as an option.\",\n      \"If you think you called this hook in a Remotion component, make sure all versions of Remotion are aligned.\"\n    ].join(`\n`));\n  }\n  if (hasContext.type === \"scale\") {\n    return hasContext.scale;\n  }\n  return calculateScale({\n    canvasSize: hasContext.canvasSize,\n    compositionHeight: config.height,\n    compositionWidth: config.width,\n    previewSize: zoomContext.size.size\n  });\n};\n\n// src/video/OffthreadVideo.tsx\n\n\n// src/video/OffthreadVideoForRendering.tsx\n\n\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({\n  src,\n  transparent,\n  currentTime,\n  toneMapped\n}) => {\n  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n\n// src/video/OffthreadVideoForRendering.tsx\n\nvar OffthreadVideoForRendering = ({\n  onError,\n  volume: volumeProp,\n  playbackRate,\n  src,\n  muted,\n  allowAmplificationDuringRender,\n  transparent,\n  toneMapped,\n  toneFrequency,\n  name,\n  loopVolumeCurveBehavior,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  onVideoFrame,\n  crossOrigin,\n  audioStreamIndex,\n  ...props2\n}) => {\n  const absoluteFrame = useTimelinePosition();\n  const frame = useCurrentFrame();\n  const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior);\n  const videoConfig = useUnsafeVideoConfig();\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const mediaStartsAt = useMediaStartsAt();\n  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n  if (!src) {\n    throw new TypeError(\"No `src` was passed to <OffthreadVideo>.\");\n  }\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `offthreadvideo-${random(src)}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n    src,\n    sequenceContext?.cumulatedFrom,\n    sequenceContext?.relativeFrom,\n    sequenceContext?.durationInFrames\n  ]);\n  if (!videoConfig) {\n    throw new Error(\"No video config found\");\n  }\n  const volume = evaluateVolume({\n    volume: volumeProp,\n    frame: volumePropsFrame,\n    mediaVolume: 1\n  });\n  warnAboutTooHighVolume(volume);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!src) {\n      throw new Error(\"No src passed\");\n    }\n    if (!window.remotion_audioEnabled) {\n      return;\n    }\n    if (muted) {\n      return;\n    }\n    if (volume <= 0) {\n      return;\n    }\n    registerRenderAsset({\n      type: \"video\",\n      src: getAbsoluteSrc(src),\n      id,\n      frame: absoluteFrame,\n      volume,\n      mediaFrame: frame,\n      playbackRate,\n      toneFrequency,\n      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n      audioStreamIndex\n    });\n    return () => unregisterRenderAsset(id);\n  }, [\n    muted,\n    src,\n    registerRenderAsset,\n    id,\n    unregisterRenderAsset,\n    volume,\n    frame,\n    absoluteFrame,\n    playbackRate,\n    toneFrequency,\n    sequenceContext?.relativeFrom,\n    audioStreamIndex\n  ]);\n  const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return getExpectedMediaFrameUncorrected({\n      frame,\n      playbackRate: playbackRate || 1,\n      startFrom: -mediaStartsAt\n    }) / videoConfig.fps;\n  }, [frame, mediaStartsAt, playbackRate, videoConfig.fps]);\n  const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return getOffthreadVideoSource({\n      src,\n      currentTime,\n      transparent,\n      toneMapped\n    });\n  }, [toneMapped, currentTime, src, transparent]);\n  const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!window.remotion_videoEnabled) {\n      return;\n    }\n    const cleanup = [];\n    setImageSrc(null);\n    const controller = new AbortController;\n    const newHandle = delayRender2(`Fetching ${actualSrc} from server`, {\n      retries: delayRenderRetries ?? undefined,\n      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n    });\n    const execute = async () => {\n      try {\n        const res = await fetch(actualSrc, {\n          signal: controller.signal,\n          cache: \"no-store\"\n        });\n        if (res.status !== 200) {\n          if (res.status === 500) {\n            const json = await res.json();\n            if (json.error) {\n              const cleanedUpErrorMessage = json.error.replace(/^Error: /, \"\");\n              throw new Error(cleanedUpErrorMessage);\n            }\n          }\n          throw new Error(`Server returned status ${res.status} while fetching ${actualSrc}`);\n        }\n        const blob = await res.blob();\n        const url = URL.createObjectURL(blob);\n        cleanup.push(() => URL.revokeObjectURL(url));\n        setImageSrc({\n          src: url,\n          handle: newHandle\n        });\n      } catch (err) {\n        if (err.message.includes(\"aborted\")) {\n          continueRender2(newHandle);\n          return;\n        }\n        if (controller.signal.aborted) {\n          continueRender2(newHandle);\n          return;\n        }\n        if (err.message.includes(\"Failed to fetch\")) {\n          err = new Error(`Failed to fetch ${actualSrc}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, { cause: err });\n        }\n        if (onError) {\n          onError(err);\n        } else {\n          cancelRender(err);\n        }\n      }\n    };\n    execute();\n    cleanup.push(() => {\n      if (controller.signal.aborted) {\n        return;\n      }\n      controller.abort();\n    });\n    return () => {\n      cleanup.forEach((c2) => c2());\n    };\n  }, [\n    actualSrc,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    onError,\n    continueRender2,\n    delayRender2\n  ]);\n  const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (onError) {\n      onError?.(new Error(\"Failed to load image with src \" + imageSrc));\n    } else {\n      cancelRender(\"Failed to load image with src \" + imageSrc);\n    }\n  }, [imageSrc, onError]);\n  const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [OBJECTFIT_CONTAIN_CLASS_NAME, props2.className].filter(truthy).join(\" \");\n  }, [props2.className]);\n  const onImageFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((img) => {\n    if (onVideoFrame) {\n      onVideoFrame(img);\n    }\n  }, [onVideoFrame]);\n  if (!imageSrc || !window.remotion_videoEnabled) {\n    return null;\n  }\n  continueRender2(imageSrc.handle);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, {\n    src: imageSrc.src,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    onImageFrame,\n    ...props2,\n    onError: onErr,\n    className\n  });\n};\n\n// src/video/VideoForPreview.tsx\n\n\n// src/video/emit-video-frame.ts\n\nvar useEmitVideoFrame = ({\n  ref,\n  onVideoFrame\n}) => {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = ref;\n    if (!current) {\n      return;\n    }\n    if (!onVideoFrame) {\n      return;\n    }\n    let handle = 0;\n    const callback = () => {\n      if (!ref.current) {\n        return;\n      }\n      onVideoFrame(ref.current);\n      handle = ref.current.requestVideoFrameCallback(callback);\n    };\n    callback();\n    return () => {\n      current.cancelVideoFrameCallback(handle);\n    };\n  }, [onVideoFrame, ref]);\n};\n\n// src/video/VideoForPreview.tsx\n\nvar VideoForDevelopmentRefForwardingFunction = (props2, ref) => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  if (!context) {\n    throw new Error(\"SharedAudioContext not found\");\n  }\n  const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const sharedSource = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!context.audioContext) {\n      return null;\n    }\n    return makeSharedElementSourceNode({\n      audioContext: context.audioContext,\n      ref: videoRef\n    });\n  }, [context.audioContext]);\n  const {\n    volume,\n    muted,\n    playbackRate,\n    onlyWarnForMediaSeekingError,\n    src,\n    onDuration,\n    acceptableTimeShift,\n    acceptableTimeShiftInSeconds,\n    toneFrequency,\n    name,\n    _remotionInternalNativeLoopPassed,\n    _remotionInternalStack,\n    style,\n    pauseWhenBuffering,\n    showInTimeline,\n    loopVolumeCurveBehavior,\n    onError,\n    onAutoPlayError,\n    onVideoFrame,\n    crossOrigin,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    allowAmplificationDuringRender,\n    useWebAudioApi,\n    audioStreamIndex,\n    ...nativeProps\n  } = props2;\n  const _propsValid = true;\n  if (!_propsValid) {\n    throw new Error(\"typecheck error\");\n  }\n  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n  const { fps, durationInFrames } = useVideoConfig();\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n  const logLevel = useLogLevel();\n  const mountTime = useMountTime();\n  const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));\n  const isSequenceHidden = hidden[timelineId] ?? false;\n  if (typeof acceptableTimeShift !== \"undefined\") {\n    throw new Error(\"acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.\");\n  }\n  const [mediaVolume] = useMediaVolumeState();\n  const [mediaMuted] = useMediaMutedState();\n  const userPreferredVolume = evaluateVolume({\n    frame: volumePropFrame,\n    volume,\n    mediaVolume\n  });\n  warnAboutTooHighVolume(userPreferredVolume);\n  useMediaInTimeline({\n    volume,\n    mediaVolume,\n    mediaType: \"video\",\n    src,\n    playbackRate: props2.playbackRate ?? 1,\n    displayName: name ?? null,\n    id: timelineId,\n    stack: _remotionInternalStack,\n    showInTimeline,\n    premountDisplay: parentSequence?.premountDisplay ?? null,\n    postmountDisplay: parentSequence?.postmountDisplay ?? null,\n    loopDisplay: undefined\n  });\n  useMediaPlayback({\n    mediaRef: videoRef,\n    src,\n    mediaType: \"video\",\n    playbackRate: props2.playbackRate ?? 1,\n    onlyWarnForMediaSeekingError,\n    acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n    isPremounting: Boolean(parentSequence?.premounting),\n    isPostmounting: Boolean(parentSequence?.postmounting),\n    pauseWhenBuffering,\n    onAutoPlayError: onAutoPlayError ?? null\n  });\n  useMediaTag({\n    id: timelineId,\n    isPostmounting: Boolean(parentSequence?.postmounting),\n    isPremounting: Boolean(parentSequence?.premounting),\n    mediaRef: videoRef,\n    mediaType: \"video\",\n    onAutoPlayError: onAutoPlayError ?? null\n  });\n  useVolume({\n    logLevel,\n    mediaRef: videoRef,\n    volume: userPreferredVolume,\n    source: sharedSource,\n    shouldUseWebAudioApi: useWebAudioApi ?? false\n  });\n  const actualFrom = parentSequence ? parentSequence.relativeFrom : 0;\n  const duration = parentSequence ? Math.min(parentSequence.durationInFrames, durationInFrames) : durationInFrames;\n  const preloadedSrc = usePreload(src);\n  const actualSrc = useAppendVideoFragment({\n    actualSrc: preloadedSrc,\n    actualFrom,\n    duration,\n    fps\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return videoRef.current;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => playbackLogging({\n    logLevel,\n    message: `Mounting video with source = ${actualSrc}, v=${VERSION}, user agent=${typeof navigator === \"undefined\" ? \"server\" : navigator.userAgent}`,\n    tag: \"video\",\n    mountTime\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = videoRef;\n    if (!current) {\n      return;\n    }\n    const errorHandler = () => {\n      if (current.error) {\n        console.error(\"Error occurred in video\", current?.error);\n        if (onError) {\n          const err = new Error(`Code ${current.error.code}: ${current.error.message}`);\n          onError(err);\n          return;\n        }\n        throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n      } else {\n        if (onError) {\n          const err = new Error(`The browser threw an error while playing the video ${src}`);\n          onError(err);\n          return;\n        }\n        throw new Error(\"The browser threw an error while playing the video\");\n      }\n    };\n    current.addEventListener(\"error\", errorHandler, { once: true });\n    return () => {\n      current.removeEventListener(\"error\", errorHandler);\n    };\n  }, [onError, src]);\n  const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n  currentOnDurationCallback.current = onDuration;\n  useEmitVideoFrame({ ref: videoRef, onVideoFrame });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = videoRef;\n    if (!current) {\n      return;\n    }\n    if (current.duration) {\n      currentOnDurationCallback.current?.(src, current.duration);\n      return;\n    }\n    const onLoadedMetadata = () => {\n      currentOnDurationCallback.current?.(src, current.duration);\n    };\n    current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n    return () => {\n      current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n    };\n  }, [src]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = videoRef;\n    if (!current) {\n      return;\n    }\n    if (isIosSafari()) {\n      current.preload = \"metadata\";\n    } else {\n      current.preload = \"auto\";\n    }\n  }, []);\n  const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...style,\n      opacity: isSequenceHidden ? 0 : style?.opacity ?? 1\n    };\n  }, [isSequenceHidden, style]);\n  const crossOriginValue = getCrossOriginValue({\n    crossOrigin,\n    requestsVideoFrame: Boolean(onVideoFrame)\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n    ref: videoRef,\n    muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n    playsInline: true,\n    src: actualSrc,\n    loop: _remotionInternalNativeLoopPassed,\n    style: actualStyle,\n    disableRemotePlayback: true,\n    crossOrigin: crossOriginValue,\n    ...nativeProps\n  });\n};\nvar VideoForPreview = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);\n\n// src/video/OffthreadVideo.tsx\n\nvar InnerOffthreadVideo = (props2) => {\n  const {\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter,\n    name,\n    pauseWhenBuffering,\n    stack,\n    showInTimeline,\n    ...otherProps\n  } = props2;\n  const environment = useRemotionEnvironment();\n  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    return;\n  }, []);\n  if (typeof props2.src !== \"string\") {\n    throw new TypeError(`The \\`<OffthreadVideo>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n  }\n  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });\n  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter\n  });\n  if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      layout: \"none\",\n      from: 0 - (trimBeforeValue ?? 0),\n      showInTimeline: false,\n      durationInFrames: trimAfterValue,\n      name,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerOffthreadVideo, {\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        ...otherProps,\n        trimAfter: undefined,\n        name: undefined,\n        showInTimeline,\n        trimBefore: undefined,\n        stack: undefined,\n        startFrom: undefined,\n        endAt: undefined\n      })\n    });\n  }\n  validateMediaProps(props2, \"Video\");\n  if (environment.isRendering) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, {\n      pauseWhenBuffering: pauseWhenBuffering ?? false,\n      ...otherProps,\n      trimAfter: undefined,\n      name: undefined,\n      showInTimeline,\n      trimBefore: undefined,\n      stack: undefined,\n      startFrom: undefined,\n      endAt: undefined\n    });\n  }\n  const {\n    transparent,\n    toneMapped,\n    onAutoPlayError,\n    onVideoFrame,\n    crossOrigin,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    ...propsForPreview\n  } = otherProps;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n    _remotionInternalStack: stack ?? null,\n    onDuration,\n    onlyWarnForMediaSeekingError: true,\n    pauseWhenBuffering: pauseWhenBuffering ?? false,\n    showInTimeline: showInTimeline ?? true,\n    onAutoPlayError: onAutoPlayError ?? undefined,\n    onVideoFrame: onVideoFrame ?? null,\n    crossOrigin,\n    ...propsForPreview,\n    _remotionInternalNativeLoopPassed: false\n  });\n};\nvar OffthreadVideo = ({\n  src,\n  acceptableTimeShiftInSeconds,\n  allowAmplificationDuringRender,\n  audioStreamIndex,\n  className,\n  crossOrigin,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  id,\n  loopVolumeCurveBehavior,\n  muted,\n  name,\n  onAutoPlayError,\n  onError,\n  onVideoFrame,\n  pauseWhenBuffering,\n  playbackRate,\n  showInTimeline,\n  style,\n  toneFrequency,\n  toneMapped,\n  transparent,\n  trimAfter,\n  trimBefore,\n  useWebAudioApi,\n  volume,\n  _remotionInternalNativeLoopPassed,\n  endAt,\n  stack,\n  startFrom,\n  imageFormat\n}) => {\n  if (imageFormat) {\n    throw new TypeError(`The \\`<OffthreadVideo>\\` tag does no longer accept \\`imageFormat\\`. Use the \\`transparent\\` prop if you want to render a transparent video.`);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerOffthreadVideo, {\n    acceptableTimeShiftInSeconds,\n    allowAmplificationDuringRender: allowAmplificationDuringRender ?? true,\n    audioStreamIndex: audioStreamIndex ?? 0,\n    className,\n    crossOrigin,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    id,\n    loopVolumeCurveBehavior: loopVolumeCurveBehavior ?? \"repeat\",\n    muted: muted ?? false,\n    name,\n    onAutoPlayError: onAutoPlayError ?? null,\n    onError,\n    onVideoFrame,\n    pauseWhenBuffering: pauseWhenBuffering ?? true,\n    playbackRate: playbackRate ?? 1,\n    toneFrequency: toneFrequency ?? 1,\n    showInTimeline: showInTimeline ?? true,\n    src,\n    stack,\n    startFrom,\n    _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n    endAt,\n    style,\n    toneMapped: toneMapped ?? true,\n    transparent: transparent ?? false,\n    trimAfter,\n    trimBefore,\n    useWebAudioApi: useWebAudioApi ?? false,\n    volume\n  });\n};\naddSequenceStackTraces(OffthreadVideo);\n\n// src/watch-static-file.ts\nvar WATCH_REMOTION_STATIC_FILES = \"remotion_staticFilesChanged\";\nvar watchStaticFile = (fileName, callback) => {\n  if (ENABLE_V5_BREAKING_CHANGES) {\n    throw new Error(\"watchStaticFile() has moved into the `@remotion/studio` package. Update your imports.\");\n  }\n  if (!getRemotionEnvironment().isStudio) {\n    console.warn(\"The watchStaticFile() API is only available while using the Remotion Studio.\");\n    return { cancel: () => {\n      return;\n    } };\n  }\n  const withoutStaticBase = fileName.startsWith(window.remotion_staticBase) ? fileName.replace(window.remotion_staticBase, \"\") : fileName;\n  const withoutLeadingSlash = withoutStaticBase.startsWith(\"/\") ? withoutStaticBase.slice(1) : withoutStaticBase;\n  let prevFileData = window.remotion_staticFiles.find((file) => file.name === withoutLeadingSlash);\n  const checkFile = (event) => {\n    const staticFiles = event.detail.files;\n    const newFileData = staticFiles.find((file) => file.name === withoutLeadingSlash);\n    if (!newFileData) {\n      if (prevFileData !== undefined) {\n        callback(null);\n      }\n      prevFileData = undefined;\n      return;\n    }\n    if (prevFileData === undefined || prevFileData.lastModified !== newFileData.lastModified) {\n      callback(newFileData);\n      prevFileData = newFileData;\n    }\n  };\n  window.addEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n  const cancel = () => {\n    return window.removeEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n  };\n  return { cancel };\n};\n\n// src/wrap-remotion-context.tsx\n\n\nfunction useRemotionContexts() {\n  const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);\n  const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);\n  const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);\n  const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);\n  const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);\n  const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);\n  const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);\n  const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);\n  const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);\n  const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);\n  const bufferManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(BufferingContextReact);\n  const logLevelContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    compositionManagerCtx,\n    timelineContext,\n    setTimelineContext,\n    sequenceContext,\n    nonceContext,\n    canUseRemotionHooksContext,\n    preloadContext,\n    resolveCompositionContext,\n    renderAssetManagerContext,\n    sequenceManagerContext,\n    bufferManagerContext,\n    logLevelContext\n  }), [\n    compositionManagerCtx,\n    nonceContext,\n    sequenceContext,\n    setTimelineContext,\n    timelineContext,\n    canUseRemotionHooksContext,\n    preloadContext,\n    resolveCompositionContext,\n    renderAssetManagerContext,\n    sequenceManagerContext,\n    bufferManagerContext,\n    logLevelContext\n  ]);\n}\nvar RemotionContextProvider = (props2) => {\n  const { children, contexts } = props2;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n    value: contexts.logLevelContext,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n      value: contexts.canUseRemotionHooksContext,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n        value: contexts.nonceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n          value: contexts.preloadContext,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n            value: contexts.compositionManagerCtx,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n              value: contexts.sequenceManagerContext,\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n                value: contexts.renderAssetManagerContext,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n                  value: contexts.resolveCompositionContext,\n                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                    value: contexts.timelineContext,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                      value: contexts.setTimelineContext,\n                      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n                        value: contexts.sequenceContext,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n                          value: contexts.bufferManagerContext,\n                          children\n                        })\n                      })\n                    })\n                  })\n                })\n              })\n            })\n          })\n        })\n      })\n    })\n  });\n};\n\n// src/internals.ts\nvar compositionSelectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar Internals = {\n  MaxMediaCacheSizeContext,\n  useUnsafeVideoConfig,\n  useFrameForVolumeProp,\n  useTimelinePosition,\n  evaluateVolume,\n  getAbsoluteSrc,\n  Timeline: exports_timeline_position_state,\n  validateMediaTrimProps,\n  validateMediaProps,\n  resolveTrimProps,\n  VideoForPreview,\n  CompositionManager,\n  CompositionSetters,\n  SequenceManager,\n  SequenceVisibilityToggleContext,\n  RemotionRootContexts,\n  CompositionManagerProvider,\n  useVideo,\n  getRoot,\n  useMediaVolumeState,\n  useMediaMutedState,\n  useMediaInTimeline,\n  useLazyComponent,\n  truthy,\n  SequenceContext,\n  useRemotionContexts,\n  RemotionContextProvider,\n  CSSUtils: exports_default_css,\n  setupEnvVariables,\n  MediaVolumeContext,\n  SetMediaVolumeContext,\n  getRemotionEnvironment,\n  SharedAudioContext,\n  SharedAudioContextProvider,\n  invalidCompositionErrorMessage,\n  calculateMediaDuration,\n  isCompositionIdValid,\n  getPreviewDomElement,\n  compositionsRef,\n  portalNode,\n  waitForRoot,\n  SetTimelineContext,\n  CanUseRemotionHooksProvider,\n  CanUseRemotionHooks,\n  PrefetchProvider,\n  DurationsContextProvider,\n  IsPlayerContextProvider,\n  useIsPlayer,\n  EditorPropsProvider,\n  EditorPropsContext,\n  usePreload,\n  NonceContext,\n  SetNonceContext,\n  resolveVideoConfig,\n  useResolvedVideoConfig,\n  resolveCompositionsRef,\n  ResolveCompositionConfigInStudio,\n  REMOTION_STUDIO_CONTAINER_ELEMENT,\n  RenderAssetManager,\n  persistCurrentFrame,\n  useTimelineSetFrame,\n  isIosSafari,\n  WATCH_REMOTION_STATIC_FILES,\n  addSequenceStackTraces,\n  useMediaStartsAt,\n  BufferingProvider,\n  BufferingContextReact,\n  enableSequenceStackTraces,\n  CurrentScaleContext,\n  PreviewSizeContext,\n  calculateScale,\n  editorPropsProviderRef,\n  PROPS_UPDATED_EXTERNALLY,\n  validateRenderAsset,\n  Log,\n  LogLevelContext,\n  useLogLevel,\n  playbackLogging,\n  timeValueRef,\n  compositionSelectorRef,\n  RemotionEnvironmentContext,\n  warnAboutTooHighVolume,\n  AudioForPreview,\n  OBJECTFIT_CONTAIN_CLASS_NAME,\n  InnerOffthreadVideo,\n  useBasicMediaInTimeline,\n  getInputPropsOverride,\n  setInputPropsOverride,\n  useVideoEnabled,\n  useAudioEnabled,\n  useIsPlayerBuffering,\n  TimelinePosition: exports_timeline_position_state,\n  DelayRenderContextType,\n  TimelineContext,\n  RenderAssetManagerProvider\n};\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n  return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n  const cachedMatchers = {\n    rgb: undefined,\n    rgba: undefined,\n    hsl: undefined,\n    hsla: undefined,\n    hex3: undefined,\n    hex4: undefined,\n    hex5: undefined,\n    hex6: undefined,\n    hex8: undefined\n  };\n  if (cachedMatchers.rgb === undefined) {\n    cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n    cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n    cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n    cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n  }\n  return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b2 = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;\n}\nfunction parse255(str) {\n  const int = Number.parseInt(str, 10);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 255) {\n    return 255;\n  }\n  return int;\n}\nfunction parse360(str) {\n  const int = Number.parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n  const num = Number.parseFloat(str);\n  if (num < 0) {\n    return 0;\n  }\n  if (num > 1) {\n    return 255;\n  }\n  return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n  const int = Number.parseFloat(str);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 100) {\n    return 1;\n  }\n  return int / 100;\n}\nvar colorNames = {\n  transparent: 0,\n  aliceblue: 4042850303,\n  antiquewhite: 4209760255,\n  aqua: 16777215,\n  aquamarine: 2147472639,\n  azure: 4043309055,\n  beige: 4126530815,\n  bisque: 4293182719,\n  black: 255,\n  blanchedalmond: 4293643775,\n  blue: 65535,\n  blueviolet: 2318131967,\n  brown: 2771004159,\n  burlywood: 3736635391,\n  burntsienna: 3934150143,\n  cadetblue: 1604231423,\n  chartreuse: 2147418367,\n  chocolate: 3530104575,\n  coral: 4286533887,\n  cornflowerblue: 1687547391,\n  cornsilk: 4294499583,\n  crimson: 3692313855,\n  cyan: 16777215,\n  darkblue: 35839,\n  darkcyan: 9145343,\n  darkgoldenrod: 3095792639,\n  darkgray: 2846468607,\n  darkgreen: 6553855,\n  darkgrey: 2846468607,\n  darkkhaki: 3182914559,\n  darkmagenta: 2332068863,\n  darkolivegreen: 1433087999,\n  darkorange: 4287365375,\n  darkorchid: 2570243327,\n  darkred: 2332033279,\n  darksalmon: 3918953215,\n  darkseagreen: 2411499519,\n  darkslateblue: 1211993087,\n  darkslategray: 793726975,\n  darkslategrey: 793726975,\n  darkturquoise: 13554175,\n  darkviolet: 2483082239,\n  deeppink: 4279538687,\n  deepskyblue: 12582911,\n  dimgray: 1768516095,\n  dimgrey: 1768516095,\n  dodgerblue: 512819199,\n  firebrick: 2988581631,\n  floralwhite: 4294635775,\n  forestgreen: 579543807,\n  fuchsia: 4278255615,\n  gainsboro: 3705462015,\n  ghostwhite: 4177068031,\n  gold: 4292280575,\n  goldenrod: 3668254975,\n  gray: 2155905279,\n  green: 8388863,\n  greenyellow: 2919182335,\n  grey: 2155905279,\n  honeydew: 4043305215,\n  hotpink: 4285117695,\n  indianred: 3445382399,\n  indigo: 1258324735,\n  ivory: 4294963455,\n  khaki: 4041641215,\n  lavender: 3873897215,\n  lavenderblush: 4293981695,\n  lawngreen: 2096890111,\n  lemonchiffon: 4294626815,\n  lightblue: 2916673279,\n  lightcoral: 4034953471,\n  lightcyan: 3774873599,\n  lightgoldenrodyellow: 4210742015,\n  lightgray: 3553874943,\n  lightgreen: 2431553791,\n  lightgrey: 3553874943,\n  lightpink: 4290167295,\n  lightsalmon: 4288707327,\n  lightseagreen: 548580095,\n  lightskyblue: 2278488831,\n  lightslategray: 2005441023,\n  lightslategrey: 2005441023,\n  lightsteelblue: 2965692159,\n  lightyellow: 4294959359,\n  lime: 16711935,\n  limegreen: 852308735,\n  linen: 4210091775,\n  magenta: 4278255615,\n  maroon: 2147483903,\n  mediumaquamarine: 1724754687,\n  mediumblue: 52735,\n  mediumorchid: 3126187007,\n  mediumpurple: 2473647103,\n  mediumseagreen: 1018393087,\n  mediumslateblue: 2070474495,\n  mediumspringgreen: 16423679,\n  mediumturquoise: 1221709055,\n  mediumvioletred: 3340076543,\n  midnightblue: 421097727,\n  mintcream: 4127193855,\n  mistyrose: 4293190143,\n  moccasin: 4293178879,\n  navajowhite: 4292783615,\n  navy: 33023,\n  oldlace: 4260751103,\n  olive: 2155872511,\n  olivedrab: 1804477439,\n  orange: 4289003775,\n  orangered: 4282712319,\n  orchid: 3664828159,\n  palegoldenrod: 4008225535,\n  palegreen: 2566625535,\n  paleturquoise: 2951671551,\n  palevioletred: 3681588223,\n  papayawhip: 4293907967,\n  peachpuff: 4292524543,\n  peru: 3448061951,\n  pink: 4290825215,\n  plum: 3718307327,\n  powderblue: 2967529215,\n  purple: 2147516671,\n  rebeccapurple: 1714657791,\n  red: 4278190335,\n  rosybrown: 3163525119,\n  royalblue: 1097458175,\n  saddlebrown: 2336560127,\n  salmon: 4202722047,\n  sandybrown: 4104413439,\n  seagreen: 780883967,\n  seashell: 4294307583,\n  sienna: 2689740287,\n  silver: 3233857791,\n  skyblue: 2278484991,\n  slateblue: 1784335871,\n  slategray: 1887473919,\n  slategrey: 1887473919,\n  snow: 4294638335,\n  springgreen: 16744447,\n  steelblue: 1182971135,\n  tan: 3535047935,\n  teal: 8421631,\n  thistle: 3636451583,\n  tomato: 4284696575,\n  turquoise: 1088475391,\n  violet: 4001558271,\n  wheat: 4125012991,\n  white: 4294967295,\n  whitesmoke: 4126537215,\n  yellow: 4294902015,\n  yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n  const matchers = getMatchers();\n  let match;\n  if (matchers.hex6) {\n    if (match = matchers.hex6.exec(color)) {\n      return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (colorNames[color] !== undefined) {\n    return colorNames[color];\n  }\n  if (matchers.rgb) {\n    if (match = matchers.rgb.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n    }\n  }\n  if (matchers.rgba) {\n    if (match = matchers.rgba.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n    }\n  }\n  if (matchers.hex3) {\n    if (match = matchers.hex3.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (matchers.hex8) {\n    if (match = matchers.hex8.exec(color)) {\n      return Number.parseInt(match[1], 16) >>> 0;\n    }\n  }\n  if (matchers.hex4) {\n    if (match = matchers.hex4.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n    }\n  }\n  if (matchers.hsl) {\n    if (match = matchers.hsl.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n    }\n  }\n  if (matchers.hsla) {\n    if (match = matchers.hsla.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n    }\n  }\n  throw new Error(`invalid color string ${color} provided`);\n}\nvar opacity = (c2) => {\n  return (c2 >> 24 & 255) / 255;\n};\nvar red = (c2) => {\n  return c2 >> 16 & 255;\n};\nvar green = (c2) => {\n  return c2 >> 8 & 255;\n};\nvar blue = (c2) => {\n  return c2 & 255;\n};\nvar rgbaColor = (r, g, b2, alpha) => {\n  return `rgba(${r}, ${g}, ${b2}, ${alpha})`;\n};\nfunction processColor(color) {\n  const normalizedColor = normalizeColor(color);\n  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar interpolateColorsRGB = (value, inputRange, colors) => {\n  const [r, g, b2, a2] = [red, green, blue, opacity].map((f) => {\n    const unrounded = interpolate(value, inputRange, colors.map((c2) => f(c2)), {\n      extrapolateLeft: \"clamp\",\n      extrapolateRight: \"clamp\"\n    });\n    if (f === opacity) {\n      return Number(unrounded.toFixed(3));\n    }\n    return Math.round(unrounded);\n  });\n  return rgbaColor(r, g, b2, a2);\n};\nvar interpolateColors = (input, inputRange, outputRange) => {\n  if (typeof input === \"undefined\") {\n    throw new TypeError(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new TypeError(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new TypeError(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new TypeError(\"inputRange (\" + inputRange.length + \" values provided) and outputRange (\" + outputRange.length + \" values provided) must have the same length\");\n  }\n  const processedOutputRange = outputRange.map((c2) => processColor(c2));\n  return interpolateColorsRGB(input, inputRange, processedOutputRange);\n};\n// src/validate-frame.ts\nvar validateFrame = ({\n  allowFloats,\n  durationInFrames,\n  frame\n}) => {\n  if (typeof frame === \"undefined\") {\n    throw new TypeError(`Argument missing for parameter \"frame\"`);\n  }\n  if (typeof frame !== \"number\") {\n    throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n  }\n  if (!Number.isFinite(frame)) {\n    throw new RangeError(`Frame ${frame} is not finite`);\n  }\n  if (frame % 1 !== 0 && !allowFloats) {\n    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n  }\n  if (frame < 0 && frame < -durationInFrames) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n  }\n  if (frame > durationInFrames - 1) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n  }\n};\n// src/series/index.tsx\n\n\n// src/series/flatten-children.tsx\n\nvar flattenChildren = (children) => {\n  const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n  return childrenArray.reduce((flatChildren, child) => {\n    if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n      return flatChildren.concat(flattenChildren(child.props.children));\n    }\n    flatChildren.push(child);\n    return flatChildren;\n  }, []);\n};\n\n// src/series/is-inside-series.tsx\n\n\nvar IsInsideSeriesContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsInsideSeriesContainer = ({ children }) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n    value: true,\n    children\n  });\n};\nvar IsNotInsideSeriesProvider = ({ children }) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n    value: false,\n    children\n  });\n};\nvar useRequireToBeInsideSeries = () => {\n  const isInsideSeries = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsInsideSeriesContext);\n  if (!isInsideSeries) {\n    throw new Error(\"This component must be inside a <Series /> component.\");\n  }\n};\n\n// src/series/index.tsx\n\nvar SeriesSequenceRefForwardingFunction = ({ children }, _ref) => {\n  useRequireToBeInsideSeries();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsNotInsideSeriesProvider, {\n    children\n  });\n};\nvar SeriesSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);\nvar Series = (props2) => {\n  const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let startFrame = 0;\n    const flattenedChildren = flattenChildren(props2.children);\n    return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, (child, i) => {\n      const castedChild = child;\n      if (typeof castedChild === \"string\") {\n        if (castedChild.trim() === \"\") {\n          return null;\n        }\n        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but you passed a string \"${castedChild}\"`);\n      }\n      if (castedChild.type !== SeriesSequence) {\n        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but got ${castedChild} instead`);\n      }\n      const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;\n      if (!castedChild?.props.children) {\n        throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);\n      }\n      const durationInFramesProp = castedChild.props.durationInFrames;\n      const {\n        durationInFrames,\n        children: _children,\n        from,\n        name,\n        ...passedProps\n      } = castedChild.props;\n      if (i !== flattenedChildren.length - 1 || durationInFramesProp !== Infinity) {\n        validateDurationInFrames(durationInFramesProp, {\n          component: `of a <Series.Sequence /> component`,\n          allowFloats: true\n        });\n      }\n      const offset = castedChild.props.offset ?? 0;\n      if (Number.isNaN(offset)) {\n        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);\n      }\n      if (!Number.isFinite(offset)) {\n        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n      }\n      if (offset % 1 !== 0) {\n        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n      }\n      const currentStartFrame = startFrame + offset;\n      startFrame += durationInFramesProp + offset;\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n        name: name || \"<Series.Sequence>\",\n        from: currentStartFrame,\n        durationInFrames: durationInFramesProp,\n        ...passedProps,\n        ref: castedChild.ref,\n        children: child\n      });\n    });\n  }, [props2.children]);\n  if (ENABLE_V5_BREAKING_CHANGES) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n        ...props2,\n        children: childrenValue\n      })\n    });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n    children: childrenValue\n  });\n};\nSeries.Sequence = SeriesSequence;\naddSequenceStackTraces(SeriesSequence);\n// src/validation/validation-spring-duration.ts\nvar validateSpringDuration = (dur) => {\n  if (typeof dur === \"undefined\") {\n    return;\n  }\n  if (typeof dur !== \"number\") {\n    throw new TypeError(`A \"duration\" of a spring must be a \"number\" but is \"${typeof dur}\"`);\n  }\n  if (Number.isNaN(dur)) {\n    throw new TypeError('A \"duration\" of a spring is NaN, which it must not be');\n  }\n  if (!Number.isFinite(dur)) {\n    throw new TypeError('A \"duration\" of a spring must be finite, but is ' + dur);\n  }\n  if (dur <= 0) {\n    throw new TypeError('A \"duration\" of a spring must be positive, but is ' + dur);\n  }\n};\n\n// src/spring/spring-utils.ts\nvar defaultSpringConfig = {\n  damping: 10,\n  mass: 1,\n  stiffness: 100,\n  overshootClamping: false\n};\nvar advanceCache = {};\nfunction advance({\n  animation,\n  now,\n  config\n}) {\n  const { toValue, lastTimestamp, current, velocity } = animation;\n  const deltaTime = Math.min(now - lastTimestamp, 64);\n  if (config.damping <= 0) {\n    throw new Error(\"Spring damping must be greater than 0, otherwise the spring() animation will never end, causing an infinite loop.\");\n  }\n  const c2 = config.damping;\n  const m = config.mass;\n  const k = config.stiffness;\n  const cacheKey = [\n    toValue,\n    lastTimestamp,\n    current,\n    velocity,\n    c2,\n    m,\n    k,\n    now\n  ].join(\"-\");\n  if (advanceCache[cacheKey]) {\n    return advanceCache[cacheKey];\n  }\n  const v0 = -velocity;\n  const x0 = toValue - current;\n  const zeta = c2 / (2 * Math.sqrt(k * m));\n  const omega0 = Math.sqrt(k / m);\n  const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n  const t = deltaTime / 1000;\n  const sin1 = Math.sin(omega1 * t);\n  const cos1 = Math.cos(omega1 * t);\n  const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n  const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n  const underDampedPosition = toValue - underDampedFrag1;\n  const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n  const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n  const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n  const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n  const animationNode = {\n    toValue,\n    prevPosition: current,\n    lastTimestamp: now,\n    current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,\n    velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity\n  };\n  advanceCache[cacheKey] = animationNode;\n  return animationNode;\n}\nvar calculationCache = {};\nfunction springCalculation({\n  frame,\n  fps,\n  config = {}\n}) {\n  const from = 0;\n  const to = 1;\n  const cacheKey = [\n    frame,\n    fps,\n    config.damping,\n    config.mass,\n    config.overshootClamping,\n    config.stiffness\n  ].join(\"-\");\n  if (calculationCache[cacheKey]) {\n    return calculationCache[cacheKey];\n  }\n  let animation = {\n    lastTimestamp: 0,\n    current: from,\n    toValue: to,\n    velocity: 0,\n    prevPosition: 0\n  };\n  const frameClamped = Math.max(0, frame);\n  const unevenRest = frameClamped % 1;\n  for (let f = 0;f <= Math.floor(frameClamped); f++) {\n    if (f === Math.floor(frameClamped)) {\n      f += unevenRest;\n    }\n    const time = f / fps * 1000;\n    animation = advance({\n      animation,\n      now: time,\n      config: {\n        ...defaultSpringConfig,\n        ...config\n      }\n    });\n  }\n  calculationCache[cacheKey] = animation;\n  return animation;\n}\n\n// src/spring/measure-spring.ts\nvar cache = new Map;\nfunction measureSpring({\n  fps,\n  config = {},\n  threshold = 0.005\n}) {\n  if (typeof threshold !== \"number\") {\n    throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);\n  }\n  if (threshold === 0) {\n    return Infinity;\n  }\n  if (threshold === 1) {\n    return 0;\n  }\n  if (isNaN(threshold)) {\n    throw new TypeError(\"Threshold is NaN\");\n  }\n  if (!Number.isFinite(threshold)) {\n    throw new TypeError(\"Threshold is not finite\");\n  }\n  if (threshold < 0) {\n    throw new TypeError(\"Threshold is below 0\");\n  }\n  const cacheKey = [\n    fps,\n    config.damping,\n    config.mass,\n    config.overshootClamping,\n    config.stiffness,\n    threshold\n  ].join(\"-\");\n  if (cache.has(cacheKey)) {\n    return cache.get(cacheKey);\n  }\n  validateFps(fps, \"to the measureSpring() function\", false);\n  let frame = 0;\n  let finishedFrame = 0;\n  const calc = () => {\n    return springCalculation({\n      fps,\n      frame,\n      config\n    });\n  };\n  let animation = calc();\n  const calcDifference = () => {\n    return Math.abs(animation.current - animation.toValue);\n  };\n  let difference = calcDifference();\n  while (difference >= threshold) {\n    frame++;\n    animation = calc();\n    difference = calcDifference();\n  }\n  finishedFrame = frame;\n  for (let i = 0;i < 20; i++) {\n    frame++;\n    animation = calc();\n    difference = calcDifference();\n    if (difference >= threshold) {\n      i = 0;\n      finishedFrame = frame + 1;\n    }\n  }\n  cache.set(cacheKey, finishedFrame);\n  return finishedFrame;\n}\n\n// src/spring/index.ts\nfunction spring({\n  frame: passedFrame,\n  fps,\n  config = {},\n  from = 0,\n  to = 1,\n  durationInFrames: passedDurationInFrames,\n  durationRestThreshold,\n  delay = 0,\n  reverse = false\n}) {\n  validateSpringDuration(passedDurationInFrames);\n  validateFrame({\n    frame: passedFrame,\n    durationInFrames: Infinity,\n    allowFloats: true\n  });\n  validateFps(fps, \"to spring()\", false);\n  const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== \"undefined\";\n  const naturalDuration = needsToCalculateNaturalDuration ? measureSpring({\n    fps,\n    config,\n    threshold: durationRestThreshold\n  }) : undefined;\n  const naturalDurationGetter = needsToCalculateNaturalDuration ? {\n    get: () => naturalDuration\n  } : {\n    get: () => {\n      throw new Error(\"did not calculate natural duration, this is an error with Remotion. Please report\");\n    }\n  };\n  const reverseProcessed = reverse ? (passedDurationInFrames ?? naturalDurationGetter.get()) - passedFrame : passedFrame;\n  const delayProcessed = reverseProcessed + (reverse ? delay : -delay);\n  const durationProcessed = passedDurationInFrames === undefined ? delayProcessed : delayProcessed / (passedDurationInFrames / naturalDurationGetter.get());\n  if (passedDurationInFrames && delayProcessed > passedDurationInFrames) {\n    return to;\n  }\n  const spr = springCalculation({\n    fps,\n    frame: durationProcessed,\n    config\n  });\n  const inner = config.overshootClamping ? to >= from ? Math.min(spr.current, to) : Math.max(spr.current, to) : spr.current;\n  const interpolated = from === 0 && to === 1 ? inner : interpolate(inner, [0, 1], [from, to]);\n  return interpolated;\n}\n// src/static-file.ts\nvar problematicCharacters = {\n  \"%3A\": \":\",\n  \"%2F\": \"/\",\n  \"%3F\": \"?\",\n  \"%23\": \"#\",\n  \"%5B\": \"[\",\n  \"%5D\": \"]\",\n  \"%40\": \"@\",\n  \"%21\": \"!\",\n  \"%24\": \"$\",\n  \"%26\": \"&\",\n  \"%27\": \"'\",\n  \"%28\": \"(\",\n  \"%29\": \")\",\n  \"%2A\": \"*\",\n  \"%2B\": \"+\",\n  \"%2C\": \",\",\n  \"%3B\": \";\"\n};\nvar didWarn2 = {};\nvar warnOnce3 = (message) => {\n  if (didWarn2[message]) {\n    return;\n  }\n  console.warn(message);\n  didWarn2[message] = true;\n};\nvar includesHexOfUnsafeChar = (path) => {\n  for (const key of Object.keys(problematicCharacters)) {\n    if (path.includes(key)) {\n      return { containsHex: true, hexCode: key };\n    }\n  }\n  return { containsHex: false };\n};\nvar trimLeadingSlash = (path) => {\n  if (path.startsWith(\"/\")) {\n    return trimLeadingSlash(path.substring(1));\n  }\n  return path;\n};\nvar inner = (path) => {\n  if (typeof window !== \"undefined\" && window.remotion_staticBase) {\n    if (path.startsWith(window.remotion_staticBase)) {\n      throw new Error(`The value \"${path}\" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);\n    }\n    return `${window.remotion_staticBase}/${trimLeadingSlash(path)}`;\n  }\n  return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path) => {\n  const splitBySlash = path.split(\"/\");\n  const encodedArray = splitBySlash.map((element) => {\n    return encodeURIComponent(element);\n  });\n  const merged = encodedArray.join(\"/\");\n  return merged;\n};\nvar staticFile = (path) => {\n  if (path === null) {\n    throw new TypeError(\"null was passed to staticFile()\");\n  }\n  if (typeof path === \"undefined\") {\n    throw new TypeError(\"undefined was passed to staticFile()\");\n  }\n  if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n    throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n  }\n  if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n    throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n    throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  if (path.startsWith(\"public/\")) {\n    throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  const includesHex = includesHexOfUnsafeChar(path);\n  if (includesHex.containsHex) {\n    warnOnce3(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n  }\n  const preprocessed = encodeBySplitting(path);\n  const preparsed = inner(preprocessed);\n  if (!preparsed.startsWith(\"/\")) {\n    return `/${preparsed}`;\n  }\n  return preparsed;\n};\n// src/Still.tsx\n\nvar Still = (props2) => {\n  const newProps = {\n    ...props2,\n    durationInFrames: 1,\n    fps: 1\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Composition, newProps);\n};\n// src/video/Video.tsx\n\n\n// src/video/VideoForRendering.tsx\n\n\n// src/video/seek-until-right.ts\nvar roundTo6Commas = (num) => {\n  return Math.round(num * 1e5) / 1e5;\n};\nvar seekToTime = ({\n  element,\n  desiredTime,\n  logLevel,\n  mountTime\n}) => {\n  if (isApproximatelyTheSame(element.currentTime, desiredTime)) {\n    return {\n      wait: Promise.resolve(desiredTime),\n      cancel: () => {}\n    };\n  }\n  seek({\n    logLevel,\n    mediaRef: element,\n    time: desiredTime,\n    why: \"Seeking during rendering\",\n    mountTime\n  });\n  let cancel;\n  let cancelSeeked = null;\n  const prom = new Promise((resolve) => {\n    cancel = element.requestVideoFrameCallback((now, metadata) => {\n      const displayIn = metadata.expectedDisplayTime - now;\n      if (displayIn <= 0) {\n        resolve(metadata.mediaTime);\n        return;\n      }\n      setTimeout(() => {\n        resolve(metadata.mediaTime);\n      }, displayIn + 150);\n    });\n  });\n  const waitForSeekedEvent = new Promise((resolve) => {\n    const onDone = () => {\n      resolve();\n    };\n    element.addEventListener(\"seeked\", onDone, {\n      once: true\n    });\n    cancelSeeked = () => {\n      element.removeEventListener(\"seeked\", onDone);\n    };\n  });\n  return {\n    wait: Promise.all([prom, waitForSeekedEvent]).then(([time]) => time),\n    cancel: () => {\n      cancelSeeked?.();\n      element.cancelVideoFrameCallback(cancel);\n    }\n  };\n};\nvar seekToTimeMultipleUntilRight = ({\n  element,\n  desiredTime,\n  fps,\n  logLevel,\n  mountTime\n}) => {\n  const threshold = 1 / fps / 2;\n  let currentCancel = () => {\n    return;\n  };\n  if (Number.isFinite(element.duration) && element.currentTime >= element.duration && desiredTime >= element.duration) {\n    return {\n      prom: Promise.resolve(),\n      cancel: () => {}\n    };\n  }\n  const prom = new Promise((resolve, reject) => {\n    const firstSeek = seekToTime({\n      element,\n      desiredTime: desiredTime + threshold,\n      logLevel,\n      mountTime\n    });\n    firstSeek.wait.then((seekedTo) => {\n      const difference = Math.abs(desiredTime - seekedTo);\n      if (difference <= threshold) {\n        return resolve();\n      }\n      const sign = desiredTime > seekedTo ? 1 : -1;\n      const newSeek = seekToTime({\n        element,\n        desiredTime: seekedTo + threshold * sign,\n        logLevel,\n        mountTime\n      });\n      currentCancel = newSeek.cancel;\n      newSeek.wait.then((newTime) => {\n        const newDifference = Math.abs(desiredTime - newTime);\n        if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {\n          return resolve();\n        }\n        const thirdSeek = seekToTime({\n          element,\n          desiredTime: desiredTime + threshold,\n          logLevel,\n          mountTime\n        });\n        currentCancel = thirdSeek.cancel;\n        return thirdSeek.wait.then(() => {\n          resolve();\n        }).catch((err) => {\n          reject(err);\n        });\n      }).catch((err) => {\n        reject(err);\n      });\n    });\n    currentCancel = firstSeek.cancel;\n  });\n  return {\n    prom,\n    cancel: () => {\n      currentCancel();\n    }\n  };\n};\n\n// src/video/VideoForRendering.tsx\n\nvar VideoForRenderingForwardFunction = ({\n  onError,\n  volume: volumeProp,\n  allowAmplificationDuringRender,\n  playbackRate,\n  onDuration,\n  toneFrequency,\n  name,\n  acceptableTimeShiftInSeconds,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  loopVolumeCurveBehavior,\n  audioStreamIndex,\n  onVideoFrame,\n  ...props2\n}, ref) => {\n  const absoluteFrame = useTimelinePosition();\n  const frame = useCurrentFrame();\n  const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n  const videoConfig = useUnsafeVideoConfig();\n  const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const mediaStartsAt = useMediaStartsAt();\n  const environment = useRemotionEnvironment();\n  const logLevel = useLogLevel();\n  const mountTime = useMountTime();\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `video-${random(props2.src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n    props2.src,\n    sequenceContext?.cumulatedFrom,\n    sequenceContext?.relativeFrom,\n    sequenceContext?.durationInFrames\n  ]);\n  if (!videoConfig) {\n    throw new Error(\"No video config found\");\n  }\n  const volume = evaluateVolume({\n    volume: volumeProp,\n    frame: volumePropsFrame,\n    mediaVolume: 1\n  });\n  warnAboutTooHighVolume(volume);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!props2.src) {\n      throw new Error(\"No src passed\");\n    }\n    if (props2.muted) {\n      return;\n    }\n    if (volume <= 0) {\n      return;\n    }\n    if (!window.remotion_audioEnabled) {\n      return;\n    }\n    registerRenderAsset({\n      type: \"video\",\n      src: getAbsoluteSrc(props2.src),\n      id,\n      frame: absoluteFrame,\n      volume,\n      mediaFrame: frame,\n      playbackRate: playbackRate ?? 1,\n      toneFrequency: toneFrequency ?? 1,\n      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n      audioStreamIndex: audioStreamIndex ?? 0\n    });\n    return () => unregisterRenderAsset(id);\n  }, [\n    props2.muted,\n    props2.src,\n    registerRenderAsset,\n    id,\n    unregisterRenderAsset,\n    volume,\n    frame,\n    absoluteFrame,\n    playbackRate,\n    toneFrequency,\n    sequenceContext?.relativeFrom,\n    audioStreamIndex\n  ]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return videoRef.current;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!window.remotion_videoEnabled) {\n      return;\n    }\n    const { current } = videoRef;\n    if (!current) {\n      return;\n    }\n    const currentTime = getMediaTime({\n      frame,\n      playbackRate: playbackRate || 1,\n      startFrom: -mediaStartsAt,\n      fps: videoConfig.fps\n    });\n    const handle = delayRender2(`Rendering <Html5Video /> with src=\"${props2.src}\" at time ${currentTime}`, {\n      retries: delayRenderRetries ?? undefined,\n      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n    });\n    if (window.process?.env?.NODE_ENV === \"test\") {\n      continueRender2(handle);\n      return;\n    }\n    if (isApproximatelyTheSame(current.currentTime, currentTime)) {\n      if (current.readyState >= 2) {\n        continueRender2(handle);\n        return;\n      }\n      const loadedDataHandler = () => {\n        continueRender2(handle);\n      };\n      current.addEventListener(\"loadeddata\", loadedDataHandler, { once: true });\n      return () => {\n        current.removeEventListener(\"loadeddata\", loadedDataHandler);\n      };\n    }\n    const endedHandler = () => {\n      continueRender2(handle);\n    };\n    const seek2 = seekToTimeMultipleUntilRight({\n      element: current,\n      desiredTime: currentTime,\n      fps: videoConfig.fps,\n      logLevel,\n      mountTime\n    });\n    seek2.prom.then(() => {\n      continueRender2(handle);\n    });\n    current.addEventListener(\"ended\", endedHandler, { once: true });\n    const errorHandler = () => {\n      if (current?.error) {\n        console.error(\"Error occurred in video\", current?.error);\n        if (onError) {\n          return;\n        }\n        throw new Error(`The browser threw an error while playing the video ${props2.src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n      } else {\n        throw new Error(\"The browser threw an error\");\n      }\n    };\n    current.addEventListener(\"error\", errorHandler, { once: true });\n    return () => {\n      seek2.cancel();\n      current.removeEventListener(\"ended\", endedHandler);\n      current.removeEventListener(\"error\", errorHandler);\n      continueRender2(handle);\n    };\n  }, [\n    volumePropsFrame,\n    props2.src,\n    playbackRate,\n    videoConfig.fps,\n    frame,\n    mediaStartsAt,\n    onError,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    logLevel,\n    mountTime,\n    continueRender2,\n    delayRender2\n  ]);\n  const { src } = props2;\n  if (environment.isRendering) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      if (window.process?.env?.NODE_ENV === \"test\") {\n        return;\n      }\n      const newHandle = delayRender2(\"Loading <Html5Video> duration with src=\" + src, {\n        retries: delayRenderRetries ?? undefined,\n        timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n      });\n      const { current } = videoRef;\n      const didLoad = () => {\n        if (current?.duration) {\n          onDuration(src, current.duration);\n        }\n        continueRender2(newHandle);\n      };\n      if (current?.duration) {\n        onDuration(src, current.duration);\n        continueRender2(newHandle);\n      } else {\n        current?.addEventListener(\"loadedmetadata\", didLoad, { once: true });\n      }\n      return () => {\n        current?.removeEventListener(\"loadedmetadata\", didLoad);\n        continueRender2(newHandle);\n      };\n    }, [\n      src,\n      onDuration,\n      delayRenderRetries,\n      delayRenderTimeoutInMilliseconds,\n      continueRender2,\n      delayRender2\n    ]);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n    ref: videoRef,\n    disableRemotePlayback: true,\n    ...props2\n  });\n};\nvar VideoForRendering = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);\n\n// src/video/Video.tsx\n\nvar VideoForwardingFunction = (props2, ref) => {\n  const {\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter,\n    name,\n    pauseWhenBuffering,\n    stack,\n    _remotionInternalNativeLoopPassed,\n    showInTimeline,\n    onAutoPlayError,\n    ...otherProps\n  } = props2;\n  const { loop, ...propsOtherThanLoop } = props2;\n  const { fps } = useVideoConfig();\n  const environment = useRemotionEnvironment();\n  const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n  if (typeof ref === \"string\") {\n    throw new Error(\"string refs are not supported\");\n  }\n  if (typeof props2.src !== \"string\") {\n    throw new TypeError(`The \\`<Html5Video>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n  }\n  const preloadedSrc = usePreload(props2.src);\n  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds) => {\n    setDurations({ type: \"got-duration\", durationInSeconds, src });\n  }, [setDurations]);\n  const onVideoFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {}, []);\n  const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props2.src)];\n  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });\n  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter\n  });\n  if (loop && durationFetched !== undefined) {\n    if (!Number.isFinite(durationFetched)) {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {\n        ...propsOtherThanLoop,\n        ref,\n        _remotionInternalNativeLoopPassed: true\n      });\n    }\n    const mediaDuration = durationFetched * fps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n      durationInFrames: calculateMediaDuration({\n        trimAfter: trimAfterValue,\n        mediaDurationInFrames: mediaDuration,\n        playbackRate: props2.playbackRate ?? 1,\n        trimBefore: trimBeforeValue\n      }),\n      layout: \"none\",\n      name,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {\n        ...propsOtherThanLoop,\n        ref,\n        _remotionInternalNativeLoopPassed: true\n      })\n    });\n  }\n  if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      layout: \"none\",\n      from: 0 - (trimBeforeValue ?? 0),\n      showInTimeline: false,\n      durationInFrames: trimAfterValue,\n      name,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        ...otherProps,\n        ref\n      })\n    });\n  }\n  validateMediaProps({ playbackRate: props2.playbackRate, volume: props2.volume }, \"Html5Video\");\n  if (environment.isRendering) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, {\n      onDuration,\n      onVideoFrame: onVideoFrame ?? null,\n      ...otherProps,\n      ref\n    });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n    onlyWarnForMediaSeekingError: false,\n    ...otherProps,\n    ref,\n    onVideoFrame: null,\n    pauseWhenBuffering: pauseWhenBuffering ?? false,\n    onDuration,\n    _remotionInternalStack: stack ?? null,\n    _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n    showInTimeline: showInTimeline ?? true,\n    onAutoPlayError: onAutoPlayError ?? undefined\n  });\n};\nvar Html5Video = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForwardingFunction);\naddSequenceStackTraces(Html5Video);\nvar Video = Html5Video;\n// src/index.ts\ncheckMultipleRemotionVersions();\nvar Experimental = {\n  Clipper,\n  Null,\n  useIsPlayer\n};\nvar proxyObj = {};\nvar Config = new Proxy(proxyObj, {\n  get(_, prop) {\n    if (prop === \"Bundling\" || prop === \"Rendering\" || prop === \"Log\" || prop === \"Puppeteer\" || prop === \"Output\") {\n      return Config;\n    }\n    return () => {\n      console.warn(\"  The CLI configuration has been extracted from Remotion Core.\");\n      console.warn(\"Update the import from the config file:\");\n      console.warn();\n      console.warn(\"- Delete:\");\n      console.warn('import {Config} from \"remotion\";');\n      console.warn(\"+ Replace:\");\n      console.warn('import {Config} from \"@remotion/cli/config\";');\n      console.warn();\n      console.warn(\"For more information, see https://www.remotion.dev/docs/4-0-migration.\");\n      process.exit(1);\n    };\n  }\n});\naddSequenceStackTraces(Sequence);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNzQztBQUN0QyxXQUFXLGdEQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQixnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixlQUFlLGlCQUFpQixnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEI7QUFDaUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZ0RBQW1CO0FBQy9DLGtCQUFrQixrREFBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQW1CO0FBQ3JCLEVBQUUsa0RBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvRTtBQUM1QjtBQUN4QyxzQkFBc0Isb0RBQWM7QUFDcEM7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUIsc0RBQUc7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1FQUFtRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUM1RSwwQ0FBMEMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUM1RiwwQ0FBMEMsRUFBRTtBQUM1QywwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyREFBMkQsV0FBVyxVQUFVLGlCQUFpQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLLDZDQUE2QywyQkFBMkI7QUFDakg7QUFDQSxjQUFjLDJCQUEyQixHQUFHLHVCQUF1QjtBQUNuRTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxLQUFLO0FBQ2pGO0FBQ0E7QUFDQSwrRUFBK0UsS0FBSztBQUNwRjtBQUNBO0FBQ0EsK0VBQStFLEtBQUs7QUFDcEY7QUFDQTtBQUNBLDRGQUE0RixLQUFLO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixvQkFBb0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnREFBcUI7QUFDOUI7QUFDQTtBQUM2Rzs7QUFFN0c7QUFTZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBUTtBQUMzQiwwQkFBMEIsaURBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7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Z0NBQWdDLHNEQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQixzREFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSx1QkFBdUIsMERBQTBEO0FBQ2pGO0FBQ0EsMkJBQTJCLHNEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLHNEQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLGlEQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxnQkFBZ0I7QUFDcEQ7QUFDQSw0QkFBNEIsUUFBUSw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQThDRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcHRpb24tZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vaW5kZXgubWpzPzVkMmYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7XG4gICAgICBnZXQ6IGFsbFtuYW1lXSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IChuZXdWYWx1ZSkgPT4gYWxsW25hbWVdID0gKCkgPT4gbmV3VmFsdWVcbiAgICB9KTtcbn07XG5cbi8vIHNyYy9fY2hlY2stcnNjLnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pZiAodHlwZW9mIGNyZWF0ZUNvbnRleHQgIT09IFwiZnVuY3Rpb25cIikge1xuICBjb25zdCBlcnIgPSBbXG4gICAgJ1JlbW90aW9uIHJlcXVpcmVzIFJlYWN0LmNyZWF0ZUNvbnRleHQsIGJ1dCBpdCBpcyBcInVuZGVmaW5lZFwiLicsXG4gICAgJ0lmIHlvdSBhcmUgaW4gYSBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50LCB0dXJuIGl0IGludG8gYSBjbGllbnQgY29tcG9uZW50IGJ5IGFkZGluZyBcInVzZSBjbGllbnRcIiBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlLicsXG4gICAgXCJcIixcbiAgICBcIkJlZm9yZTpcIixcbiAgICAnICBpbXBvcnQge3VzZUN1cnJlbnRGcmFtZX0gZnJvbSBcInJlbW90aW9uXCI7JyxcbiAgICBcIlwiLFxuICAgIFwiQWZ0ZXI6XCIsXG4gICAgJyAgXCJ1c2UgY2xpZW50XCI7JyxcbiAgICAnICBpbXBvcnQge3VzZUN1cnJlbnRGcmFtZX0gZnJvbSBcInJlbW90aW9uXCI7J1xuICBdO1xuICB0aHJvdyBuZXcgRXJyb3IoZXJyLmpvaW4oYFxuYCkpO1xufVxuXG4vLyBzcmMvQ2xpcHBlci50c3hcbnZhciBDbGlwcGVyID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCI8Q2xpcHBlcj4gaGFzIGJlZW4gcmVtb3ZlZCBhcyBvZiBSZW1vdGlvbiB2NC4wLjIyOC4gVGhlIG5hdGl2ZSBjbGlwcGluZyBBUElzIHdlcmUgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIHJlbW92YWwgYXQgYW55IHRpbWUuIFdlIHJlbW92ZWQgdGhlbSBiZWNhdXNlIHRoZXkgd2VyZSBzcGFyaW5nbHkgdXNlZCBhbmQgbWFkZSByZW5kZXJpbmcgb2Z0ZW4gc2xvd2VyIHJhdGhlciB0aGFuIGZhc3Rlci5cIik7XG59O1xuXG4vLyBzcmMvZW5hYmxlLXNlcXVlbmNlLXN0YWNrLXRyYWNlcy50c1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IEpzeFJ1bnRpbWUgZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5cbi8vIHNyYy9nZXQtcmVtb3Rpb24tZW52aXJvbm1lbnQudHNcbmZ1bmN0aW9uIGdldE5vZGVFbnZTdHJpbmcoKSB7XG4gIHJldHVybiBbXCJOT0RcIiwgXCJFX0VOXCIsIFwiVlwiXS5qb2luKFwiXCIpO1xufVxudmFyIGdldEVudlN0cmluZyA9ICgpID0+IHtcbiAgcmV0dXJuIFtcImVcIiwgXCJudlwiXS5qb2luKFwiXCIpO1xufTtcbnZhciBnZXRSZW1vdGlvbkVudmlyb25tZW50ID0gKCkgPT4ge1xuICBjb25zdCBpc1BsYXllciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lzUGxheWVyO1xuICBjb25zdCBpc1JlbmRlcmluZyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5wcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucHJvY2Vzcy5lbnYgIT09IFwidW5kZWZpbmVkXCIgJiYgKHdpbmRvdy5wcm9jZXNzW2dldEVudlN0cmluZygpXVtnZXROb2RlRW52U3RyaW5nKCldID09PSBcInRlc3RcIiB8fCB3aW5kb3cucHJvY2Vzc1tnZXRFbnZTdHJpbmcoKV1bZ2V0Tm9kZUVudlN0cmluZygpXSA9PT0gXCJwcm9kdWN0aW9uXCIgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnJlbW90aW9uX3B1cHBldGVlclRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpO1xuICBjb25zdCBpc1N0dWRpbyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lzU3R1ZGlvO1xuICBjb25zdCBpc1JlYWRPbmx5U3R1ZGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNSZWFkT25seVN0dWRpbztcbiAgcmV0dXJuIHtcbiAgICBpc1N0dWRpbyxcbiAgICBpc1JlbmRlcmluZyxcbiAgICBpc1BsYXllcixcbiAgICBpc1JlYWRPbmx5U3R1ZGlvLFxuICAgIGlzQ2xpZW50U2lkZVJlbmRlcmluZzogZmFsc2VcbiAgfTtcbn07XG5cbi8vIHNyYy9lbmFibGUtc2VxdWVuY2Utc3RhY2stdHJhY2VzLnRzXG52YXIgb3JpZ2luYWxDcmVhdGVFbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudDtcbnZhciBvcmlnaW5hbEpzeCA9IEpzeFJ1bnRpbWUuanN4O1xudmFyIGNvbXBvbmVudHNUb0FkZFN0YWNrc1RvID0gW107XG52YXIgZW5hYmxlUHJveHkgPSAoYXBpKSA9PiB7XG4gIHJldHVybiBuZXcgUHJveHkoYXBpLCB7XG4gICAgYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSkge1xuICAgICAgaWYgKGNvbXBvbmVudHNUb0FkZFN0YWNrc1RvLmluY2x1ZGVzKGFyZ0FycmF5WzBdKSkge1xuICAgICAgICBjb25zdCBbZmlyc3QsIHByb3BzLCAuLi5yZXN0XSA9IGFyZ0FycmF5O1xuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAuLi5wcm9wcyA/PyB7fSxcbiAgICAgICAgICBzdGFjazogbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBbZmlyc3QsIG5ld1Byb3BzLCAuLi5yZXN0XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ0FycmF5KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzID0gKCkgPT4ge1xuICBpZiAoIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1N0dWRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBSZWFjdC5jcmVhdGVFbGVtZW50ID0gZW5hYmxlUHJveHkob3JpZ2luYWxDcmVhdGVFbGVtZW50KTtcbiAgSnN4UnVudGltZS5qc3ggPSBlbmFibGVQcm94eShvcmlnaW5hbEpzeCk7XG59O1xudmFyIGFkZFNlcXVlbmNlU3RhY2tUcmFjZXMgPSAoY29tcG9uZW50KSA9PiB7XG4gIGNvbXBvbmVudHNUb0FkZFN0YWNrc1RvLnB1c2goY29tcG9uZW50KTtcbiAgZW5hYmxlU2VxdWVuY2VTdGFja1RyYWNlcygpO1xufTtcblxuLy8gc3JjL2lzLXBsYXllci50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsIHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIElzUGxheWVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQyKGZhbHNlKTtcbnZhciBJc1BsYXllckNvbnRleHRQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuXG59KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KElzUGxheWVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VJc1BsYXllciA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoSXNQbGF5ZXJDb250ZXh0KTtcbn07XG5cbi8vIHNyYy90cnV0aHkudHNcbmZ1bmN0aW9uIHRydXRoeSh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgVkVSU0lPTiA9IFwiNC4wLjM4OFwiO1xuXG4vLyBzcmMvbXVsdGlwbGUtdmVyc2lvbnMtd2FybmluZy50c1xudmFyIGNoZWNrTXVsdGlwbGVSZW1vdGlvblZlcnNpb25zID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2V0ID0gKCkgPT4ge1xuICAgIGdsb2JhbFRoaXMucmVtb3Rpb25faW1wb3J0ZWQgPSBWRVJTSU9OO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25faW1wb3J0ZWQgPSBWRVJTSU9OO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYWxyZWFkeUltcG9ydGVkID0gZ2xvYmFsVGhpcy5yZW1vdGlvbl9pbXBvcnRlZCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pbXBvcnRlZDtcbiAgaWYgKGFscmVhZHlJbXBvcnRlZCkge1xuICAgIGlmIChhbHJlYWR5SW1wb3J0ZWQgPT09IFZFUlNJT04pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbHJlYWR5SW1wb3J0ZWQgPT09IFwic3RyaW5nXCIgJiYgYWxyZWFkeUltcG9ydGVkLmluY2x1ZGVzKFwid2ViY29kZWNzXCIpKSB7XG4gICAgICBzZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXFx1RDgzRFxcdURFQTggTXVsdGlwbGUgdmVyc2lvbnMgb2YgUmVtb3Rpb24gZGV0ZWN0ZWQ6ICR7W1xuICAgICAgVkVSU0lPTixcbiAgICAgIHR5cGVvZiBhbHJlYWR5SW1wb3J0ZWQgPT09IFwic3RyaW5nXCIgPyBhbHJlYWR5SW1wb3J0ZWQgOiBcImFuIG9sZGVyIHZlcnNpb25cIlxuICAgIF0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBhbmQgXCIpfS4gVGhpcyB3aWxsIGNhdXNlIHRoaW5ncyB0byBicmVhayBpbiBhbiB1bmV4cGVjdGVkIHdheS5cbkNoZWNrIHRoYXQgYWxsIHlvdXIgUmVtb3Rpb24gcGFja2FnZXMgYXJlIG9uIHRoZSBzYW1lIHZlcnNpb24uIElmIHlvdXIgZGVwZW5kZW5jaWVzIGRlcGVuZCBvbiBSZW1vdGlvbiwgbWFrZSB0aGVtIHBlZXIgZGVwZW5kZW5jaWVzLiBZb3UgY2FuIGFsc28gcnVuIFxcYG5weCByZW1vdGlvbiB2ZXJzaW9uc1xcYCBmcm9tIHlvdXIgdGVybWluYWwgdG8gc2VlIHdoaWNoIHZlcnNpb25zIGFyZSBtaXNtYXRjaGluZy5gKTtcbiAgfVxuICBzZXQoKTtcbn07XG5cbi8vIHNyYy9OdWxsLnRzeFxudmFyIE51bGwgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIjxOdWxsPiBoYXMgYmVlbiByZW1vdmVkIGFzIG9mIFJlbW90aW9uIHY0LjAuMjI4LiBUaGUgbmF0aXZlIGNsaXBwaW5nIEFQSXMgd2VyZSBleHBlcmltZW50YWwgYW5kIHN1YmplY3QgdG8gcmVtb3ZhbCBhdCBhbnkgdGltZS4gV2UgcmVtb3ZlZCB0aGVtIGJlY2F1c2UgdGhleSB3ZXJlIHNwYXJpbmdseSB1c2VkIGFuZCBtYWRlIHJlbmRlcmluZyBvZnRlbiBzbG93ZXIgcmF0aGVyIHRoYW4gZmFzdGVyLlwiKTtcbn07XG5cbi8vIHNyYy9TZXF1ZW5jZS50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjIsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEzLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MyxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTAsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlNlxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0Fic29sdXRlRmlsbC50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgaGFzVGFpbHdpbmRDbGFzc05hbWUgPSAoe1xuICBjbGFzc05hbWUsXG4gIGNsYXNzUHJlZml4LFxuICB0eXBlXG59KSA9PiB7XG4gIGlmICghY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlID09PSBcImV4YWN0XCIpIHtcbiAgICBjb25zdCBzcGxpdCA9IGNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG4gICAgcmV0dXJuIGNsYXNzUHJlZml4LnNvbWUoKHRva2VuKSA9PiB7XG4gICAgICByZXR1cm4gc3BsaXQuc29tZSgocGFydCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFydC50cmltKCkgPT09IHRva2VuIHx8IHBhcnQudHJpbSgpLmVuZHNXaXRoKGA6JHt0b2tlbn1gKSB8fCBwYXJ0LnRyaW0oKS5lbmRzV2l0aChgISR7dG9rZW59YCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2xhc3NQcmVmaXguc29tZSgocHJlZml4KSA9PiB7XG4gICAgcmV0dXJuIGNsYXNzTmFtZS5zdGFydHNXaXRoKHByZWZpeCkgfHwgY2xhc3NOYW1lLmluY2x1ZGVzKGAgJHtwcmVmaXh9YCkgfHwgY2xhc3NOYW1lLmluY2x1ZGVzKGAhJHtwcmVmaXh9YCkgfHwgY2xhc3NOYW1lLmluY2x1ZGVzKGA6JHtwcmVmaXh9YCk7XG4gIH0pO1xufTtcbnZhciBBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgeyBzdHlsZSwgLi4ub3RoZXIgfSA9IHByb3BzO1xuICBjb25zdCBhY3R1YWxTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgdG9wOiBoYXNUYWlsd2luZENsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZTogb3RoZXIuY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc1ByZWZpeDogW1widG9wLVwiLCBcImluc2V0LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgbGVmdDogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcImxlZnQtXCIsIFwiaW5zZXQtXCJdLFxuICAgICAgICB0eXBlOiBcInByZWZpeFwiXG4gICAgICB9KSA/IHVuZGVmaW5lZCA6IDAsXG4gICAgICByaWdodDogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcInJpZ2h0LVwiLCBcImluc2V0LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgYm90dG9tOiBoYXNUYWlsd2luZENsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZTogb3RoZXIuY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc1ByZWZpeDogW1wiYm90dG9tLVwiLCBcImluc2V0LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgd2lkdGg6IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUHJlZml4OiBbXCJ3LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiBcIjEwMCVcIixcbiAgICAgIGhlaWdodDogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcImgtXCJdLFxuICAgICAgICB0eXBlOiBcInByZWZpeFwiXG4gICAgICB9KSA/IHVuZGVmaW5lZCA6IFwiMTAwJVwiLFxuICAgICAgZGlzcGxheTogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcbiAgICAgICAgICBcImJsb2NrXCIsXG4gICAgICAgICAgXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgICBcImlubGluZVwiLFxuICAgICAgICAgIFwiZmxleFwiLFxuICAgICAgICAgIFwiaW5saW5lLWZsZXhcIixcbiAgICAgICAgICBcImZsb3ctcm9vdFwiLFxuICAgICAgICAgIFwiZ3JpZFwiLFxuICAgICAgICAgIFwiaW5saW5lLWdyaWRcIixcbiAgICAgICAgICBcImNvbnRlbnRzXCIsXG4gICAgICAgICAgXCJsaXN0LWl0ZW1cIixcbiAgICAgICAgICBcImhpZGRlblwiXG4gICAgICAgIF0sXG4gICAgICAgIHR5cGU6IFwiZXhhY3RcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiBcImZsZXhcIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUHJlZml4OiBbXG4gICAgICAgICAgXCJmbGV4LXJvd1wiLFxuICAgICAgICAgIFwiZmxleC1jb2xcIixcbiAgICAgICAgICBcImZsZXgtcm93LXJldmVyc2VcIixcbiAgICAgICAgICBcImZsZXgtY29sLXJldmVyc2VcIlxuICAgICAgICBdLFxuICAgICAgICB0eXBlOiBcImV4YWN0XCJcbiAgICAgIH0pID8gdW5kZWZpbmVkIDogXCJjb2x1bW5cIixcbiAgICAgIC4uLnN0eWxlXG4gICAgfTtcbiAgfSwgW290aGVyLmNsYXNzTmFtZSwgc3R5bGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZGl2XCIsIHtcbiAgICByZWYsXG4gICAgc3R5bGU6IGFjdHVhbFN0eWxlLFxuICAgIC4uLm90aGVyXG4gIH0pO1xufTtcbnZhciBBYnNvbHV0ZUZpbGwgPSBmb3J3YXJkUmVmKEFic29sdXRlRmlsbFJlZkZvcndhcmRpbmcpO1xuXG4vLyBzcmMvU2VxdWVuY2VDb250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIFNlcXVlbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQzKG51bGwpO1xuXG4vLyBzcmMvU2VxdWVuY2VNYW5hZ2VyLnRzeFxuaW1wb3J0IFJlYWN0MywgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU2VxdWVuY2VNYW5hZ2VyID0gUmVhY3QzLmNyZWF0ZUNvbnRleHQoe1xuICByZWdpc3RlclNlcXVlbmNlOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VxdWVuY2VNYW5hZ2VyQ29udGV4dCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gIH0sXG4gIHVucmVnaXN0ZXJTZXF1ZW5jZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlcXVlbmNlTWFuYWdlckNvbnRleHQgbm90IGluaXRpYWxpemVkXCIpO1xuICB9LFxuICBzZXF1ZW5jZXM6IFtdXG59KTtcbnZhciBTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0ID0gUmVhY3QzLmNyZWF0ZUNvbnRleHQoe1xuICBoaWRkZW46IHt9LFxuICBzZXRIaWRkZW46ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGUgbm90IGluaXRpYWxpemVkXCIpO1xuICB9XG59KTtcbnZhciBTZXF1ZW5jZU1hbmFnZXJQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW3NlcXVlbmNlcywgc2V0U2VxdWVuY2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2hpZGRlbiwgc2V0SGlkZGVuXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgcmVnaXN0ZXJTZXF1ZW5jZSA9IHVzZUNhbGxiYWNrKChzZXEpID0+IHtcbiAgICBzZXRTZXF1ZW5jZXMoKHNlcXMpID0+IHtcbiAgICAgIHJldHVybiBbLi4uc2Vxcywgc2VxXTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyU2VxdWVuY2UgPSB1c2VDYWxsYmFjaygoc2VxKSA9PiB7XG4gICAgc2V0U2VxdWVuY2VzKChzZXFzKSA9PiBzZXFzLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc2VxKSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgICAgc2VxdWVuY2VzLFxuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlXG4gICAgfTtcbiAgfSwgW3JlZ2lzdGVyU2VxdWVuY2UsIHNlcXVlbmNlcywgdW5yZWdpc3RlclNlcXVlbmNlXSk7XG4gIGNvbnN0IGhpZGRlbkNvbnRleHQgPSB1c2VNZW1vMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpZGRlbixcbiAgICAgIHNldEhpZGRlblxuICAgIH07XG4gIH0sIFtoaWRkZW5dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFNlcXVlbmNlTWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzZXF1ZW5jZUNvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBoaWRkZW5Db250ZXh0LFxuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9UaW1lbGluZUNvbnRleHQudHN4XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMCxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vIGFzIHVzZU1lbW83LFxuICB1c2VSZWYgYXMgdXNlUmVmMixcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGU1XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcmFuZG9tLnRzXG5mdW5jdGlvbiBtdWxiZXJyeTMyKGEpIHtcbiAgbGV0IHQgPSBhICsgMTgzMTU2NTgxMztcbiAgdCA9IE1hdGguaW11bCh0IF4gdCA+Pj4gMTUsIHQgfCAxKTtcbiAgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiB0ID4+PiA3LCB0IHwgNjEpO1xuICByZXR1cm4gKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG59XG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hyID0gMDtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGkgPSAwO2kgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgIGhhc2ggfD0gMDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbnZhciByYW5kb20gPSAoc2VlZCwgZHVtbXkpID0+IHtcbiAgaWYgKGR1bW15ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmFuZG9tKCkgdGFrZXMgb25seSBvbmUgYXJndW1lbnRcIik7XG4gIH1cbiAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihoYXNoQ29kZShzZWVkKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoc2VlZCAqIDEwMDAwMDAwMDAwKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb20oKSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xufTtcblxuLy8gc3JjL3RpbWVsaW5lLXBvc2l0aW9uLXN0YXRlLnRzXG52YXIgZXhwb3J0c190aW1lbGluZV9wb3NpdGlvbl9zdGF0ZSA9IHt9O1xuX19leHBvcnQoZXhwb3J0c190aW1lbGluZV9wb3NpdGlvbl9zdGF0ZSwge1xuICB1c2VUaW1lbGluZVNldEZyYW1lOiAoKSA9PiB1c2VUaW1lbGluZVNldEZyYW1lLFxuICB1c2VUaW1lbGluZVBvc2l0aW9uOiAoKSA9PiB1c2VUaW1lbGluZVBvc2l0aW9uLFxuICB1c2VQbGF5aW5nU3RhdGU6ICgpID0+IHVzZVBsYXlpbmdTdGF0ZSxcbiAgcGVyc2lzdEN1cnJlbnRGcmFtZTogKCkgPT4gcGVyc2lzdEN1cnJlbnRGcmFtZSxcbiAgZ2V0SW5pdGlhbEZyYW1lU3RhdGU6ICgpID0+IGdldEluaXRpYWxGcmFtZVN0YXRlLFxuICBnZXRGcmFtZUZvckNvbXBvc2l0aW9uOiAoKSA9PiBnZXRGcmFtZUZvckNvbXBvc2l0aW9uXG59KTtcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDYsIHVzZU1lbW8gYXMgdXNlTWVtbzYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZS1yZW1vdGlvbi1lbnZpcm9ubWVudC50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9yZW1vdGlvbi1lbnZpcm9ubWVudC1jb250ZXh0LnRzXG5pbXBvcnQgUmVhY3Q0IGZyb20gXCJyZWFjdFwiO1xudmFyIFJlbW90aW9uRW52aXJvbm1lbnRDb250ZXh0ID0gUmVhY3Q0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbi8vIHNyYy91c2UtcmVtb3Rpb24tZW52aXJvbm1lbnQudHNcbnZhciB1c2VSZW1vdGlvbkVudmlyb25tZW50ID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDIoUmVtb3Rpb25FbnZpcm9ubWVudENvbnRleHQpO1xuICBjb25zdCBbZW52XSA9IHVzZVN0YXRlMigoKSA9PiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkpO1xuICByZXR1cm4gY29udGV4dCA/PyBlbnY7XG59O1xuXG4vLyBzcmMvdXNlLXZpZGVvLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ1LCB1c2VNZW1vIGFzIHVzZU1lbW81IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9Db21wb3NpdGlvbk1hbmFnZXJDb250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIENvbXBvc2l0aW9uTWFuYWdlciA9IGNyZWF0ZUNvbnRleHQ0KHtcbiAgY29tcG9zaXRpb25zOiBbXSxcbiAgZm9sZGVyczogW10sXG4gIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhOiBudWxsLFxuICBjYW52YXNDb250ZW50OiBudWxsXG59KTtcbnZhciBDb21wb3NpdGlvblNldHRlcnMgPSBjcmVhdGVDb250ZXh0NCh7XG4gIHJlZ2lzdGVyQ29tcG9zaXRpb246ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVucmVnaXN0ZXJDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVnaXN0ZXJGb2xkZXI6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVucmVnaXN0ZXJGb2xkZXI6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHNldENhbnZhc0NvbnRlbnQ6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBvbmx5UmVuZGVyQ29tcG9zaXRpb246IG51bGxcbn0pO1xuXG4vLyBzcmMvUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NyxcbiAgY3JlYXRlUmVmLFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDQsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUyLFxuICB1c2VNZW1vIGFzIHVzZU1lbW80LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTRcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9FZGl0b3JQcm9wcy50c3hcbmltcG9ydCBSZWFjdDUsIHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NSxcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2syLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8zXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBFZGl0b3JQcm9wc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0NSh7XG4gIHByb3BzOiB7fSxcbiAgdXBkYXRlUHJvcHM6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH0sXG4gIHJlc2V0VW5zYXZlZDogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxufSk7XG52YXIgZWRpdG9yUHJvcHNQcm92aWRlclJlZiA9IFJlYWN0NS5jcmVhdGVSZWYoKTtcbnZhciB0aW1lVmFsdWVSZWYgPSBSZWFjdDUuY3JlYXRlUmVmKCk7XG52YXIgRWRpdG9yUHJvcHNQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW3Byb3BzLCBzZXRQcm9wc10gPSBSZWFjdDUudXNlU3RhdGUoe30pO1xuICBjb25zdCB1cGRhdGVQcm9wcyA9IHVzZUNhbGxiYWNrMigoe1xuICAgIGRlZmF1bHRQcm9wcyxcbiAgICBpZCxcbiAgICBuZXdQcm9wc1xuICB9KSA9PiB7XG4gICAgc2V0UHJvcHMoKHByZXYpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtpZF06IHR5cGVvZiBuZXdQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gbmV3UHJvcHMocHJldltpZF0gPz8gZGVmYXVsdFByb3BzKSA6IG5ld1Byb3BzXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlc2V0VW5zYXZlZCA9IHVzZUNhbGxiYWNrMigoY29tcG9zaXRpb25JZCkgPT4ge1xuICAgIHNldFByb3BzKChwcmV2KSA9PiB7XG4gICAgICBpZiAocHJldltjb21wb3NpdGlvbklkXSkge1xuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHsgLi4ucHJldiB9O1xuICAgICAgICBkZWxldGUgbmV3UHJvcHNbY29tcG9zaXRpb25JZF07XG4gICAgICAgIHJldHVybiBuZXdQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZWRpdG9yUHJvcHNQcm92aWRlclJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRQcm9wczogKCkgPT4gcHJvcHMsXG4gICAgICBzZXRQcm9wc1xuICAgIH07XG4gIH0sIFtwcm9wc10pO1xuICBjb25zdCBjdHggPSB1c2VNZW1vMygoKSA9PiB7XG4gICAgcmV0dXJuIHsgcHJvcHMsIHVwZGF0ZVByb3BzLCByZXNldFVuc2F2ZWQgfTtcbiAgfSwgW3Byb3BzLCByZXNldFVuc2F2ZWQsIHVwZGF0ZVByb3BzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NChFZGl0b3JQcm9wc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4LFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL2lucHV0LXByb3BzLW92ZXJyaWRlLnRzXG52YXIgZ2V0S2V5ID0gKCkgPT4ge1xuICByZXR1cm4gYHJlbW90aW9uX2lucHV0UHJvcHNPdmVycmlkZWAgKyB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xufTtcbnZhciBnZXRJbnB1dFByb3BzT3ZlcnJpZGUgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBvdmVycmlkZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldEtleSgpKTtcbiAgaWYgKCFvdmVycmlkZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIEpTT04ucGFyc2Uob3ZlcnJpZGUpO1xufTtcbnZhciBzZXRJbnB1dFByb3BzT3ZlcnJpZGUgPSAob3ZlcnJpZGUpID0+IHtcbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuICBpZiAob3ZlcnJpZGUgPT09IG51bGwpIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShnZXRLZXkoKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldEtleSgpLCBKU09OLnN0cmluZ2lmeShvdmVycmlkZSkpO1xufTtcblxuLy8gc3JjL2lucHV0LXByb3BzLXNlcmlhbGl6YXRpb24udHNcbnZhciBEQVRFX1RPS0VOID0gXCJyZW1vdGlvbi1kYXRlOlwiO1xudmFyIEZJTEVfVE9LRU4gPSBcInJlbW90aW9uLWZpbGU6XCI7XG52YXIgc2VyaWFsaXplSlNPTldpdGhTcGVjaWFsVHlwZXMgPSAoe1xuICBkYXRhLFxuICBpbmRlbnQsXG4gIHN0YXRpY0Jhc2Vcbn0pID0+IHtcbiAgbGV0IGN1c3RvbURhdGVVc2VkID0gZmFsc2U7XG4gIGxldCBjdXN0b21GaWxlVXNlZCA9IGZhbHNlO1xuICBsZXQgbWFwVXNlZCA9IGZhbHNlO1xuICBsZXQgc2V0VXNlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trZXldO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGN1c3RvbURhdGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0RBVEVfVE9LRU59JHtpdGVtLnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG1hcFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBzZXRVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICYmIHN0YXRpY0Jhc2UgIT09IG51bGwgJiYgaXRlbS5zdGFydHNXaXRoKHN0YXRpY0Jhc2UpKSB7XG4gICAgICAgIGN1c3RvbUZpbGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0ZJTEVfVE9LRU59JHtpdGVtLnJlcGxhY2Uoc3RhdGljQmFzZSArIFwiL1wiLCBcIlwiKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGluZGVudCk7XG4gICAgcmV0dXJuIHsgc2VyaWFsaXplZFN0cmluZywgY3VzdG9tRGF0ZVVzZWQsIGN1c3RvbUZpbGVVc2VkLCBtYXBVc2VkLCBzZXRVc2VkIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBzZXJpYWxpemUgdGhlIHBhc3NlZCBpbnB1dCBwcm9wcyB0byBKU09OOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgfVxufTtcbnZhciBkZXNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzID0gKGRhdGEpID0+IHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSwgKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKERBVEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUucmVwbGFjZShEQVRFX1RPS0VOLCBcIlwiKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChGSUxFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIGAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS8ke3ZhbHVlLnJlcGxhY2UoRklMRV9UT0tFTiwgXCJcIil9YDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn07XG52YXIgc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBkZXNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzKHNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzKHtcbiAgICBkYXRhOiBwcm9wcyxcbiAgICBpbmRlbnQ6IDIsXG4gICAgc3RhdGljQmFzZTogd2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2VcbiAgfSkuc2VyaWFsaXplZFN0cmluZyk7XG59O1xudmFyIHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvID0gKHByb3BzKSA9PiB7XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICByZXR1cm4gc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplKHByb3BzKTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59O1xuXG4vLyBzcmMvY29uZmlnL2lucHV0LXByb3BzLnRzXG52YXIgZGlkV2FyblNTUkltcG9ydCA9IGZhbHNlO1xudmFyIHdhcm5PbmNlU1NSSW1wb3J0ID0gKCkgPT4ge1xuICBpZiAoZGlkV2FyblNTUkltcG9ydCkge1xuICAgIHJldHVybjtcbiAgfVxuICBkaWRXYXJuU1NSSW1wb3J0ID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGBnZXRJbnB1dFByb3BzKClgIG9uIHRoZSBzZXJ2ZXIuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBzZXJ2ZXItc2lkZSBhbmQgaGFzIHJldHVybmVkIGFuIGVtcHR5IG9iamVjdC5cIik7XG4gIGNvbnNvbGUud2FybihcIlRvIGhpZGUgdGhpcyB3YXJuaW5nLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb24gdGhlIHNlcnZlcjpcIik7XG4gIGNvbnNvbGUud2FybihcIiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IGdldElucHV0UHJvcHMoKVwiKTtcbn07XG52YXIgZ2V0SW5wdXRQcm9wcyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3YXJuT25jZVNTUkltcG9ydCgpO1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBjYWxsIGBnZXRJbnB1dFByb3BzKClgIGZyb20gYSA8UGxheWVyPi4gSW5zdGVhZCwgdGhlIHByb3BzIGFyZSBhdmFpbGFibGUgYXMgUmVhY3QgcHJvcHMgZnJvbSBjb21wb25lbnQgdGhhdCB5b3UgcGFzc2VkIGFzIGBjb21wb25lbnRgIHByb3AuXCIpO1xuICB9XG4gIGNvbnN0IG92ZXJyaWRlID0gZ2V0SW5wdXRQcm9wc092ZXJyaWRlKCk7XG4gIGlmIChvdmVycmlkZSkge1xuICAgIHJldHVybiBvdmVycmlkZTtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygd2luZG93LnJlbW90aW9uX2lucHV0UHJvcHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBgZ2V0SW5wdXRQcm9wcygpYCAtIHdpbmRvdy5yZW1vdGlvbl9pbnB1dFByb3BzIGlzIG5vdCBzZXQuIFRoaXMgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHlvdSBhcmUgaW4gdGhlIFN0dWRpbywgb3Igd2hpbGUgeW91IGFyZSByZW5kZXJpbmcgc2VydmVyLXNpZGUuXCIpO1xuICB9XG4gIGNvbnN0IHBhcmFtID0gd2luZG93LnJlbW90aW9uX2lucHV0UHJvcHM7XG4gIGlmICghcGFyYW0pIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcGFyc2VkID0gZGVzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyhwYXJhbSk7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBzcmMvbm9uY2UudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDYsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBOb25jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0Nih7XG4gIGdldE5vbmNlOiAoKSA9PiAwLFxuICBmYXN0UmVmcmVzaGVzOiAwLFxuICBtYW51YWxSZWZyZXNoZXM6IDBcbn0pO1xudmFyIFNldE5vbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ2KHtcbiAgaW5jcmVhc2VNYW51YWxSZWZyZXNoZXM6ICgpID0+IHt9XG59KTtcbnZhciB1c2VOb25jZSA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQzKE5vbmNlQ29udGV4dCk7XG4gIGNvbnN0IFtub25jZSwgc2V0Tm9uY2VdID0gdXNlU3RhdGUzKCgpID0+IGNvbnRleHQuZ2V0Tm9uY2UoKSk7XG4gIGNvbnN0IGxhc3RDb250ZXh0ID0gdXNlUmVmKGNvbnRleHQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChsYXN0Q29udGV4dC5jdXJyZW50ID09PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RDb250ZXh0LmN1cnJlbnQgPSBjb250ZXh0O1xuICAgIHNldE5vbmNlKGNvbnRleHQuZ2V0Tm9uY2UpO1xuICB9LCBbY29udGV4dF0pO1xuICByZXR1cm4gbm9uY2U7XG59O1xuXG4vLyBzcmMvY29kZWMudHNcbnZhciB2YWxpZENvZGVjcyA9IFtcbiAgXCJoMjY0XCIsXG4gIFwiaDI2NVwiLFxuICBcInZwOFwiLFxuICBcInZwOVwiLFxuICBcIm1wM1wiLFxuICBcImFhY1wiLFxuICBcIndhdlwiLFxuICBcInByb3Jlc1wiLFxuICBcImgyNjQtbWt2XCIsXG4gIFwiaDI2NC10c1wiLFxuICBcImdpZlwiXG5dO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kZWZhdWx0LWNvZGVjLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUNvZGVjKGRlZmF1bHRDb2RlYywgbG9jYXRpb24sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBkZWZhdWx0Q29kZWMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0Q29kZWMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWV9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdENvZGVjfS5gKTtcbiAgfVxuICBpZiAoIXZhbGlkQ29kZWNzLmluY2x1ZGVzKGRlZmF1bHRDb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7bmFtZX1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgb25lIG9mICR7dmFsaWRDb2RlY3Muam9pbihcIiwgXCIpfSwgYnV0IHlvdSBwYXNzZWQgJHtkZWZhdWx0Q29kZWN9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRpbWVuc2lvbnMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9uKGFtb3VudCwgbmFtZU9mUHJvcCwgbG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBhbW91bnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhbW91bnR9YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgZmluaXRlLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHthbW91bnR9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWR1cmF0aW9uLWluLWZyYW1lcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhbGxvd0Zsb2F0cywgY29tcG9uZW50IH0gPSBvcHRpb25zO1xuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBpcyBtaXNzaW5nLmApO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghYWxsb3dGbG9hdHMgJiYgZHVyYXRpb25JbkZyYW1lcyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb25JbkZyYW1lcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1mcHMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRnBzKGZwcywgbG9jYXRpb24sIGlzR2lmKSB7XG4gIGlmICh0eXBlb2YgZnBzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgZmluaXRlLCBidXQgeW91IHBhc3NlZCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNOYU4oZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGZwcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJmcHNcIiBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChpc0dpZiAmJiBmcHMgPiA1MCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBGUFMgZm9yIGEgR0lGIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiA1MC4gVXNlIHRoZSAtLWV2ZXJ5LW50aC1mcmFtZSBvcHRpb24gdG8gbG93ZXIgdGhlIEZQUzogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9yZW5kZXItYXMtZ2lmYCk7XG4gIH1cbn1cblxuLy8gc3JjL3Jlc29sdmUtdmlkZW8tY29uZmlnLnRzXG52YXIgdmFsaWRhdGVDYWxjdWxhdGVkID0gKHtcbiAgY2FsY3VsYXRlZCxcbiAgY29tcG9zaXRpb25JZCxcbiAgY29tcG9zaXRpb25GcHMsXG4gIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICBjb21wb3NpdGlvbldpZHRoLFxuICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXNcbn0pID0+IHtcbiAgY29uc3QgY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uID0gYGNhbGN1bGF0ZWQgYnkgY2FsY3VsYXRlTWV0YWRhdGEoKSBmb3IgdGhlIGNvbXBvc2l0aW9uIFwiJHtjb21wb3NpdGlvbklkfVwiYDtcbiAgY29uc3QgZGVmYXVsdEVycm9yTG9jYXRpb24gPSBgb2YgdGhlIFwiPENvbXBvc2l0aW9uIC8+XCIgY29tcG9uZW50IHdpdGggdGhlIGlkIFwiJHtjb21wb3NpdGlvbklkfVwiYDtcbiAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVkPy53aWR0aCA/PyBjb21wb3NpdGlvbldpZHRoID8/IHVuZGVmaW5lZDtcbiAgdmFsaWRhdGVEaW1lbnNpb24od2lkdGgsIFwid2lkdGhcIiwgY2FsY3VsYXRlZD8ud2lkdGggPyBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gOiBkZWZhdWx0RXJyb3JMb2NhdGlvbik7XG4gIGNvbnN0IGhlaWdodCA9IGNhbGN1bGF0ZWQ/LmhlaWdodCA/PyBjb21wb3NpdGlvbkhlaWdodCA/PyB1bmRlZmluZWQ7XG4gIHZhbGlkYXRlRGltZW5zaW9uKGhlaWdodCwgXCJoZWlnaHRcIiwgY2FsY3VsYXRlZD8uaGVpZ2h0ID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24pO1xuICBjb25zdCBmcHMgPSBjYWxjdWxhdGVkPy5mcHMgPz8gY29tcG9zaXRpb25GcHMgPz8gbnVsbDtcbiAgdmFsaWRhdGVGcHMoZnBzLCBjYWxjdWxhdGVkPy5mcHMgPyBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gOiBkZWZhdWx0RXJyb3JMb2NhdGlvbiwgZmFsc2UpO1xuICBjb25zdCBkdXJhdGlvbkluRnJhbWVzID0gY2FsY3VsYXRlZD8uZHVyYXRpb25JbkZyYW1lcyA/PyBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbDtcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICBhbGxvd0Zsb2F0czogZmFsc2UsXG4gICAgY29tcG9uZW50OiBgb2YgdGhlIFwiPENvbXBvc2l0aW9uIC8+XCIgY29tcG9uZW50IHdpdGggdGhlIGlkIFwiJHtjb21wb3NpdGlvbklkfVwiYFxuICB9KTtcbiAgY29uc3QgZGVmYXVsdENvZGVjID0gY2FsY3VsYXRlZD8uZGVmYXVsdENvZGVjO1xuICB2YWxpZGF0ZUNvZGVjKGRlZmF1bHRDb2RlYywgY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uLCBcImRlZmF1bHRDb2RlY1wiKTtcbiAgY29uc3QgZGVmYXVsdE91dE5hbWUgPSBjYWxjdWxhdGVkPy5kZWZhdWx0T3V0TmFtZTtcbiAgY29uc3QgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQgPSBjYWxjdWxhdGVkPy5kZWZhdWx0VmlkZW9JbWFnZUZvcm1hdDtcbiAgY29uc3QgZGVmYXVsdFBpeGVsRm9ybWF0ID0gY2FsY3VsYXRlZD8uZGVmYXVsdFBpeGVsRm9ybWF0O1xuICBjb25zdCBkZWZhdWx0UHJvUmVzUHJvZmlsZSA9IGNhbGN1bGF0ZWQ/LmRlZmF1bHRQcm9SZXNQcm9maWxlO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmcHMsXG4gICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICBkZWZhdWx0Q29kZWMsXG4gICAgZGVmYXVsdE91dE5hbWUsXG4gICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQsXG4gICAgZGVmYXVsdFBpeGVsRm9ybWF0LFxuICAgIGRlZmF1bHRQcm9SZXNQcm9maWxlXG4gIH07XG59O1xudmFyIHJlc29sdmVWaWRlb0NvbmZpZyA9ICh7XG4gIGNhbGN1bGF0ZU1ldGFkYXRhLFxuICBzaWduYWwsXG4gIGRlZmF1bHRQcm9wcyxcbiAgaW5wdXRQcm9wczogb3JpZ2luYWxQcm9wcyxcbiAgY29tcG9zaXRpb25JZCxcbiAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzLFxuICBjb21wb3NpdGlvbkZwcyxcbiAgY29tcG9zaXRpb25IZWlnaHQsXG4gIGNvbXBvc2l0aW9uV2lkdGhcbn0pID0+IHtcbiAgY29uc3QgY2FsY3VsYXRlZFByb20gPSBjYWxjdWxhdGVNZXRhZGF0YSA/IGNhbGN1bGF0ZU1ldGFkYXRhKHtcbiAgICBkZWZhdWx0UHJvcHMsXG4gICAgcHJvcHM6IG9yaWdpbmFsUHJvcHMsXG4gICAgYWJvcnRTaWduYWw6IHNpZ25hbCxcbiAgICBjb21wb3NpdGlvbklkLFxuICAgIGlzUmVuZGVyaW5nOiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmdcbiAgfSkgOiBudWxsO1xuICBpZiAoY2FsY3VsYXRlZFByb20gIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZWRQcm9tID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIGNhbGN1bGF0ZWRQcm9tKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZWRQcm9tLnRoZW4oKGMpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgZnBzLFxuICAgICAgICBkZWZhdWx0Q29kZWMsXG4gICAgICAgIGRlZmF1bHRPdXROYW1lLFxuICAgICAgICBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdCxcbiAgICAgICAgZGVmYXVsdFBpeGVsRm9ybWF0LFxuICAgICAgICBkZWZhdWx0UHJvUmVzUHJvZmlsZVxuICAgICAgfSA9IHZhbGlkYXRlQ2FsY3VsYXRlZCh7XG4gICAgICAgIGNhbGN1bGF0ZWQ6IGMsXG4gICAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgY29tcG9zaXRpb25GcHMsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoLFxuICAgICAgICBjb21wb3NpdGlvbklkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZwcyxcbiAgICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgaWQ6IGNvbXBvc2l0aW9uSWQsXG4gICAgICAgIGRlZmF1bHRQcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oZGVmYXVsdFByb3BzKSxcbiAgICAgICAgcHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGMucHJvcHMgPz8gb3JpZ2luYWxQcm9wcyksXG4gICAgICAgIGRlZmF1bHRDb2RlYzogZGVmYXVsdENvZGVjID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRPdXROYW1lOiBkZWZhdWx0T3V0TmFtZSA/PyBudWxsLFxuICAgICAgICBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdDogZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQgPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFBpeGVsRm9ybWF0OiBkZWZhdWx0UGl4ZWxGb3JtYXQgPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFByb1Jlc1Byb2ZpbGU6IGRlZmF1bHRQcm9SZXNQcm9maWxlID8/IG51bGxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZGF0YSA9IHZhbGlkYXRlQ2FsY3VsYXRlZCh7XG4gICAgY2FsY3VsYXRlZDogY2FsY3VsYXRlZFByb20sXG4gICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzLFxuICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgIGNvbXBvc2l0aW9uV2lkdGgsXG4gICAgY29tcG9zaXRpb25JZFxuICB9KTtcbiAgaWYgKGNhbGN1bGF0ZWRQcm9tID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBpZDogY29tcG9zaXRpb25JZCxcbiAgICAgIGRlZmF1bHRQcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oZGVmYXVsdFByb3BzID8/IHt9KSxcbiAgICAgIHByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhvcmlnaW5hbFByb3BzKSxcbiAgICAgIGRlZmF1bHRDb2RlYzogbnVsbCxcbiAgICAgIGRlZmF1bHRPdXROYW1lOiBudWxsLFxuICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ6IG51bGwsXG4gICAgICBkZWZhdWx0UGl4ZWxGb3JtYXQ6IG51bGwsXG4gICAgICBkZWZhdWx0UHJvUmVzUHJvZmlsZTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGlkOiBjb21wb3NpdGlvbklkLFxuICAgIGRlZmF1bHRQcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oZGVmYXVsdFByb3BzID8/IHt9KSxcbiAgICBwcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oY2FsY3VsYXRlZFByb20ucHJvcHMgPz8gb3JpZ2luYWxQcm9wcyksXG4gICAgZGVmYXVsdENvZGVjOiBjYWxjdWxhdGVkUHJvbS5kZWZhdWx0Q29kZWMgPz8gbnVsbCxcbiAgICBkZWZhdWx0T3V0TmFtZTogY2FsY3VsYXRlZFByb20uZGVmYXVsdE91dE5hbWUgPz8gbnVsbCxcbiAgICBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdDogY2FsY3VsYXRlZFByb20uZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQgPz8gbnVsbCxcbiAgICBkZWZhdWx0UGl4ZWxGb3JtYXQ6IGNhbGN1bGF0ZWRQcm9tLmRlZmF1bHRQaXhlbEZvcm1hdCA/PyBudWxsLFxuICAgIGRlZmF1bHRQcm9SZXNQcm9maWxlOiBjYWxjdWxhdGVkUHJvbS5kZWZhdWx0UHJvUmVzUHJvZmlsZSA/PyBudWxsXG4gIH07XG59O1xudmFyIHJlc29sdmVWaWRlb0NvbmZpZ09yQ2F0Y2ggPSAocGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvbWlzZU9yUmV0dXJuVmFsdWUgPSByZXNvbHZlVmlkZW9Db25maWcocGFyYW1zKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICByZXN1bHQ6IHByb21pc2VPclJldHVyblZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIGVycm9yOiBlcnJcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDcobnVsbCk7XG52YXIgcmVzb2x2ZUNvbXBvc2l0aW9uc1JlZiA9IGNyZWF0ZVJlZigpO1xudmFyIG5lZWRzUmVzb2x1dGlvbiA9IChjb21wb3NpdGlvbikgPT4ge1xuICByZXR1cm4gQm9vbGVhbihjb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSk7XG59O1xudmFyIFBST1BTX1VQREFURURfRVhURVJOQUxMWSA9IFwicmVtb3Rpb24ucHJvcHNVcGRhdGVkRXh0ZXJuYWxseVwiO1xudmFyIFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZ0luU3R1ZGlvID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24sIHNldEN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uXSA9IHVzZVN0YXRlNChudWxsKTtcbiAgY29uc3QgeyBjb21wb3NpdGlvbnMsIGNhbnZhc0NvbnRlbnQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIH0gPSB1c2VDb250ZXh0NChDb21wb3NpdGlvbk1hbmFnZXIpO1xuICBjb25zdCB7IGZhc3RSZWZyZXNoZXMsIG1hbnVhbFJlZnJlc2hlcyB9ID0gdXNlQ29udGV4dDQoTm9uY2VDb250ZXh0KTtcbiAgaWYgKG1hbnVhbFJlZnJlc2hlcykge31cbiAgY29uc3Qgc2VsZWN0ZWRDb21wb3NpdGlvbiA9IHVzZU1lbW80KCgpID0+IHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGNhbnZhc0NvbnRlbnQgJiYgY2FudmFzQ29udGVudC50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgJiYgY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkID09PSBjLmlkKTtcbiAgfSwgW2NhbnZhc0NvbnRlbnQsIGNvbXBvc2l0aW9uc10pO1xuICBjb25zdCByZW5kZXJNb2RhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uKTtcbiAgY29uc3QgeyBwcm9wczogYWxsRWRpdG9yUHJvcHMgfSA9IHVzZUNvbnRleHQ0KEVkaXRvclByb3BzQ29udGV4dCk7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgaW5wdXRQcm9wcyA9IHVzZU1lbW80KCgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBlbnYuaXNQbGF5ZXIgPyB7fSA6IGdldElucHV0UHJvcHMoKSA/PyB7fTtcbiAgfSwgW2Vudi5pc1BsYXllcl0pO1xuICBjb25zdCBbcmVzb2x2ZWRDb25maWdzLCBzZXRSZXNvbHZlZENvbmZpZ3NdID0gdXNlU3RhdGU0KHt9KTtcbiAgY29uc3Qgc2VsZWN0ZWRFZGl0b3JQcm9wcyA9IHVzZU1lbW80KCgpID0+IHtcbiAgICByZXR1cm4gc2VsZWN0ZWRDb21wb3NpdGlvbiA/IGFsbEVkaXRvclByb3BzW3NlbGVjdGVkQ29tcG9zaXRpb24uaWRdID8/IHt9IDoge307XG4gIH0sIFthbGxFZGl0b3JQcm9wcywgc2VsZWN0ZWRDb21wb3NpdGlvbl0pO1xuICBjb25zdCByZW5kZXJNb2RhbFByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiByZW5kZXJNb2RhbENvbXBvc2l0aW9uID8gYWxsRWRpdG9yUHJvcHNbcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5pZF0gPz8ge30gOiB7fTtcbiAgfSwgW2FsbEVkaXRvclByb3BzLCByZW5kZXJNb2RhbENvbXBvc2l0aW9uXSk7XG4gIGNvbnN0IGhhc1Jlc29sdXRpb24gPSBCb29sZWFuKGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhKTtcbiAgY29uc3QgZG9SZXNvbHV0aW9uID0gdXNlQ2FsbGJhY2szKCh7XG4gICAgY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgY29tYmluZWRQcm9wcyxcbiAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgY29tcG9zaXRpb25GcHMsXG4gICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgY29tcG9zaXRpb25JZCxcbiAgICBjb21wb3NpdGlvbldpZHRoLFxuICAgIGRlZmF1bHRQcm9wc1xuICB9KSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7XG4gICAgaWYgKGhhc1Jlc29sdXRpb24pIHtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBjb25zdCB7IHNpZ25hbCB9ID0gY29udHJvbGxlcjtcbiAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlVmlkZW9Db25maWdPckNhdGNoKHtcbiAgICAgIGNvbXBvc2l0aW9uSWQsXG4gICAgICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgIGlucHV0UHJvcHM6IGNvbWJpbmVkUHJvcHMsXG4gICAgICBzaWduYWwsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBjb21wb3NpdGlvbkZwcyxcbiAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgICAgY29tcG9zaXRpb25XaWR0aFxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBjb25zdCBwcm9tT3JOb3QgPSByZXN1bHQucmVzdWx0O1xuICAgIGlmICh0eXBlb2YgcHJvbU9yTm90ID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHByb21Pck5vdCkge1xuICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXYgPSByW2NvbXBvc2l0aW9uSWRdO1xuICAgICAgICBpZiAocHJldj8udHlwZSA9PT0gXCJzdWNjZXNzXCIgfHwgcHJldj8udHlwZSA9PT0gXCJzdWNjZXNzLWFuZC1yZWZyZXNoaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIixcbiAgICAgICAgICAgICAgcmVzdWx0OiBwcmV2LnJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCJcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHByb21Pck5vdC50aGVuKChjKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICByZXN1bHQ6IGNcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAuLi5yLFxuICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICByZXN1bHQ6IHByb21Pck5vdFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVyO1xuICB9LCBbaGFzUmVzb2x1dGlvbl0pO1xuICBjb25zdCBjdXJyZW50Q29tcG9zaXRpb24gPSBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgPyBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlMihyZXNvbHZlQ29tcG9zaXRpb25zUmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uOiAoaWQpID0+IHtcbiAgICAgICAgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24oaWQpO1xuICAgICAgfSxcbiAgICAgIHJlbG9hZEN1cnJlbnRseVNlbGVjdGVkQ29tcG9zaXRpb246ICgpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgY29tcG9zaXRpb24gd2l0aCBpZCAke2N1cnJlbnRDb21wb3NpdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGl0b3JQcm9wcyA9IGFsbEVkaXRvclByb3BzW2N1cnJlbnRDb21wb3NpdGlvbl0gPz8ge307XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAuLi5jb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgLi4uZWRpdG9yUHJvcHMgPz8ge31cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICAgIC4uLmlucHV0UHJvcHMgPz8ge31cbiAgICAgICAgfTtcbiAgICAgICAgZG9SZXNvbHV0aW9uKHtcbiAgICAgICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IGNvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgICAgIGNvbWJpbmVkUHJvcHM6IHByb3BzLFxuICAgICAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lczogY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uRnBzOiBjb21wb3NpdGlvbi5mcHMgPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbkhlaWdodDogY29tcG9zaXRpb24uaGVpZ2h0ID8/IG51bGwsXG4gICAgICAgICAgY29tcG9zaXRpb25XaWR0aDogY29tcG9zaXRpb24ud2lkdGggPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbklkOiBjb21wb3NpdGlvbi5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXG4gICAgYWxsRWRpdG9yUHJvcHMsXG4gICAgY29tcG9zaXRpb25zLFxuICAgIGN1cnJlbnRDb21wb3NpdGlvbixcbiAgICBkb1Jlc29sdXRpb24sXG4gICAgaW5wdXRQcm9wc1xuICBdKTtcbiAgY29uc3QgaXNUaGVTYW1lID0gc2VsZWN0ZWRDb21wb3NpdGlvbj8uaWQgPT09IHJlbmRlck1vZGFsQ29tcG9zaXRpb24/LmlkO1xuICBjb25zdCBjdXJyZW50RGVmYXVsdFByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zZWxlY3RlZENvbXBvc2l0aW9uPy5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAuLi5zZWxlY3RlZEVkaXRvclByb3BzID8/IHt9XG4gICAgfTtcbiAgfSwgW3NlbGVjdGVkQ29tcG9zaXRpb24/LmRlZmF1bHRQcm9wcywgc2VsZWN0ZWRFZGl0b3JQcm9wc10pO1xuICBjb25zdCBvcmlnaW5hbFByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jdXJyZW50RGVmYXVsdFByb3BzLFxuICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgIH07XG4gIH0sIFtjdXJyZW50RGVmYXVsdFByb3BzLCBpbnB1dFByb3BzXSk7XG4gIGNvbnN0IGNhblJlc29sdmUgPSBzZWxlY3RlZENvbXBvc2l0aW9uICYmIG5lZWRzUmVzb2x1dGlvbihzZWxlY3RlZENvbXBvc2l0aW9uKTtcbiAgY29uc3Qgc2hvdWxkSWdub3JlVXBkYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGUgJiYgZmFzdFJlZnJlc2hlcyA8PSB3aW5kb3cucmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGU7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmIChzaG91bGRJZ25vcmVVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhblJlc29sdmUpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkb1Jlc29sdXRpb24oe1xuICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogc2VsZWN0ZWRDb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgICAgY29tYmluZWRQcm9wczogb3JpZ2luYWxQcm9wcyxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiBzZWxlY3RlZENvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25GcHM6IHNlbGVjdGVkQ29tcG9zaXRpb24uZnBzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiBzZWxlY3RlZENvbXBvc2l0aW9uLmhlaWdodCA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoOiBzZWxlY3RlZENvbXBvc2l0aW9uLndpZHRoID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQcm9wczogY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICAgICAgY29tcG9zaXRpb25JZDogc2VsZWN0ZWRDb21wb3NpdGlvbi5pZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW1xuICAgIGNhblJlc29sdmUsXG4gICAgY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICBkb1Jlc29sdXRpb24sXG4gICAgb3JpZ2luYWxQcm9wcyxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5kdXJhdGlvbkluRnJhbWVzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmZwcyxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5oZWlnaHQsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uaWQsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8ud2lkdGgsXG4gICAgc2hvdWxkSWdub3JlVXBkYXRlXG4gIF0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVuZGVyTW9kYWxDb21wb3NpdGlvbiAmJiAhaXNUaGVTYW1lKSB7XG4gICAgICBjb25zdCBjb21iaW5lZFByb3BzID0ge1xuICAgICAgICAuLi5yZW5kZXJNb2RhbENvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgLi4ucmVuZGVyTW9kYWxQcm9wcyA/PyB7fSxcbiAgICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkb1Jlc29sdXRpb24oe1xuICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25GcHM6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uZnBzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmhlaWdodCA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbklkOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmlkLFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLndpZHRoID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQcm9wczogY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICAgICAgY29tYmluZWRQcm9wc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW1xuICAgIGN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgZG9SZXNvbHV0aW9uLFxuICAgIGlucHV0UHJvcHMsXG4gICAgaXNUaGVTYW1lLFxuICAgIHJlbmRlck1vZGFsQ29tcG9zaXRpb24sXG4gICAgcmVuZGVyTW9kYWxQcm9wc1xuICBdKTtcbiAgY29uc3QgcmVzb2x2ZWRDb25maWdzSW5jbHVkaW5nU3RhdGljT25lcyA9IHVzZU1lbW80KCgpID0+IHtcbiAgICBjb25zdCBzdGF0aWNDb21wcyA9IGNvbXBvc2l0aW9ucy5maWx0ZXIoKGMpID0+IHtcbiAgICAgIHJldHVybiBjLmNhbGN1bGF0ZU1ldGFkYXRhID09PSBudWxsO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNvbHZlZENvbmZpZ3MsXG4gICAgICAuLi5zdGF0aWNDb21wcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBbY3Vyci5pZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgcmVzdWx0OiB7IC4uLmN1cnIsIGRlZmF1bHRQcm9wczogY3Vyci5kZWZhdWx0UHJvcHMgPz8ge30gfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sIHt9KVxuICAgIH07XG4gIH0sIFtjb21wb3NpdGlvbnMsIHJlc29sdmVkQ29uZmlnc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDUoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnID0gKHByZWZlcnJlZENvbXBvc2l0aW9uSWQpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ0KFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQpO1xuICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dDQoRWRpdG9yUHJvcHNDb250ZXh0KTtcbiAgY29uc3QgeyBjb21wb3NpdGlvbnMsIGNhbnZhc0NvbnRlbnQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIH0gPSB1c2VDb250ZXh0NChDb21wb3NpdGlvbk1hbmFnZXIpO1xuICBjb25zdCBjdXJyZW50Q29tcG9zaXRpb24gPSBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgPyBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsO1xuICBjb25zdCBjb21wb3NpdGlvbklkID0gcHJlZmVycmVkQ29tcG9zaXRpb25JZCA/PyBjdXJyZW50Q29tcG9zaXRpb247XG4gIGNvbnN0IGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGNvbXBvc2l0aW9uSWQpO1xuICBjb25zdCBzZWxlY3RlZEVkaXRvclByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiBjb21wb3NpdGlvbiA/IGFsbEVkaXRvclByb3BzW2NvbXBvc2l0aW9uLmlkXSA/PyB7fSA6IHt9O1xuICB9LCBbYWxsRWRpdG9yUHJvcHMsIGNvbXBvc2l0aW9uXSk7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgcmV0dXJuIHVzZU1lbW80KCgpID0+IHtcbiAgICBpZiAoIWNvbXBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgLi4uY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gICAgICAgICAgaWQ6IGNvbXBvc2l0aW9uLmlkLFxuICAgICAgICAgIGRlZmF1bHRQcm9wczogY29tcG9zaXRpb24uZGVmYXVsdFByb3BzID8/IHt9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbmVlZHNSZXNvbHV0aW9uKGNvbXBvc2l0aW9uKSkge1xuICAgICAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGNvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICAgICAgYWxsb3dGbG9hdHM6IGZhbHNlLFxuICAgICAgICBjb21wb25lbnQ6IGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmBcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVGcHMoY29tcG9zaXRpb24uZnBzLCBgaW4gPENvbXBvc2l0aW9uIGlkPVwiJHtjb21wb3NpdGlvbi5pZH1cIj5gLCBmYWxzZSk7XG4gICAgICB2YWxpZGF0ZURpbWVuc2lvbihjb21wb3NpdGlvbi53aWR0aCwgXCJ3aWR0aFwiLCBgaW4gPENvbXBvc2l0aW9uIGlkPVwiJHtjb21wb3NpdGlvbi5pZH1cIj5gKTtcbiAgICAgIHZhbGlkYXRlRGltZW5zaW9uKGNvbXBvc2l0aW9uLmhlaWdodCwgXCJoZWlnaHRcIiwgYGluIDxDb21wb3NpdGlvbiBpZD1cIiR7Y29tcG9zaXRpb24uaWR9XCI+YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgd2lkdGg6IGNvbXBvc2l0aW9uLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY29tcG9zaXRpb24uaGVpZ2h0LFxuICAgICAgICAgIGZwczogY29tcG9zaXRpb24uZnBzLFxuICAgICAgICAgIGlkOiBjb21wb3NpdGlvbi5pZCxcbiAgICAgICAgICBkdXJhdGlvbkluRnJhbWVzOiBjb21wb3NpdGlvbi5kdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICAgIGRlZmF1bHRQcm9wczogY29tcG9zaXRpb24uZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAuLi5jb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgICAuLi5zZWxlY3RlZEVkaXRvclByb3BzID8/IHt9LFxuICAgICAgICAgICAgLi4udHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBlbnYuaXNQbGF5ZXIgfHwgIXdpbmRvdy5yZW1vdGlvbl9pbnB1dFByb3BzID8ge30gOiBnZXRJbnB1dFByb3BzKCkgPz8ge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHRDb2RlYzogbnVsbCxcbiAgICAgICAgICBkZWZhdWx0T3V0TmFtZTogbnVsbCxcbiAgICAgICAgICBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdDogbnVsbCxcbiAgICAgICAgICBkZWZhdWx0UGl4ZWxGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgZGVmYXVsdFByb1Jlc1Byb2ZpbGU6IG51bGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0W2NvbXBvc2l0aW9uLmlkXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0W2NvbXBvc2l0aW9uLmlkXTtcbiAgfSwgW1xuICAgIGNvbXBvc2l0aW9uLFxuICAgIGNvbnRleHQsXG4gICAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gICAgc2VsZWN0ZWRFZGl0b3JQcm9wcyxcbiAgICBlbnYuaXNQbGF5ZXJcbiAgXSk7XG59O1xuXG4vLyBzcmMvdXNlLXZpZGVvLnRzXG52YXIgdXNlVmlkZW8gPSAoKSA9PiB7XG4gIGNvbnN0IHsgY2FudmFzQ29udGVudCwgY29tcG9zaXRpb25zLCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSB9ID0gdXNlQ29udGV4dDUoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3Qgc2VsZWN0ZWQgPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4ge1xuICAgIHJldHVybiBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgJiYgYy5pZCA9PT0gY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkO1xuICB9KTtcbiAgY29uc3QgcmVzb2x2ZWQgPSB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnKHNlbGVjdGVkPy5pZCA/PyBudWxsKTtcbiAgcmV0dXJuIHVzZU1lbW81KCgpID0+IHtcbiAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc29sdmVkLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZC50eXBlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzb2x2ZWQucmVzdWx0LFxuICAgICAgZGVmYXVsdFByb3BzOiBzZWxlY3RlZC5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICBpZDogc2VsZWN0ZWQuaWQsXG4gICAgICAuLi5jdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSA/PyB7fSxcbiAgICAgIGNvbXBvbmVudDogc2VsZWN0ZWQuY29tcG9uZW50XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCByZXNvbHZlZCwgc2VsZWN0ZWRdKTtcbn07XG5cbi8vIHNyYy90aW1lbGluZS1wb3NpdGlvbi1zdGF0ZS50c1xudmFyIG1ha2VLZXkgPSAoKSA9PiB7XG4gIHJldHVybiBgcmVtb3Rpb24udGltZS1hbGxgO1xufTtcbnZhciBwZXJzaXN0Q3VycmVudEZyYW1lID0gKHRpbWUpID0+IHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obWFrZUtleSgpLCBKU09OLnN0cmluZ2lmeSh0aW1lKSk7XG59O1xudmFyIGdldEluaXRpYWxGcmFtZVN0YXRlID0gKCkgPT4ge1xuICBjb25zdCBpdGVtID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obWFrZUtleSgpKSA/PyBcInt9XCI7XG4gIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoaXRlbSk7XG4gIHJldHVybiBvYmo7XG59O1xudmFyIGdldEZyYW1lRm9yQ29tcG9zaXRpb24gPSAoY29tcG9zaXRpb24pID0+IHtcbiAgY29uc3QgaXRlbSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKG1ha2VLZXkoKSkgPz8gXCJ7fVwiO1xuICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGl0ZW0pO1xuICBpZiAob2JqW2NvbXBvc2l0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE51bWJlcihvYmpbY29tcG9zaXRpb25dKTtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lID8/IDA7XG59O1xudmFyIHVzZVRpbWVsaW5lUG9zaXRpb24gPSAoKSA9PiB7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW8oKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VDb250ZXh0NihUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lID8/IDA7XG4gIH1cbiAgY29uc3QgdW5jbGFtcGVkID0gc3RhdGUuZnJhbWVbdmlkZW9Db25maWcuaWRdID8/IChlbnYuaXNQbGF5ZXIgPyAwIDogZ2V0RnJhbWVGb3JDb21wb3NpdGlvbih2aWRlb0NvbmZpZy5pZCkpO1xuICByZXR1cm4gTWF0aC5taW4odmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcyAtIDEsIHVuY2xhbXBlZCk7XG59O1xudmFyIHVzZVRpbWVsaW5lU2V0RnJhbWUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc2V0RnJhbWUgfSA9IHVzZUNvbnRleHQ2KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIHJldHVybiBzZXRGcmFtZTtcbn07XG52YXIgdXNlUGxheWluZ1N0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IHBsYXlpbmcsIGltcGVyYXRpdmVQbGF5aW5nIH0gPSB1c2VDb250ZXh0NihUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCB7IHNldFBsYXlpbmcgfSA9IHVzZUNvbnRleHQ2KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vNigoKSA9PiBbcGxheWluZywgc2V0UGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmddLCBbaW1wZXJhdGl2ZVBsYXlpbmcsIHBsYXlpbmcsIHNldFBsYXlpbmddKTtcbn07XG5cbi8vIHNyYy91c2UtZGVsYXktcmVuZGVyLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0OSwgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ4IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jYW5jZWwtcmVuZGVyLnRzXG52YXIgaXNFcnJvckxpa2UgPSAoZXJyKSA9PiB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJzdGFja1wiIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJtZXNzYWdlXCIgaW4gZXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGVyci5tZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGNhbmNlbFJlbmRlckludGVybmFsKHNjb3BlLCBlcnIpIHtcbiAgbGV0IGVycm9yO1xuICBpZiAoaXNFcnJvckxpa2UoZXJyKSkge1xuICAgIGVycm9yID0gZXJyO1xuICAgIGlmICghZXJyb3Iuc3RhY2spIHtcbiAgICAgIGVycm9yLnN0YWNrID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpLnN0YWNrO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXJyb3IgPSBFcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yID0gRXJyb3IoXCJSZW5kZXJpbmcgd2FzIGNhbmNlbGxlZFwiKTtcbiAgfVxuICBpZiAoc2NvcGUpIHtcbiAgICBzY29wZS5yZW1vdGlvbl9jYW5jZWxsZWRFcnJvciA9IGVycm9yLnN0YWNrO1xuICB9XG4gIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gY2FuY2VsUmVuZGVyKGVycikge1xuICByZXR1cm4gY2FuY2VsUmVuZGVySW50ZXJuYWwodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZCwgZXJyKTtcbn1cblxuLy8gc3JjL2xvZy50c1xudmFyIGxvZ0xldmVscyA9IFtcInRyYWNlXCIsIFwidmVyYm9zZVwiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl07XG52YXIgZ2V0TnVtYmVyRm9yTG9nTGV2ZWwgPSAobGV2ZWwpID0+IHtcbiAgcmV0dXJuIGxvZ0xldmVscy5pbmRleE9mKGxldmVsKTtcbn07XG52YXIgaXNFcXVhbE9yQmVsb3dMb2dMZXZlbCA9IChjdXJyZW50TGV2ZWwsIGxldmVsKSA9PiB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JMb2dMZXZlbChjdXJyZW50TGV2ZWwpIDw9IGdldE51bWJlckZvckxvZ0xldmVsKGxldmVsKTtcbn07XG52YXIgdHJhbnNmb3JtQXJncyA9ICh7XG4gIGFyZ3MsXG4gIGxvZ0xldmVsLFxuICB0YWdcbn0pID0+IHtcbiAgY29uc3QgYXJyID0gWy4uLmFyZ3NdO1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nICYmICFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNDbGllbnRTaWRlUmVuZGVyaW5nKSB7XG4gICAgYXJyLnVuc2hpZnQoU3ltYm9sLmZvcihgX19yZW1vdGlvbl9sZXZlbF8ke2xvZ0xldmVsfWApKTtcbiAgfVxuICBpZiAodGFnICYmIGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZyAmJiAhZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzQ2xpZW50U2lkZVJlbmRlcmluZykge1xuICAgIGFyci51bnNoaWZ0KFN5bWJvbC5mb3IoYF9fcmVtb3Rpb25fdGFnXyR7dGFnfWApKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbnZhciB2ZXJib3NlID0gKG9wdGlvbnMsIC4uLmFyZ3MpID0+IHtcbiAgaWYgKGlzRXF1YWxPckJlbG93TG9nTGV2ZWwob3B0aW9ucy5sb2dMZXZlbCwgXCJ2ZXJib3NlXCIpKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZGVidWcoLi4udHJhbnNmb3JtQXJncyh7IGFyZ3MsIGxvZ0xldmVsOiBcInZlcmJvc2VcIiwgdGFnOiBvcHRpb25zLnRhZyB9KSk7XG4gIH1cbn07XG52YXIgdHJhY2UgPSAob3B0aW9ucywgLi4uYXJncykgPT4ge1xuICBpZiAoaXNFcXVhbE9yQmVsb3dMb2dMZXZlbChvcHRpb25zLmxvZ0xldmVsLCBcInRyYWNlXCIpKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZGVidWcoLi4udHJhbnNmb3JtQXJncyh7IGFyZ3MsIGxvZ0xldmVsOiBcInRyYWNlXCIsIHRhZzogb3B0aW9ucy50YWcgfSkpO1xuICB9XG59O1xudmFyIGluZm8gPSAob3B0aW9ucywgLi4uYXJncykgPT4ge1xuICBpZiAoaXNFcXVhbE9yQmVsb3dMb2dMZXZlbChvcHRpb25zLmxvZ0xldmVsLCBcImluZm9cIikpIHtcbiAgICByZXR1cm4gY29uc29sZS5sb2coLi4udHJhbnNmb3JtQXJncyh7IGFyZ3MsIGxvZ0xldmVsOiBcImluZm9cIiwgdGFnOiBvcHRpb25zLnRhZyB9KSk7XG4gIH1cbn07XG52YXIgd2FybiA9IChvcHRpb25zLCAuLi5hcmdzKSA9PiB7XG4gIGlmIChpc0VxdWFsT3JCZWxvd0xvZ0xldmVsKG9wdGlvbnMubG9nTGV2ZWwsIFwid2FyblwiKSkge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oLi4udHJhbnNmb3JtQXJncyh7IGFyZ3MsIGxvZ0xldmVsOiBcIndhcm5cIiwgdGFnOiBvcHRpb25zLnRhZyB9KSk7XG4gIH1cbn07XG52YXIgZXJyb3IgPSAob3B0aW9ucywgLi4uYXJncykgPT4ge1xuICByZXR1cm4gY29uc29sZS5lcnJvciguLi50cmFuc2Zvcm1BcmdzKHsgYXJncywgbG9nTGV2ZWw6IFwiZXJyb3JcIiwgdGFnOiBvcHRpb25zLnRhZyB9KSk7XG59O1xudmFyIExvZyA9IHtcbiAgdHJhY2UsXG4gIHZlcmJvc2UsXG4gIGluZm8sXG4gIHdhcm4sXG4gIGVycm9yXG59O1xuXG4vLyBzcmMvZGVsYXktcmVuZGVyLnRzXG52YXIgaGFuZGxlcyA9IFtdO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gZmFsc2U7XG4gIGlmICghd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMpIHtcbiAgICB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0cyA9IHt9O1xuICB9XG59XG52YXIgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTiA9IFwiVGhlIGRlbGF5UmVuZGVyIHdhcyBjYWxsZWQ6XCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCA9IFwiUmV0cmllcyBsZWZ0OiBcIjtcbnZhciBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4gPSBcIi0gUmVuZGVyaW5nIHRoZSBmcmFtZSB3aWxsIGJlIHJldHJpZWQuXCI7XG52YXIgREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOID0gXCJoYW5kbGUgd2FzIGNsZWFyZWQgYWZ0ZXJcIjtcbnZhciBkZWZhdWx0VGltZW91dCA9IDMwMDAwO1xudmFyIGRlbGF5UmVuZGVySW50ZXJuYWwgPSAoe1xuICBzY29wZSxcbiAgZW52aXJvbm1lbnQsXG4gIGxhYmVsLFxuICBvcHRpb25zXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgbGFiZWwgIT09IFwic3RyaW5nXCIgJiYgbGFiZWwgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGFiZWwgcGFyYW1ldGVyIG9mIGRlbGF5UmVuZGVyKCkgbXVzdCBiZSBhIHN0cmluZyBvciB1bmRlZmluZWQsIGdvdDogXCIgKyBKU09OLnN0cmluZ2lmeShsYWJlbCkpO1xuICB9XG4gIGNvbnN0IGhhbmRsZSA9IE1hdGgucmFuZG9tKCk7XG4gIGhhbmRsZXMucHVzaChoYW5kbGUpO1xuICBjb25zdCBjYWxsZWQgPSBFcnJvcigpLnN0YWNrPy5yZXBsYWNlKC9eRXJyb3IvZywgXCJcIikgPz8gXCJcIjtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgY29uc3QgdGltZW91dFRvVXNlID0gKG9wdGlvbnM/LnRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyAodHlwZW9mIHNjb3BlID09PSBcInVuZGVmaW5lZFwiID8gZGVmYXVsdFRpbWVvdXQgOiBzY29wZS5yZW1vdGlvbl9wdXBwZXRlZXJUaW1lb3V0ID8/IGRlZmF1bHRUaW1lb3V0KSkgLSAyMDAwO1xuICAgIGlmICh0eXBlb2Ygc2NvcGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IHJldHJpZXNMZWZ0ID0gKG9wdGlvbnM/LnJldHJpZXMgPz8gMCkgLSAoc2NvcGUucmVtb3Rpb25fYXR0ZW1wdCAtIDEpO1xuICAgICAgc2NvcGUucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdID0ge1xuICAgICAgICBsYWJlbDogbGFiZWwgPz8gbnVsbCxcbiAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICB0aW1lb3V0OiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICAgICAgYEEgZGVsYXlSZW5kZXIoKWAsXG4gICAgICAgICAgICBsYWJlbCA/IGBcIiR7bGFiZWx9XCJgIDogbnVsbCxcbiAgICAgICAgICAgIGB3YXMgY2FsbGVkIGJ1dCBub3QgY2xlYXJlZCBhZnRlciAke3RpbWVvdXRUb1VzZX1tcy4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvdGltZW91dCBmb3IgaGVscC5gLFxuICAgICAgICAgICAgcmV0cmllc0xlZnQgPiAwID8gREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCArIHJldHJpZXNMZWZ0IDogbnVsbCxcbiAgICAgICAgICAgIHJldHJpZXNMZWZ0ID4gMCA/IERFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTiA6IG51bGwsXG4gICAgICAgICAgICBERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOLFxuICAgICAgICAgICAgY2FsbGVkXG4gICAgICAgICAgXS5maWx0ZXIodHJ1dGh5KS5qb2luKFwiIFwiKTtcbiAgICAgICAgICBjYW5jZWxSZW5kZXJJbnRlcm5hbChzY29wZSwgRXJyb3IobWVzc2FnZSkpO1xuICAgICAgICB9LCB0aW1lb3V0VG9Vc2UpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjb3BlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NvcGUucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufTtcbnZhciBkZWxheVJlbmRlciA9IChsYWJlbCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gZGVsYXlSZW5kZXJJbnRlcm5hbCh7XG4gICAgc2NvcGU6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB1bmRlZmluZWQsXG4gICAgZW52aXJvbm1lbnQ6IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKSxcbiAgICBsYWJlbDogbGFiZWwgPz8gbnVsbCxcbiAgICBvcHRpb25zOiBvcHRpb25zID8/IHt9XG4gIH0pO1xufTtcbnZhciBjb250aW51ZVJlbmRlckludGVybmFsID0gKHtcbiAgc2NvcGUsXG4gIGhhbmRsZSxcbiAgZW52aXJvbm1lbnQsXG4gIGxvZ0xldmVsXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgaGFuZGxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjb250aW51ZVJlbmRlcigpIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgcGFyYW1ldGVyIHRoYXQgaXMgdGhlIHJldHVybiB2YWx1ZSBvZiBkZWxheVJlbmRlcigpLiBObyB2YWx1ZSB3YXMgcGFzc2VkLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcGFyYW1ldGVyIHBhc3NlZCBpbnRvIGNvbnRpbnVlUmVuZGVyKCkgbXVzdCBiZSB0aGUgcmV0dXJuIHZhbHVlIG9mIGRlbGF5UmVuZGVyKCkgd2hpY2ggaXMgYSBudW1iZXIuIEdvdDogXCIgKyBKU09OLnN0cmluZ2lmeShoYW5kbGUpKTtcbiAgfVxuICBoYW5kbGVzID0gaGFuZGxlcy5maWx0ZXIoKGgpID0+IHtcbiAgICBpZiAoaCA9PT0gaGFuZGxlKSB7XG4gICAgICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcgJiYgc2NvcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXNjb3BlLnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxhYmVsLCBzdGFydFRpbWUsIHRpbWVvdXQgfSA9IHNjb3BlLnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICAgIGxhYmVsID8gYFwiJHtsYWJlbH1cImAgOiBcIkEgaGFuZGxlXCIsXG4gICAgICAgICAgREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOLFxuICAgICAgICAgIGAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgXG4gICAgICAgIF0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBcIik7XG4gICAgICAgIExvZy52ZXJib3NlKHsgbG9nTGV2ZWwsIHRhZzogXCJkZWxheVJlbmRlcigpXCIgfSwgbWVzc2FnZSk7XG4gICAgICAgIGRlbGV0ZSBzY29wZS5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgaWYgKGhhbmRsZXMubGVuZ3RoID09PSAwICYmIHR5cGVvZiBzY29wZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHNjb3BlLnJlbW90aW9uX3JlbmRlclJlYWR5ID0gdHJ1ZTtcbiAgfVxufTtcbnZhciBjb250aW51ZVJlbmRlciA9IChoYW5kbGUpID0+IHtcbiAgY29udGludWVSZW5kZXJJbnRlcm5hbCh7XG4gICAgc2NvcGU6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlLFxuICAgIGVudmlyb25tZW50OiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCksXG4gICAgbG9nTGV2ZWw6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cucmVtb3Rpb25fbG9nTGV2ZWwgPz8gXCJpbmZvXCIgOiBcImluZm9cIlxuICB9KTtcbn07XG5cbi8vIHNyYy9sb2ctbGV2ZWwtY29udGV4dC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDggfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0NiBmcm9tIFwicmVhY3RcIjtcbnZhciBMb2dMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0OCh7XG4gIGxvZ0xldmVsOiBcImluZm9cIixcbiAgbW91bnRUaW1lOiAwXG59KTtcbnZhciB1c2VMb2dMZXZlbCA9ICgpID0+IHtcbiAgY29uc3QgeyBsb2dMZXZlbCB9ID0gUmVhY3Q2LnVzZUNvbnRleHQoTG9nTGV2ZWxDb250ZXh0KTtcbiAgaWYgKGxvZ0xldmVsID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlTG9nTGV2ZWwgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIExvZ0xldmVsUHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGxvZ0xldmVsO1xufTtcbnZhciB1c2VNb3VudFRpbWUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbW91bnRUaW1lIH0gPSBSZWFjdDYudXNlQ29udGV4dChMb2dMZXZlbENvbnRleHQpO1xuICBpZiAobW91bnRUaW1lID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlTW91bnRUaW1lIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBMb2dMZXZlbFByb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiBtb3VudFRpbWU7XG59O1xuXG4vLyBzcmMvdXNlLWRlbGF5LXJlbmRlci50c3hcbnZhciBEZWxheVJlbmRlckNvbnRleHRUeXBlID0gY3JlYXRlQ29udGV4dDkobnVsbCk7XG52YXIgdXNlRGVsYXlSZW5kZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBzY29wZSA9IHVzZUNvbnRleHQ4KERlbGF5UmVuZGVyQ29udGV4dFR5cGUpO1xuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IGRlbGF5UmVuZGVyMiA9IHVzZUNhbGxiYWNrNCgobGFiZWwsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gZGVsYXlSZW5kZXJJbnRlcm5hbCh7XG4gICAgICBzY29wZTogc2NvcGUgPz8gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB1bmRlZmluZWQpLFxuICAgICAgZW52aXJvbm1lbnQsXG4gICAgICBsYWJlbDogbGFiZWwgPz8gbnVsbCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMgPz8ge31cbiAgICB9KTtcbiAgfSwgW2Vudmlyb25tZW50LCBzY29wZV0pO1xuICBjb25zdCBjb250aW51ZVJlbmRlcjIgPSB1c2VDYWxsYmFjazQoKGhhbmRsZSkgPT4ge1xuICAgIGNvbnRpbnVlUmVuZGVySW50ZXJuYWwoe1xuICAgICAgc2NvcGU6IHNjb3BlID8/ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdW5kZWZpbmVkKSxcbiAgICAgIGhhbmRsZSxcbiAgICAgIGVudmlyb25tZW50LFxuICAgICAgbG9nTGV2ZWxcbiAgICB9KTtcbiAgfSwgW2Vudmlyb25tZW50LCBsb2dMZXZlbCwgc2NvcGVdKTtcbiAgY29uc3QgY2FuY2VsUmVuZGVyMiA9IHVzZUNhbGxiYWNrNCgoZXJyKSA9PiB7XG4gICAgcmV0dXJuIGNhbmNlbFJlbmRlckludGVybmFsKHNjb3BlID8/ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdW5kZWZpbmVkKSwgZXJyKTtcbiAgfSwgW3Njb3BlXSk7XG4gIHJldHVybiB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIsIGNhbmNlbFJlbmRlcjogY2FuY2VsUmVuZGVyMiB9O1xufTtcblxuLy8gc3JjL1RpbWVsaW5lQ29udGV4dC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g2IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU2V0VGltZWxpbmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDEwKHtcbiAgc2V0RnJhbWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9LFxuICBzZXRQbGF5aW5nOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfVxufSk7XG52YXIgVGltZWxpbmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDEwKHtcbiAgZnJhbWU6IHt9LFxuICBwbGF5aW5nOiBmYWxzZSxcbiAgcGxheWJhY2tSYXRlOiAxLFxuICByb290SWQ6IFwiXCIsXG4gIGltcGVyYXRpdmVQbGF5aW5nOiB7XG4gICAgY3VycmVudDogZmFsc2VcbiAgfSxcbiAgc2V0UGxheWJhY2tSYXRlOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfSxcbiAgYXVkaW9BbmRWaWRlb1RhZ3M6IHsgY3VycmVudDogW10gfVxufSk7XG52YXIgVGltZWxpbmVDb250ZXh0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgZnJhbWVTdGF0ZSB9KSA9PiB7XG4gIGNvbnN0IFtwbGF5aW5nLCBzZXRQbGF5aW5nXSA9IHVzZVN0YXRlNShmYWxzZSk7XG4gIGNvbnN0IGltcGVyYXRpdmVQbGF5aW5nID0gdXNlUmVmMihmYWxzZSk7XG4gIGNvbnN0IFtwbGF5YmFja1JhdGUsIHNldFBsYXliYWNrUmF0ZV0gPSB1c2VTdGF0ZTUoMSk7XG4gIGNvbnN0IGF1ZGlvQW5kVmlkZW9UYWdzID0gdXNlUmVmMihbXSk7XG4gIGNvbnN0IFtyZW1vdGlvblJvb3RJZF0gPSB1c2VTdGF0ZTUoKCkgPT4gU3RyaW5nKHJhbmRvbShudWxsKSkpO1xuICBjb25zdCBbX2ZyYW1lLCBzZXRGcmFtZV0gPSB1c2VTdGF0ZTUoKCkgPT4gZ2V0SW5pdGlhbEZyYW1lU3RhdGUoKSk7XG4gIGNvbnN0IGZyYW1lID0gZnJhbWVTdGF0ZSA/PyBfZnJhbWU7XG4gIGNvbnN0IHsgZGVsYXlSZW5kZXI6IGRlbGF5UmVuZGVyMiwgY29udGludWVSZW5kZXI6IGNvbnRpbnVlUmVuZGVyMiB9ID0gdXNlRGVsYXlSZW5kZXIoKTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW90aW9uX3NldEZyYW1lID0gKGYsIGNvbXBvc2l0aW9uLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdGlvbl9hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICAgICAgY29uc3QgaWQgPSBkZWxheVJlbmRlcjIoYFNldHRpbmcgdGhlIGN1cnJlbnQgZnJhbWUgdG8gJHtmfWApO1xuICAgICAgICBsZXQgYXN5bmNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzZXRGcmFtZSgocykgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHNbY29tcG9zaXRpb25dID8/IHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWU7XG4gICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSA9PT0gZikge1xuICAgICAgICAgICAgYXN5bmNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucyxcbiAgICAgICAgICAgIFtjb21wb3NpdGlvbl06IGZcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFzeW5jVXBkYXRlKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNvbnRpbnVlUmVuZGVyMihpZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyMihpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgPSBmYWxzZTtcbiAgICB9LCBbY29udGludWVSZW5kZXIyLCBkZWxheVJlbmRlcjJdKTtcbiAgfVxuICBjb25zdCB0aW1lbGluZUNvbnRleHRWYWx1ZSA9IHVzZU1lbW83KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJhbWUsXG4gICAgICBwbGF5aW5nLFxuICAgICAgaW1wZXJhdGl2ZVBsYXlpbmcsXG4gICAgICByb290SWQ6IHJlbW90aW9uUm9vdElkLFxuICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgc2V0UGxheWJhY2tSYXRlLFxuICAgICAgYXVkaW9BbmRWaWRlb1RhZ3NcbiAgICB9O1xuICB9LCBbZnJhbWUsIHBsYXliYWNrUmF0ZSwgcGxheWluZywgcmVtb3Rpb25Sb290SWRdKTtcbiAgY29uc3Qgc2V0VGltZWxpbmVDb250ZXh0VmFsdWUgPSB1c2VNZW1vNygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEZyYW1lLFxuICAgICAgc2V0UGxheWluZ1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g2KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0aW1lbGluZUNvbnRleHRWYWx1ZSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDYoU2V0VGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc2V0VGltZWxpbmVDb250ZXh0VmFsdWUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby1jb25maWcudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEwIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9DYW5Vc2VSZW1vdGlvbkhvb2tzLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTEgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rcyA9IGNyZWF0ZUNvbnRleHQxMShmYWxzZSk7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDcoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS11bnNhZmUtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ5LCB1c2VNZW1vIGFzIHVzZU1lbW84IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVW5zYWZlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0OShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBjdHhXaWR0aCA9IGNvbnRleHQ/LndpZHRoID8/IG51bGw7XG4gIGNvbnN0IGN0eEhlaWdodCA9IGNvbnRleHQ/LmhlaWdodCA/PyBudWxsO1xuICBjb25zdCBjdHhEdXJhdGlvbiA9IGNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbDtcbiAgY29uc3QgdmlkZW8gPSB1c2VWaWRlbygpO1xuICByZXR1cm4gdXNlTWVtbzgoKCkgPT4ge1xuICAgIGlmICghdmlkZW8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBmcHMsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHByb3BzLFxuICAgICAgZGVmYXVsdENvZGVjLFxuICAgICAgZGVmYXVsdE91dE5hbWUsXG4gICAgICBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdCxcbiAgICAgIGRlZmF1bHRQaXhlbEZvcm1hdCxcbiAgICAgIGRlZmF1bHRQcm9SZXNQcm9maWxlXG4gICAgfSA9IHZpZGVvO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHdpZHRoOiBjdHhXaWR0aCA/PyB3aWR0aCxcbiAgICAgIGhlaWdodDogY3R4SGVpZ2h0ID8/IGhlaWdodCxcbiAgICAgIGZwcyxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGN0eER1cmF0aW9uID8/IGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRDb2RlYyxcbiAgICAgIGRlZmF1bHRPdXROYW1lLFxuICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQsXG4gICAgICBkZWZhdWx0UGl4ZWxGb3JtYXQsXG4gICAgICBkZWZhdWx0UHJvUmVzUHJvZmlsZVxuICAgIH07XG4gIH0sIFtjdHhEdXJhdGlvbiwgY3R4SGVpZ2h0LCBjdHhXaWR0aCwgdmlkZW9dKTtcbn07XG5cbi8vIHNyYy91c2UtdmlkZW8tY29uZmlnLnRzXG52YXIgdXNlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQxMChDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgY29uc3QgaXNQbGF5ZXIgPSB1c2VJc1BsYXllcigpO1xuICBpZiAoIXZpZGVvQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lzUGxheWVyIHx8IGlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgICBcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZC4gTGlrZWx5IHJlYXNvbnM6XCIsXG4gICAgICAgIFwiLSBZb3UgYXJlIHByb2JhYmx5IGNhbGxpbmcgdXNlVmlkZW9Db25maWcoKSBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudCBwYXNzZWQgdG8gPFBsYXllciAvPi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3BsYXllci9leGFtcGxlcyBmb3IgaG93IHRvIHNldCB1cCB0aGUgUGxheWVyIGNvcnJlY3RseS5cIixcbiAgICAgICAgXCItIFlvdSBoYXZlIG11bHRpcGxlIHZlcnNpb25zIG9mIFJlbW90aW9uIGluc3RhbGxlZCB3aGljaCBjYXVzZXMgdGhlIFJlYWN0IGNvbnRleHQgdG8gZ2V0IGxvc3QuXCJcbiAgICAgIF0uam9pbihcIi1cIikpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2aWRlbyBjb25maWcgZm91bmQuIFlvdSBhcmUgcHJvYmFibHkgY2FsbGluZyB1c2VWaWRlb0NvbmZpZygpIGZyb20gYSBjb21wb25lbnQgd2hpY2ggaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgYXMgYSA8Q29tcG9zaXRpb24gLz4uIFNlZSBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy90aGUtZnVuZGFtZW50YWxzI2RlZmluaW5nLWNvbXBvc2l0aW9ucyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIik7XG4gIH1cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIHVzZVZpZGVvQ29uZmlnKCkgb3V0c2lkZSBhIFJlbW90aW9uIGNvbXBvc2l0aW9uLlwiKTtcbiAgfVxuICByZXR1cm4gdmlkZW9Db25maWc7XG59O1xuXG4vLyBzcmMvZnJlZXplLnRzeFxuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTIsIHVzZU1lbW8gYXMgdXNlTWVtbzkgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZS1jdXJyZW50LWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUN1cnJlbnRGcmFtZSA9ICgpID0+IHtcbiAgY29uc3QgY2FuVXNlUmVtb3Rpb25Ib29rcyA9IHVzZUNvbnRleHQxMShDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBpZiAoIWNhblVzZVJlbW90aW9uSG9va3MpIHtcbiAgICBpZiAoZW52LmlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVzZUN1cnJlbnRGcmFtZSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHBhc3NlZCB0byA8UGxheWVyPi4gU2VlOiBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvZXhhbXBsZXNgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1c2VDdXJyZW50RnJhbWUoKSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHJlZ2lzdGVyZWQgYXMgYSBjb21wb3NpdGlvbi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zYCk7XG4gIH1cbiAgY29uc3QgZnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MTEoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgY29udGV4dE9mZnNldCA9IGNvbnRleHQgPyBjb250ZXh0LmN1bXVsYXRlZEZyb20gKyBjb250ZXh0LnJlbGF0aXZlRnJvbSA6IDA7XG4gIHJldHVybiBmcmFtZSAtIGNvbnRleHRPZmZzZXQ7XG59O1xuXG4vLyBzcmMvZnJlZXplLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBGcmVlemUgPSAoe1xuICBmcmFtZTogZnJhbWVUb0ZyZWV6ZSxcbiAgY2hpbGRyZW4sXG4gIGFjdGl2ZSA9IHRydWVcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBpZiAodHlwZW9mIGZyYW1lVG9GcmVlemUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSA8RnJlZXplIC8+IGNvbXBvbmVudCByZXF1aXJlcyBhICdmcmFtZScgcHJvcCwgYnV0IG5vbmUgd2FzIHBhc3NlZC5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyYW1lVG9GcmVlemUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgaXMgb2YgdHlwZSAke3R5cGVvZiBmcmFtZVRvRnJlZXplfWApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZnJhbWVUb0ZyZWV6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgcmVhbCBudW1iZXIsIGJ1dCBpdCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWVUb0ZyZWV6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgZmluaXRlIG51bWJlciwgYnV0IGl0IGlzICR7ZnJhbWVUb0ZyZWV6ZX0uYCk7XG4gIH1cbiAgY29uc3QgaXNBY3RpdmUgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGl2ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlKGZyYW1lKTtcbiAgICB9XG4gIH0sIFthY3RpdmUsIGZyYW1lXSk7XG4gIGNvbnN0IHRpbWVsaW5lQ29udGV4dCA9IHVzZUNvbnRleHQxMihUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MTIoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgcmVsYXRpdmVGcm9tID0gc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMDtcbiAgY29uc3QgdGltZWxpbmVWYWx1ZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gdGltZWxpbmVDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGltZWxpbmVDb250ZXh0LFxuICAgICAgcGxheWluZzogZmFsc2UsXG4gICAgICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgICAgICBjdXJyZW50OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZyYW1lOiB7XG4gICAgICAgIFt2aWRlb0NvbmZpZy5pZF06IGZyYW1lVG9GcmVlemUgKyByZWxhdGl2ZUZyb21cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaXNBY3RpdmUsIHRpbWVsaW5lQ29udGV4dCwgdmlkZW9Db25maWcuaWQsIGZyYW1lVG9GcmVlemUsIHJlbGF0aXZlRnJvbV0pO1xuICBjb25zdCBuZXdTZXF1ZW5jZUNvbnRleHQgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgaWYgKCFzZXF1ZW5jZUNvbnRleHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2VDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2VxdWVuY2VDb250ZXh0LFxuICAgICAgY3VtdWxhdGVkRnJvbTogMFxuICAgIH07XG4gIH0sIFtzZXF1ZW5jZUNvbnRleHQsIGlzQWN0aXZlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdGltZWxpbmVWYWx1ZSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDgoU2VxdWVuY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogbmV3U2VxdWVuY2VDb250ZXh0LFxuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9TZXF1ZW5jZS50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g5IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVndWxhclNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHtcbiAgZnJvbSA9IDAsXG4gIGR1cmF0aW9uSW5GcmFtZXMgPSBJbmZpbml0eSxcbiAgY2hpbGRyZW4sXG4gIG5hbWUsXG4gIGhlaWdodCxcbiAgd2lkdGgsXG4gIHNob3dJblRpbWVsaW5lID0gdHJ1ZSxcbiAgX3JlbW90aW9uSW50ZXJuYWxMb29wRGlzcGxheTogbG9vcERpc3BsYXksXG4gIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrLFxuICBfcmVtb3Rpb25JbnRlcm5hbFByZW1vdW50RGlzcGxheTogcHJlbW91bnREaXNwbGF5LFxuICBfcmVtb3Rpb25JbnRlcm5hbFBvc3Rtb3VudERpc3BsYXk6IHBvc3Rtb3VudERpc3BsYXksXG4gIC4uLm90aGVyXG59LCByZWYpID0+IHtcbiAgY29uc3QgeyBsYXlvdXQgPSBcImFic29sdXRlLWZpbGxcIiB9ID0gb3RoZXI7XG4gIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZTYoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgcGFyZW50U2VxdWVuY2UgPSB1c2VDb250ZXh0MTMoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgeyByb290SWQgfSA9IHVzZUNvbnRleHQxMyhUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBjdW11bGF0ZWRGcm9tID0gcGFyZW50U2VxdWVuY2UgPyBwYXJlbnRTZXF1ZW5jZS5jdW11bGF0ZWRGcm9tICsgcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tIDogMDtcbiAgY29uc3Qgbm9uY2UgPSB1c2VOb25jZSgpO1xuICBpZiAobGF5b3V0ICE9PSBcImFic29sdXRlLWZpbGxcIiAmJiBsYXlvdXQgIT09IFwibm9uZVwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIGxheW91dCBwcm9wIG9mIDxTZXF1ZW5jZSAvPiBleHBlY3RzIGVpdGhlciBcImFic29sdXRlLWZpbGxcIiBvciBcIm5vbmVcIiwgYnV0IHlvdSBwYXNzZWQ6ICR7bGF5b3V0fWApO1xuICB9XG4gIGlmIChsYXlvdXQgPT09IFwibm9uZVwiICYmIHR5cGVvZiBvdGhlci5zdHlsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIGxheW91dD1cIm5vbmVcIiwgeW91IG1heSBub3QgcGFzcyBhIHN0eWxlLicpO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgdG8gZHVyYXRpb25JbkZyYW1lcyBhbiBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uSW5GcmFtZXN9LCBidXQgaXQgbXVzdCBiZSBhIG51bWJlci5gKTtcbiAgfVxuICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZHVyYXRpb25JbkZyYW1lcyBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyb20gIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgcGFzc2VkIHRvIHRoZSBcImZyb21cIiBwcm9wcyBvZiB5b3VyIDxTZXF1ZW5jZT4gYW4gYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBmcm9tfSwgYnV0IGl0IG11c3QgYmUgYSBudW1iZXIuYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJvbSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJmcm9tXCIgcHJvcCBvZiBhIHNlcXVlbmNlIG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZnJvbX0uYCk7XG4gIH1cbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZUR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2UgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzIC0gZnJvbSwgZHVyYXRpb25JbkZyYW1lcykgOiBkdXJhdGlvbkluRnJhbWVzO1xuICBjb25zdCBhY3R1YWxEdXJhdGlvbkluRnJhbWVzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcyAtIGZyb20sIHBhcmVudFNlcXVlbmNlRHVyYXRpb24pKTtcbiAgY29uc3QgeyByZWdpc3RlclNlcXVlbmNlLCB1bnJlZ2lzdGVyU2VxdWVuY2UgfSA9IHVzZUNvbnRleHQxMyhTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCB7IGhpZGRlbiB9ID0gdXNlQ29udGV4dDEzKFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQpO1xuICBjb25zdCBwcmVtb3VudGluZyA9IHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIHBhcmVudFNlcXVlbmNlPy5wcmVtb3VudGluZyB8fCBCb29sZWFuKG90aGVyLl9yZW1vdGlvbkludGVybmFsSXNQcmVtb3VudGluZyk7XG4gIH0sIFtvdGhlci5fcmVtb3Rpb25JbnRlcm5hbElzUHJlbW91bnRpbmcsIHBhcmVudFNlcXVlbmNlPy5wcmVtb3VudGluZ10pO1xuICBjb25zdCBwb3N0bW91bnRpbmcgPSB1c2VNZW1vMTAoKCkgPT4ge1xuICAgIHJldHVybiBwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nIHx8IEJvb2xlYW4ob3RoZXIuX3JlbW90aW9uSW50ZXJuYWxJc1Bvc3Rtb3VudGluZyk7XG4gIH0sIFtvdGhlci5fcmVtb3Rpb25JbnRlcm5hbElzUG9zdG1vdW50aW5nLCBwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1bXVsYXRlZEZyb20sXG4gICAgICByZWxhdGl2ZUZyb206IGZyb20sXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgICAgcGFyZW50RnJvbTogcGFyZW50U2VxdWVuY2U/LnJlbGF0aXZlRnJvbSA/PyAwLFxuICAgICAgaWQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/PyBwYXJlbnRTZXF1ZW5jZT8uaGVpZ2h0ID8/IG51bGwsXG4gICAgICB3aWR0aDogd2lkdGggPz8gcGFyZW50U2VxdWVuY2U/LndpZHRoID8/IG51bGwsXG4gICAgICBwcmVtb3VudGluZyxcbiAgICAgIHBvc3Rtb3VudGluZyxcbiAgICAgIHByZW1vdW50RGlzcGxheTogcHJlbW91bnREaXNwbGF5ID8/IG51bGwsXG4gICAgICBwb3N0bW91bnREaXNwbGF5OiBwb3N0bW91bnREaXNwbGF5ID8/IG51bGxcbiAgICB9O1xuICB9LCBbXG4gICAgY3VtdWxhdGVkRnJvbSxcbiAgICBmcm9tLFxuICAgIGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgcGFyZW50U2VxdWVuY2UsXG4gICAgaWQsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIHByZW1vdW50aW5nLFxuICAgIHBvc3Rtb3VudGluZyxcbiAgICBwcmVtb3VudERpc3BsYXksXG4gICAgcG9zdG1vdW50RGlzcGxheVxuICBdKTtcbiAgY29uc3QgdGltZWxpbmVDbGlwTmFtZSA9IHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIG5hbWUgPz8gXCJcIjtcbiAgfSwgW25hbWVdKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAoIWVudi5pc1N0dWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclNlcXVlbmNlKHtcbiAgICAgIGZyb20sXG4gICAgICBkdXJhdGlvbjogYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGlkLFxuICAgICAgZGlzcGxheU5hbWU6IHRpbWVsaW5lQ2xpcE5hbWUsXG4gICAgICBwYXJlbnQ6IHBhcmVudFNlcXVlbmNlPy5pZCA/PyBudWxsLFxuICAgICAgdHlwZTogXCJzZXF1ZW5jZVwiLFxuICAgICAgcm9vdElkLFxuICAgICAgc2hvd0luVGltZWxpbmUsXG4gICAgICBub25jZSxcbiAgICAgIGxvb3BEaXNwbGF5LFxuICAgICAgc3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgICBwcmVtb3VudERpc3BsYXk6IHByZW1vdW50RGlzcGxheSA/PyBudWxsLFxuICAgICAgcG9zdG1vdW50RGlzcGxheTogcG9zdG1vdW50RGlzcGxheSA/PyBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZShpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgaWQsXG4gICAgbmFtZSxcbiAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgIHRpbWVsaW5lQ2xpcE5hbWUsXG4gICAgdW5yZWdpc3RlclNlcXVlbmNlLFxuICAgIHBhcmVudFNlcXVlbmNlPy5pZCxcbiAgICBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgIHJvb3RJZCxcbiAgICBmcm9tLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIG5vbmNlLFxuICAgIGxvb3BEaXNwbGF5LFxuICAgIHN0YWNrLFxuICAgIHByZW1vdW50RGlzcGxheSxcbiAgICBwb3N0bW91bnREaXNwbGF5LFxuICAgIGVudi5pc1N0dWRpb1xuICBdKTtcbiAgY29uc3QgZW5kVGhyZXNob2xkID0gTWF0aC5jZWlsKGN1bXVsYXRlZEZyb20gKyBmcm9tICsgZHVyYXRpb25JbkZyYW1lcyAtIDEpO1xuICBjb25zdCBjb250ZW50ID0gYWJzb2x1dGVGcmFtZSA8IGN1bXVsYXRlZEZyb20gKyBmcm9tID8gbnVsbCA6IGFic29sdXRlRnJhbWUgPiBlbmRUaHJlc2hvbGQgPyBudWxsIDogY2hpbGRyZW47XG4gIGNvbnN0IHN0eWxlSWZUaGVyZSA9IG90aGVyLmxheW91dCA9PT0gXCJub25lXCIgPyB1bmRlZmluZWQgOiBvdGhlci5zdHlsZTtcbiAgY29uc3QgZGVmYXVsdFN0eWxlID0gdXNlTWVtbzEwKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmxleERpcmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgLi4ud2lkdGggPyB7IHdpZHRoIH0gOiB7fSxcbiAgICAgIC4uLmhlaWdodCA/IHsgaGVpZ2h0IH0gOiB7fSxcbiAgICAgIC4uLnN0eWxlSWZUaGVyZSA/PyB7fVxuICAgIH07XG4gIH0sIFtoZWlnaHQsIHN0eWxlSWZUaGVyZSwgd2lkdGhdKTtcbiAgaWYgKHJlZiAhPT0gbnVsbCAmJiBsYXlvdXQgPT09IFwibm9uZVwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXQgaXMgbm90IHN1cHBvcnRlZCB0byBwYXNzIGJvdGggYSBgcmVmYCBhbmQgYGxheW91dD1cIm5vbmVcImAgdG8gPFNlcXVlbmNlIC8+LicpO1xuICB9XG4gIGNvbnN0IGlzU2VxdWVuY2VIaWRkZW4gPSBoaWRkZW5baWRdID8/IGZhbHNlO1xuICBpZiAoaXNTZXF1ZW5jZUhpZGRlbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OShTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuOiBjb250ZW50ID09PSBudWxsID8gbnVsbCA6IG90aGVyLmxheW91dCA9PT0gXCJub25lXCIgPyBjb250ZW50IDogLyogQF9fUFVSRV9fICovIGpzeDkoQWJzb2x1dGVGaWxsLCB7XG4gICAgICByZWYsXG4gICAgICBzdHlsZTogZGVmYXVsdFN0eWxlLFxuICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbjogY29udGVudFxuICAgIH0pXG4gIH0pO1xufTtcbnZhciBSZWd1bGFyU2VxdWVuY2UgPSBmb3J3YXJkUmVmMihSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFByZW1vdW50ZWRQb3N0bW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgaWYgKHByb3BzLmxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2A8U2VxdWVuY2U+YCB3aXRoIGBwcmVtb3VudEZvcmAgYW5kIGBwb3N0bW91bnRGb3JgIHByb3BzIGRvZXMgbm90IHN1cHBvcnQgbGF5b3V0PVwibm9uZVwiJyk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHN0eWxlOiBwYXNzZWRTdHlsZSxcbiAgICBmcm9tID0gMCxcbiAgICBkdXJhdGlvbkluRnJhbWVzID0gSW5maW5pdHksXG4gICAgcHJlbW91bnRGb3IgPSAwLFxuICAgIHBvc3Rtb3VudEZvciA9IDAsXG4gICAgc3R5bGVXaGlsZVByZW1vdW50ZWQsXG4gICAgc3R5bGVXaGlsZVBvc3Rtb3VudGVkLFxuICAgIC4uLm90aGVyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBlbmRUaHJlc2hvbGQgPSBNYXRoLmNlaWwoZnJvbSArIGR1cmF0aW9uSW5GcmFtZXMgLSAxKTtcbiAgY29uc3QgcHJlbW91bnRpbmdBY3RpdmUgPSBmcmFtZSA8IGZyb20gJiYgZnJhbWUgPj0gZnJvbSAtIHByZW1vdW50Rm9yO1xuICBjb25zdCBwb3N0bW91bnRpbmdBY3RpdmUgPSBmcmFtZSA+IGVuZFRocmVzaG9sZCAmJiBmcmFtZSA8PSBlbmRUaHJlc2hvbGQgKyBwb3N0bW91bnRGb3I7XG4gIGNvbnN0IGZyZWV6ZUZyYW1lID0gcHJlbW91bnRpbmdBY3RpdmUgPyBmcm9tIDogcG9zdG1vdW50aW5nQWN0aXZlID8gZnJvbSArIGR1cmF0aW9uSW5GcmFtZXMgLSAxIDogMDtcbiAgY29uc3QgaXNGcmVlemluZ0FjdGl2ZSA9IHByZW1vdW50aW5nQWN0aXZlIHx8IHBvc3Rtb3VudGluZ0FjdGl2ZTtcbiAgY29uc3Qgc3R5bGUgPSB1c2VNZW1vMTAoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXNzZWRTdHlsZSxcbiAgICAgIG9wYWNpdHk6IHByZW1vdW50aW5nQWN0aXZlIHx8IHBvc3Rtb3VudGluZ0FjdGl2ZSA/IDAgOiAxLFxuICAgICAgcG9pbnRlckV2ZW50czogcHJlbW91bnRpbmdBY3RpdmUgfHwgcG9zdG1vdW50aW5nQWN0aXZlID8gXCJub25lXCIgOiBwYXNzZWRTdHlsZT8ucG9pbnRlckV2ZW50cyA/PyB1bmRlZmluZWQsXG4gICAgICAuLi5wcmVtb3VudGluZ0FjdGl2ZSA/IHN0eWxlV2hpbGVQcmVtb3VudGVkIDoge30sXG4gICAgICAuLi5wb3N0bW91bnRpbmdBY3RpdmUgPyBzdHlsZVdoaWxlUG9zdG1vdW50ZWQgOiB7fVxuICAgIH07XG4gIH0sIFtcbiAgICBwYXNzZWRTdHlsZSxcbiAgICBwcmVtb3VudGluZ0FjdGl2ZSxcbiAgICBwb3N0bW91bnRpbmdBY3RpdmUsXG4gICAgc3R5bGVXaGlsZVByZW1vdW50ZWQsXG4gICAgc3R5bGVXaGlsZVBvc3Rtb3VudGVkXG4gIF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDkoRnJlZXplLCB7XG4gICAgZnJhbWU6IGZyZWV6ZUZyYW1lLFxuICAgIGFjdGl2ZTogaXNGcmVlemluZ0FjdGl2ZSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDkoU2VxdWVuY2UsIHtcbiAgICAgIHJlZixcbiAgICAgIGZyb20sXG4gICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgc3R5bGUsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbFByZW1vdW50RGlzcGxheTogcHJlbW91bnRGb3IsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbFBvc3Rtb3VudERpc3BsYXk6IHBvc3Rtb3VudEZvcixcbiAgICAgIF9yZW1vdGlvbkludGVybmFsSXNQcmVtb3VudGluZzogcHJlbW91bnRpbmdBY3RpdmUsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbElzUG9zdG1vdW50aW5nOiBwb3N0bW91bnRpbmdBY3RpdmUsXG4gICAgICAuLi5vdGhlclByb3BzXG4gICAgfSlcbiAgfSk7XG59O1xudmFyIFByZW1vdW50ZWRQb3N0bW91bnRlZFNlcXVlbmNlID0gZm9yd2FyZFJlZjIoUHJlbW91bnRlZFBvc3Rtb3VudGVkU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBpZiAocHJvcHMubGF5b3V0ICE9PSBcIm5vbmVcIiAmJiAhZW52LmlzUmVuZGVyaW5nKSB7XG4gICAgaWYgKHByb3BzLnByZW1vdW50Rm9yIHx8IHByb3BzLnBvc3Rtb3VudEZvcikge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g5KFByZW1vdW50ZWRQb3N0bW91bnRlZFNlcXVlbmNlLCB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWZcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDkoUmVndWxhclNlcXVlbmNlLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgcmVmXG4gIH0pO1xufTtcbnZhciBTZXF1ZW5jZSA9IGZvcndhcmRSZWYyKFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9BbmltYXRlZEltYWdlLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMyxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTQsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3QyLFxuICB1c2VSZWYgYXMgdXNlUmVmNCxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGU3XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvY2FudmFzLnRzeFxuaW1wb3J0IFJlYWN0MTEsIHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s1LCB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUzLCB1c2VSZWYgYXMgdXNlUmVmMyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDEwIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgY2FsY0FyZ3MgPSAoZml0LCBmcmFtZVNpemUsIGNhbnZhc1NpemUpID0+IHtcbiAgc3dpdGNoIChmaXQpIHtcbiAgICBjYXNlIFwiZmlsbFwiOiB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmcmFtZVNpemUud2lkdGgsXG4gICAgICAgIGZyYW1lU2l6ZS5oZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgIGNhbnZhc1NpemUuaGVpZ2h0XG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwiY29udGFpblwiOiB7XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKGNhbnZhc1NpemUud2lkdGggLyBmcmFtZVNpemUud2lkdGgsIGNhbnZhc1NpemUuaGVpZ2h0IC8gZnJhbWVTaXplLmhlaWdodCk7XG4gICAgICBjb25zdCBjZW50ZXJYID0gKGNhbnZhc1NpemUud2lkdGggLSBmcmFtZVNpemUud2lkdGggKiByYXRpbykgLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IChjYW52YXNTaXplLmhlaWdodCAtIGZyYW1lU2l6ZS5oZWlnaHQgKiByYXRpbykgLyAyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZnJhbWVTaXplLndpZHRoLFxuICAgICAgICBmcmFtZVNpemUuaGVpZ2h0LFxuICAgICAgICBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZLFxuICAgICAgICBmcmFtZVNpemUud2lkdGggKiByYXRpbyxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCAqIHJhdGlvXG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwiY292ZXJcIjoge1xuICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1heChjYW52YXNTaXplLndpZHRoIC8gZnJhbWVTaXplLndpZHRoLCBjYW52YXNTaXplLmhlaWdodCAvIGZyYW1lU2l6ZS5oZWlnaHQpO1xuICAgICAgY29uc3QgY2VudGVyWCA9IChjYW52YXNTaXplLndpZHRoIC0gZnJhbWVTaXplLndpZHRoICogcmF0aW8pIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSAoY2FudmFzU2l6ZS5oZWlnaHQgLSBmcmFtZVNpemUuaGVpZ2h0ICogcmF0aW8pIC8gMjtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCxcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgZnJhbWVTaXplLndpZHRoICogcmF0aW8sXG4gICAgICAgIGZyYW1lU2l6ZS5oZWlnaHQgKiByYXRpb1xuICAgICAgXTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZml0OiBcIiArIGZpdCk7XG4gIH1cbn07XG52YXIgQ2FudmFzUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHsgd2lkdGgsIGhlaWdodCwgZml0LCBjbGFzc05hbWUsIHN0eWxlIH0sIHJlZikgPT4ge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWYzKG51bGwpO1xuICBjb25zdCBkcmF3ID0gdXNlQ2FsbGJhY2s1KChpbWFnZURhdGEpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IHdpZHRoID8/IGltYWdlRGF0YS5kaXNwbGF5V2lkdGg7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ID8/IGltYWdlRGF0YS5kaXNwbGF5SGVpZ2h0O1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgcmVmIGlzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IGNhbnZhc1JlZi5jdXJyZW50Py5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgMmQgY29udGV4dFwiKTtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlRGF0YSwgLi4uY2FsY0FyZ3MoZml0LCB7XG4gICAgICBoZWlnaHQ6IGltYWdlRGF0YS5kaXNwbGF5SGVpZ2h0LFxuICAgICAgd2lkdGg6IGltYWdlRGF0YS5kaXNwbGF5V2lkdGhcbiAgICB9LCB7XG4gICAgICB3aWR0aDogY2FudmFzV2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgIH0pKTtcbiAgfSwgW2ZpdCwgaGVpZ2h0LCB3aWR0aF0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlMyhyZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhdyxcbiAgICAgIGdldENhbnZhczogKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZiBpcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgIH0sXG4gICAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXNSZWYuY3VycmVudD8uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgMmQgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoLCBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtkcmF3XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTAoXCJjYW52YXNcIiwge1xuICAgIHJlZjogY2FudmFzUmVmLFxuICAgIGNsYXNzTmFtZSxcbiAgICBzdHlsZVxuICB9KTtcbn07XG52YXIgQ2FudmFzID0gUmVhY3QxMS5mb3J3YXJkUmVmKENhbnZhc1JlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9kZWNvZGUtaW1hZ2UudHNcbnZhciBDQUNIRV9TSVpFID0gNTtcbnZhciBnZXRBY3R1YWxUaW1lID0gKHtcbiAgbG9vcEJlaGF2aW9yLFxuICBkdXJhdGlvbkZvdW5kLFxuICB0aW1lSW5TZWNcbn0pID0+IHtcbiAgcmV0dXJuIGxvb3BCZWhhdmlvciA9PT0gXCJsb29wXCIgPyBkdXJhdGlvbkZvdW5kID8gdGltZUluU2VjICUgZHVyYXRpb25Gb3VuZCA6IHRpbWVJblNlYyA6IE1hdGgubWluKHRpbWVJblNlYywgZHVyYXRpb25Gb3VuZCB8fCBJbmZpbml0eSk7XG59O1xudmFyIGRlY29kZUltYWdlID0gYXN5bmMgKHtcbiAgcmVzb2x2ZWRTcmMsXG4gIHNpZ25hbCxcbiAgY3VycmVudFRpbWUsXG4gIGluaXRpYWxMb29wQmVoYXZpb3Jcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBJbWFnZURlY29kZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgV2ViQ29kZWNzIEltYWdlRGVjb2RlciBBUEkuXCIpO1xuICB9XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHJlc29sdmVkU3JjLCB7IHNpZ25hbCB9KTtcbiAgY29uc3QgeyBib2R5IH0gPSByZXM7XG4gIGlmICghYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCBubyBib2R5XCIpO1xuICB9XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgSW1hZ2VEZWNvZGVyKHtcbiAgICBkYXRhOiBib2R5LFxuICAgIHR5cGU6IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSB8fCBcImltYWdlL2dpZlwiXG4gIH0pO1xuICBhd2FpdCBkZWNvZGVyLmNvbXBsZXRlZDtcbiAgY29uc3QgeyBzZWxlY3RlZFRyYWNrIH0gPSBkZWNvZGVyLnRyYWNrcztcbiAgaWYgKCFzZWxlY3RlZFRyYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2VsZWN0ZWQgdHJhY2tcIik7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSBbXTtcbiAgbGV0IGR1cmF0aW9uRm91bmQgPSBudWxsO1xuICBjb25zdCBnZXRGcmFtZUJ5SW5kZXggPSBhc3luYyAoZnJhbWVJbmRleCkgPT4ge1xuICAgIGNvbnN0IGZvdW5kSW5DYWNoZSA9IGNhY2hlLmZpbmQoKGMpID0+IGMuZnJhbWVJbmRleCA9PT0gZnJhbWVJbmRleCk7XG4gICAgaWYgKGZvdW5kSW5DYWNoZSAmJiBmb3VuZEluQ2FjaGUuZnJhbWUpIHtcbiAgICAgIHJldHVybiBmb3VuZEluQ2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lID0gYXdhaXQgZGVjb2Rlci5kZWNvZGUoe1xuICAgICAgZnJhbWVJbmRleCxcbiAgICAgIGNvbXBsZXRlRnJhbWVzT25seTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChmb3VuZEluQ2FjaGUpIHtcbiAgICAgIGZvdW5kSW5DYWNoZS5mcmFtZSA9IGZyYW1lLmltYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5wdXNoKHtcbiAgICAgICAgZnJhbWU6IGZyYW1lLmltYWdlLFxuICAgICAgICBmcmFtZUluZGV4LFxuICAgICAgICB0aW1lSW5TZWNvbmRzOiBmcmFtZS5pbWFnZS50aW1lc3RhbXAgLyAxZTZcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZnJhbWU6IGZyYW1lLmltYWdlLFxuICAgICAgZnJhbWVJbmRleCxcbiAgICAgIHRpbWVJblNlY29uZHM6IGZyYW1lLmltYWdlLnRpbWVzdGFtcCAvIDFlNlxuICAgIH07XG4gIH07XG4gIGNvbnN0IGNsZWFyQ2FjaGUgPSAoY2xvc2VUb1RpbWVJblNlYykgPT4ge1xuICAgIGNvbnN0IGl0ZW1zSW5DYWNoZSA9IGNhY2hlLmZpbHRlcigoYykgPT4gYy5mcmFtZSk7XG4gICAgY29uc3Qgc29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWUgPSBpdGVtc0luQ2FjaGUuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyhhLnRpbWVJblNlY29uZHMgLSBjbG9zZVRvVGltZUluU2VjKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoYi50aW1lSW5TZWNvbmRzIC0gY2xvc2VUb1RpbWVJblNlYyk7XG4gICAgICByZXR1cm4gYURpZmYgLSBiRGlmZjtcbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDtpIDwgc29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpIDwgQ0FDSEVfU0laRSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW0gPSBzb3J0QnlDbG9zZXN0VG9DdXJyZW50VGltZVtpXTtcbiAgICAgIGl0ZW0uZnJhbWUgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlciA9IGFzeW5jICh7XG4gICAgdGltZUluU2VjLFxuICAgIGxvb3BCZWhhdmlvclxuICB9KSA9PiB7XG4gICAgY29uc3QgYWN0dWFsVGltZUluU2VjID0gZ2V0QWN0dWFsVGltZSh7XG4gICAgICBkdXJhdGlvbkZvdW5kLFxuICAgICAgbG9vcEJlaGF2aW9yLFxuICAgICAgdGltZUluU2VjXG4gICAgfSk7XG4gICAgY29uc3QgZnJhbWVzQmVmb3JlID0gY2FjaGUuZmlsdGVyKChjKSA9PiBjLnRpbWVJblNlY29uZHMgPD0gYWN0dWFsVGltZUluU2VjKTtcbiAgICBjb25zdCBiaWdnZXN0SW5kZXggPSBmcmFtZXNCZWZvcmUubWFwKChjKSA9PiBjLmZyYW1lSW5kZXgpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYiksIDApO1xuICAgIGxldCBpID0gYmlnZ2VzdEluZGV4O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBmID0gYXdhaXQgZ2V0RnJhbWVCeUluZGV4KGkpO1xuICAgICAgaSsrO1xuICAgICAgaWYgKCFmLmZyYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZyYW1lIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFmLmZyYW1lLmR1cmF0aW9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVHJhY2suZnJhbWVDb3VudCAmJiBkdXJhdGlvbkZvdW5kID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gKGYuZnJhbWUudGltZXN0YW1wICsgZi5mcmFtZS5kdXJhdGlvbikgLyAxZTY7XG4gICAgICAgIGR1cmF0aW9uRm91bmQgPSBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChmLnRpbWVJblNlY29uZHMgPiBhY3R1YWxUaW1lSW5TZWMgfHwgaSA9PT0gc2VsZWN0ZWRUcmFjay5mcmFtZUNvdW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWRUcmFjay5mcmFtZUNvdW50IC0gYmlnZ2VzdEluZGV4IDwgMyAmJiBsb29wQmVoYXZpb3IgPT09IFwibG9vcFwiKSB7XG4gICAgICBhd2FpdCBnZXRGcmFtZUJ5SW5kZXgoMCk7XG4gICAgfVxuICAgIGNsZWFyQ2FjaGUoYWN0dWFsVGltZUluU2VjKTtcbiAgfTtcbiAgYXdhaXQgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlcih7XG4gICAgdGltZUluU2VjOiBjdXJyZW50VGltZSxcbiAgICBsb29wQmVoYXZpb3I6IGluaXRpYWxMb29wQmVoYXZpb3JcbiAgfSk7XG4gIGF3YWl0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIoe1xuICAgIHRpbWVJblNlYzogY3VycmVudFRpbWUsXG4gICAgbG9vcEJlaGF2aW9yOiBpbml0aWFsTG9vcEJlaGF2aW9yXG4gIH0pO1xuICBjb25zdCBnZXRGcmFtZSA9IGFzeW5jICh0aW1lSW5TZWMsIGxvb3BCZWhhdmlvcikgPT4ge1xuICAgIGlmIChkdXJhdGlvbkZvdW5kICE9PSBudWxsICYmIHRpbWVJblNlYyA+IGR1cmF0aW9uRm91bmQgJiYgbG9vcEJlaGF2aW9yID09PSBcImNsZWFyLWFmdGVyLWZpbmlzaFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsVGltZUluU2VjID0gZ2V0QWN0dWFsVGltZSh7XG4gICAgICBsb29wQmVoYXZpb3IsXG4gICAgICBkdXJhdGlvbkZvdW5kLFxuICAgICAgdGltZUluU2VjXG4gICAgfSk7XG4gICAgYXdhaXQgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlcih7IHRpbWVJblNlYzogYWN0dWFsVGltZUluU2VjLCBsb29wQmVoYXZpb3IgfSk7XG4gICAgY29uc3QgaXRlbXNJbkNhY2hlID0gY2FjaGUuZmlsdGVyKChjKSA9PiBjLmZyYW1lKTtcbiAgICBjb25zdCBjbG9zZXN0ID0gaXRlbXNJbkNhY2hlLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyhhLnRpbWVJblNlY29uZHMgLSBhY3R1YWxUaW1lSW5TZWMpO1xuICAgICAgY29uc3QgYkRpZmYgPSBNYXRoLmFicyhiLnRpbWVJblNlY29uZHMgLSBhY3R1YWxUaW1lSW5TZWMpO1xuICAgICAgcmV0dXJuIGFEaWZmIDwgYkRpZmYgPyBhIDogYjtcbiAgICB9KTtcbiAgICBpZiAoIWNsb3Nlc3QuZnJhbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZyYW1lIGZvdW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXRGcmFtZSxcbiAgICBmcmFtZUNvdW50OiBzZWxlY3RlZFRyYWNrLmZyYW1lQ291bnRcbiAgfTtcbn07XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9yZXNvbHZlLWltYWdlLXNvdXJjZS50c3hcbnZhciByZXNvbHZlQW5pbWF0ZWRJbWFnZVNvdXJjZSA9IChzcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHNyYywgd2luZG93Lm9yaWdpbikuaHJlZjtcbn07XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9BbmltYXRlZEltYWdlLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDExIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQW5pbWF0ZWRJbWFnZSA9IGZvcndhcmRSZWYzKCh7XG4gIHNyYyxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgb25FcnJvcixcbiAgbG9vcEJlaGF2aW9yID0gXCJsb29wXCIsXG4gIHBsYXliYWNrUmF0ZSA9IDEsXG4gIGZpdCA9IFwiZmlsbFwiLFxuICAuLi5wcm9wc1xufSwgY2FudmFzUmVmKSA9PiB7XG4gIGNvbnN0IG1vdW50U3RhdGUgPSB1c2VSZWY0KHsgaXNNb3VudGVkOiB0cnVlIH0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IG1vdW50U3RhdGU7XG4gICAgY3VycmVudC5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzb2x2ZWRTcmMgPSByZXNvbHZlQW5pbWF0ZWRJbWFnZVNvdXJjZShzcmMpO1xuICBjb25zdCBbaW1hZ2VEZWNvZGVyLCBzZXRJbWFnZURlY29kZXJdID0gdXNlU3RhdGU3KG51bGwpO1xuICBjb25zdCB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIgfSA9IHVzZURlbGF5UmVuZGVyKCk7XG4gIGNvbnN0IFtkZWNvZGVIYW5kbGVdID0gdXNlU3RhdGU3KCgpID0+IGRlbGF5UmVuZGVyMihgUmVuZGVyaW5nIDxBbmltYXRlZEltYWdlLz4gd2l0aCBzcmM9XCIke3Jlc29sdmVkU3JjfVwiYCkpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBmcmFtZSAvIHBsYXliYWNrUmF0ZSAvIGZwcztcbiAgY29uc3QgY3VycmVudFRpbWVSZWYgPSB1c2VSZWY0KGN1cnJlbnRUaW1lKTtcbiAgY3VycmVudFRpbWVSZWYuY3VycmVudCA9IGN1cnJlbnRUaW1lO1xuICBjb25zdCByZWYgPSB1c2VSZWY0KG51bGwpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNChjYW52YXNSZWYsICgpID0+IHtcbiAgICBjb25zdCBjID0gcmVmLmN1cnJlbnQ/LmdldENhbnZhcygpO1xuICAgIGlmICghYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZiBpcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSwgW10pO1xuICBjb25zdCBbaW5pdGlhbExvb3BCZWhhdmlvcl0gPSB1c2VTdGF0ZTcoKCkgPT4gbG9vcEJlaGF2aW9yKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7XG4gICAgZGVjb2RlSW1hZ2Uoe1xuICAgICAgcmVzb2x2ZWRTcmMsXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgY3VycmVudFRpbWU6IGN1cnJlbnRUaW1lUmVmLmN1cnJlbnQsXG4gICAgICBpbml0aWFsTG9vcEJlaGF2aW9yXG4gICAgfSkudGhlbigoZCkgPT4ge1xuICAgICAgc2V0SW1hZ2VEZWNvZGVyKGQpO1xuICAgICAgY29udGludWVSZW5kZXIyKGRlY29kZUhhbmRsZSk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICBjb250aW51ZVJlbmRlcjIoZGVjb2RlSGFuZGxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcj8uKGVycik7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihkZWNvZGVIYW5kbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuY2VsUmVuZGVyKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9O1xuICB9LCBbXG4gICAgcmVzb2x2ZWRTcmMsXG4gICAgZGVjb2RlSGFuZGxlLFxuICAgIG9uRXJyb3IsXG4gICAgaW5pdGlhbExvb3BCZWhhdmlvcixcbiAgICBjb250aW51ZVJlbmRlcjJcbiAgXSk7XG4gIHVzZUxheW91dEVmZmVjdDIoKCkgPT4ge1xuICAgIGlmICghaW1hZ2VEZWNvZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gZGVsYXlSZW5kZXIyKGBSZW5kZXJpbmcgZnJhbWUgYXQgJHtjdXJyZW50VGltZX0gb2YgPEFuaW1hdGVkSW1hZ2Ugc3JjPVwiJHtzcmN9XCIvPmApO1xuICAgIGltYWdlRGVjb2Rlci5nZXRGcmFtZShjdXJyZW50VGltZSwgbG9vcEJlaGF2aW9yKS50aGVuKCh2aWRlb0ZyYW1lKSA9PiB7XG4gICAgICBpZiAobW91bnRTdGF0ZS5jdXJyZW50LmlzTW91bnRlZCkge1xuICAgICAgICBpZiAodmlkZW9GcmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50Py5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZi5jdXJyZW50Py5kcmF3KHZpZGVvRnJhbWUuZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250aW51ZVJlbmRlcjIoZGVsYXkpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgY29udGludWVSZW5kZXIyKGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbFJlbmRlcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXG4gICAgY3VycmVudFRpbWUsXG4gICAgaW1hZ2VEZWNvZGVyLFxuICAgIGxvb3BCZWhhdmlvcixcbiAgICBvbkVycm9yLFxuICAgIHNyYyxcbiAgICBjb250aW51ZVJlbmRlcjIsXG4gICAgZGVsYXlSZW5kZXIyXG4gIF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDExKENhbnZhcywge1xuICAgIHJlZixcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZml0LFxuICAgIC4uLnByb3BzXG4gIH0pO1xufSk7XG4vLyBzcmMvQXJ0aWZhY3QudHN4XG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNCwgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDQsIHVzZVN0YXRlIGFzIHVzZVN0YXRlOSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvUmVuZGVyQXNzZXRNYW5hZ2VyLnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNSxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDMsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzExLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZThcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWFydGlmYWN0LnRzXG52YXIgdmFsaWRhdGVBcnRpZmFjdEZpbGVuYW1lID0gKGZpbGVuYW1lKSA9PiB7XG4gIGlmICh0eXBlb2YgZmlsZW5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJmaWxlbmFtZVwiIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBmaWxlbmFtZX1gKTtcbiAgfVxuICBpZiAoZmlsZW5hbWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBmaWxlbmFtZWAgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gIH1cbiAgaWYgKCFmaWxlbmFtZS5tYXRjaCgvXihbMC05YS16QS1aLSFfLionKCkvOiYkQD07Kyw/XSspL2cpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGZpbGVuYW1lYCBtdXN0IG1hdGNoIFwiL14oWzAtOWEtekEtWi0hXy4qXFwnKCkvOiYkQD07Kyw/XSspL2dcIi4gVXNlIGZvcndhcmQgc2xhc2hlcyBvbmx5LCBldmVuIG9uIFdpbmRvd3MuJyk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVDb250ZW50ID0gKGNvbnRlbnQpID0+IHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiICYmICEoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiY29udGVudFwiIG11c3QgYmUgYSBzdHJpbmcgb3IgVWludDhBcnJheSwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGNvbnRlbnR9YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiICYmIGNvbnRlbnQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBjb250ZW50YCBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZVJlbmRlckFzc2V0ID0gKGFydGlmYWN0KSA9PiB7XG4gIGlmIChhcnRpZmFjdC50eXBlICE9PSBcImFydGlmYWN0XCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFsaWRhdGVBcnRpZmFjdEZpbGVuYW1lKGFydGlmYWN0LmZpbGVuYW1lKTtcbiAgaWYgKGFydGlmYWN0LmNvbnRlbnRUeXBlID09PSBcInRodW1ibmFpbFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhbGlkYXRlQ29udGVudChhcnRpZmFjdC5jb250ZW50KTtcbn07XG5cbi8vIHNyYy9SZW5kZXJBc3NldE1hbmFnZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZW5kZXJBc3NldE1hbmFnZXIgPSBjcmVhdGVDb250ZXh0MTIoe1xuICByZWdpc3RlclJlbmRlckFzc2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQ6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHJlbmRlckFzc2V0czogW11cbn0pO1xudmFyIFJlbmRlckFzc2V0TWFuYWdlclByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGNvbGxlY3RBc3NldHMgfSkgPT4ge1xuICBjb25zdCBbcmVuZGVyQXNzZXRzLCBzZXRSZW5kZXJBc3NldHNdID0gdXNlU3RhdGU4KFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJSZW5kZXJBc3NldCA9IHVzZUNhbGxiYWNrNigocmVuZGVyQXNzZXQpID0+IHtcbiAgICB2YWxpZGF0ZVJlbmRlckFzc2V0KHJlbmRlckFzc2V0KTtcbiAgICBzZXRSZW5kZXJBc3NldHMoKGFzc2V0cykgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5hc3NldHMsIHJlbmRlckFzc2V0XTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBpZiAoY29sbGVjdEFzc2V0cykge1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU1KGNvbGxlY3RBc3NldHMsICgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbGxlY3RBc3NldHM6ICgpID0+IHtcbiAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgc2V0UmVuZGVyQXNzZXRzKFtdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyQXNzZXRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtyZW5kZXJBc3NldHNdKTtcbiAgfVxuICBjb25zdCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgPSB1c2VDYWxsYmFjazYoKGlkKSA9PiB7XG4gICAgc2V0UmVuZGVyQXNzZXRzKChhc3N0cykgPT4ge1xuICAgICAgcmV0dXJuIGFzc3RzLmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUxheW91dEVmZmVjdDMoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fY29sbGVjdEFzc2V0cyA9ICgpID0+IHtcbiAgICAgICAgc2V0UmVuZGVyQXNzZXRzKFtdKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlckFzc2V0cztcbiAgICAgIH07XG4gICAgfVxuICB9LCBbcmVuZGVyQXNzZXRzXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8xMSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICByZW5kZXJBc3NldHNcbiAgICB9O1xuICB9LCBbcmVuZGVyQXNzZXRzLCByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxMihSZW5kZXJBc3NldE1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL0FydGlmYWN0LnRzeFxudmFyIEFydGlmYWN0VGh1bWJuYWlsID0gU3ltYm9sKFwiVGh1bWJuYWlsXCIpO1xudmFyIEFydGlmYWN0ID0gKHsgZmlsZW5hbWUsIGNvbnRlbnQsIGRvd25sb2FkQmVoYXZpb3IgfSkgPT4ge1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDE0KFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgW2lkXSA9IHVzZVN0YXRlOSgoKSA9PiB7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgfSk7XG4gIHVzZUxheW91dEVmZmVjdDQoKCkgPT4ge1xuICAgIGlmICghZW52LmlzUmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICAgIHR5cGU6IFwiYXJ0aWZhY3RcIixcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbnRlbnQ6IGJ0b2EobmV3IFRleHREZWNvZGVyKFwidXRmOFwiKS5kZWNvZGUoY29udGVudCkpLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImJpbmFyeVwiLFxuICAgICAgICBkb3dubG9hZEJlaGF2aW9yOiBkb3dubG9hZEJlaGF2aW9yID8/IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29udGVudCA9PT0gQXJ0aWZhY3RUaHVtYm5haWwpIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgICB0eXBlOiBcImFydGlmYWN0XCIsXG4gICAgICAgIGlkLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRodW1ibmFpbFwiLFxuICAgICAgICBkb3dubG9hZEJlaGF2aW9yOiBkb3dubG9hZEJlaGF2aW9yID8/IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgICAgdHlwZTogXCJhcnRpZmFjdFwiLFxuICAgICAgICBpZCxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGRvd25sb2FkQmVoYXZpb3I6IGRvd25sb2FkQmVoYXZpb3IgPz8gbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXR1cm4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgY29udGVudCxcbiAgICBlbnYuaXNSZW5kZXJpbmcsXG4gICAgZmlsZW5hbWUsXG4gICAgZnJhbWUsXG4gICAgaWQsXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgZG93bmxvYWRCZWhhdmlvclxuICBdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuQXJ0aWZhY3QuVGh1bWJuYWlsID0gQXJ0aWZhY3RUaHVtYm5haWw7XG4vLyBzcmMvYXVkaW8vQXVkaW8udHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY2LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazExLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYWJzb2x1dGUtc3JjLnRzXG52YXIgZ2V0QWJzb2x1dGVTcmMgPSAocmVsYXRpdmVTcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVTcmM7XG4gIH1cbiAgaWYgKHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSB8fCByZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSB8fCByZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIikgfHwgcmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlU3JjO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHJlbGF0aXZlU3JjLCB3aW5kb3cub3JpZ2luKS5ocmVmO1xufTtcblxuLy8gc3JjL2NhbGN1bGF0ZS1tZWRpYS1kdXJhdGlvbi50c1xudmFyIGNhbGN1bGF0ZU1lZGlhRHVyYXRpb24gPSAoe1xuICB0cmltQWZ0ZXIsXG4gIG1lZGlhRHVyYXRpb25JbkZyYW1lcyxcbiAgcGxheWJhY2tSYXRlLFxuICB0cmltQmVmb3JlXG59KSA9PiB7XG4gIGxldCBkdXJhdGlvbiA9IG1lZGlhRHVyYXRpb25JbkZyYW1lcztcbiAgaWYgKHR5cGVvZiB0cmltQWZ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiA9IHRyaW1BZnRlcjtcbiAgfVxuICBpZiAodHlwZW9mIHRyaW1CZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiAtPSB0cmltQmVmb3JlO1xuICB9XG4gIGNvbnN0IGFjdHVhbER1cmF0aW9uID0gZHVyYXRpb24gLyBwbGF5YmFja1JhdGU7XG4gIHJldHVybiBNYXRoLmZsb29yKGFjdHVhbER1cmF0aW9uKTtcbn07XG5cbi8vIHNyYy9sb29wL2luZGV4LnRzeFxuaW1wb3J0IFJlYWN0MTIsIHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTMsIHVzZU1lbW8gYXMgdXNlTWVtbzEyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBMb29wQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxMyhudWxsKTtcbnZhciB1c2VMb29wID0gKCkgPT4ge1xuICByZXR1cm4gUmVhY3QxMi51c2VDb250ZXh0KExvb3BDb250ZXh0KTtcbn07XG52YXIgTG9vcCA9ICh7IGR1cmF0aW9uSW5GcmFtZXMsIHRpbWVzID0gSW5maW5pdHksIGNoaWxkcmVuLCBuYW1lLCAuLi5wcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBEdXJhdGlvbiB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICBjb21wb25lbnQ6IFwib2YgdGhlIDxMb29wIC8+IGNvbXBvbmVudFwiLFxuICAgIGFsbG93RmxvYXRzOiB0cnVlXG4gIH0pO1xuICBpZiAodHlwZW9mIHRpbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBcInRpbWVzXCIgYW4gYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiB0aW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmICh0aW1lcyAhPT0gSW5maW5pdHkgJiYgdGltZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGltZXNcIiBwcm9wIG9mIGEgbG9vcCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHt0aW1lc30uYCk7XG4gIH1cbiAgaWYgKHRpbWVzIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRpbWVzXCIgcHJvcCBvZiBhIGxvb3AgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7dGltZXN9YCk7XG4gIH1cbiAgY29uc3QgbWF4VGltZXMgPSBNYXRoLmNlaWwoY29tcER1cmF0aW9uIC8gZHVyYXRpb25JbkZyYW1lcyk7XG4gIGNvbnN0IGFjdHVhbFRpbWVzID0gTWF0aC5taW4obWF4VGltZXMsIHRpbWVzKTtcbiAgY29uc3Qgc3R5bGUgPSBwcm9wcy5sYXlvdXQgPT09IFwibm9uZVwiID8gdW5kZWZpbmVkIDogcHJvcHMuc3R5bGU7XG4gIGNvbnN0IG1heEZyYW1lID0gZHVyYXRpb25JbkZyYW1lcyAqIChhY3R1YWxUaW1lcyAtIDEpO1xuICBjb25zdCBpdGVyYXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRGcmFtZSAvIGR1cmF0aW9uSW5GcmFtZXMpO1xuICBjb25zdCBzdGFydCA9IGl0ZXJhdGlvbiAqIGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGZyb20gPSBNYXRoLm1pbihzdGFydCwgbWF4RnJhbWUpO1xuICBjb25zdCBsb29wRGlzcGxheSA9IHVzZU1lbW8xMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mVGltZXM6IGFjdHVhbFRpbWVzLFxuICAgICAgc3RhcnRPZmZzZXQ6IC1mcm9tLFxuICAgICAgZHVyYXRpb25JbkZyYW1lc1xuICAgIH07XG4gIH0sIFthY3R1YWxUaW1lcywgZHVyYXRpb25JbkZyYW1lcywgZnJvbV0pO1xuICBjb25zdCBsb29wQ29udGV4dCA9IHVzZU1lbW8xMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZXJhdGlvbjogTWF0aC5mbG9vcihjdXJyZW50RnJhbWUgLyBkdXJhdGlvbkluRnJhbWVzKSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXNcbiAgICB9O1xuICB9LCBbY3VycmVudEZyYW1lLCBkdXJhdGlvbkluRnJhbWVzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTMoTG9vcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9vcENvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gxMyhTZXF1ZW5jZSwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGZyb20sXG4gICAgICBuYW1lOiBuYW1lID8/IFwiPExvb3A+XCIsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbExvb3BEaXNwbGF5OiBsb29wRGlzcGxheSxcbiAgICAgIGxheW91dDogcHJvcHMubGF5b3V0LFxuICAgICAgc3R5bGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0pO1xufTtcbkxvb3AudXNlTG9vcCA9IHVzZUxvb3A7XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTUgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3BsYXliYWNrLWxvZ2dpbmcudHNcbnZhciBwbGF5YmFja0xvZ2dpbmcgPSAoe1xuICBsb2dMZXZlbCxcbiAgdGFnLFxuICBtZXNzYWdlLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgdGFncyA9IFttb3VudFRpbWUgPyBEYXRlLm5vdygpIC0gbW91bnRUaW1lICsgXCJtcyBcIiA6IG51bGwsIHRhZ10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICBMb2cudHJhY2UoeyBsb2dMZXZlbCwgdGFnOiBudWxsIH0sIGBbJHt0YWdzfV1gLCBtZXNzYWdlKTtcbn07XG5cbi8vIHNyYy9wcmVmZXRjaC1zdGF0ZS50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE0LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE0IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUHJlbG9hZENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTQoe30pO1xudmFyIHByZWxvYWRzID0ge307XG52YXIgdXBkYXRlcnMgPSBbXTtcbnZhciBzZXRQcmVsb2FkcyA9ICh1cGRhdGVyKSA9PiB7XG4gIHByZWxvYWRzID0gdXBkYXRlcihwcmVsb2Fkcyk7XG4gIHVwZGF0ZXJzLmZvckVhY2goKHUpID0+IHUoKSk7XG59O1xudmFyIFByZWZldGNoUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtfcHJlbG9hZHMsIF9zZXRQcmVsb2Fkc10gPSB1c2VTdGF0ZTEwKCgpID0+IHByZWxvYWRzKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlckZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgX3NldFByZWxvYWRzKHByZWxvYWRzKTtcbiAgICB9O1xuICAgIHVwZGF0ZXJzLnB1c2godXBkYXRlckZ1bmN0aW9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdXBkYXRlcnMgPSB1cGRhdGVycy5maWx0ZXIoKHUpID0+IHUgIT09IHVwZGF0ZXJGdW5jdGlvbik7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE0KFByZWxvYWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IF9wcmVsb2FkcyxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xudmFyIHJlbW92ZUFuZEdldEhhc2hGcmFnbWVudCA9IChzcmMpID0+IHtcbiAgY29uc3QgaGFzaEluZGV4ID0gc3JjLmluZGV4T2YoXCIjXCIpO1xuICBpZiAoaGFzaEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBoYXNoSW5kZXg7XG59O1xudmFyIGdldFNyY1dpdGhvdXRIYXNoID0gKHNyYykgPT4ge1xuICBjb25zdCBoYXNoSW5kZXggPSByZW1vdmVBbmRHZXRIYXNoRnJhZ21lbnQoc3JjKTtcbiAgaWYgKGhhc2hJbmRleCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBzcmM7XG4gIH1cbiAgcmV0dXJuIHNyYy5zbGljZSgwLCBoYXNoSW5kZXgpO1xufTtcbnZhciB1c2VQcmVsb2FkID0gKHNyYykgPT4ge1xuICBjb25zdCBwcmVsb2FkczIgPSB1c2VDb250ZXh0MTUoUHJlbG9hZENvbnRleHQpO1xuICBjb25zdCBoYXNoRnJhZ21lbnRJbmRleCA9IHJlbW92ZUFuZEdldEhhc2hGcmFnbWVudChzcmMpO1xuICBjb25zdCB3aXRob3V0SGFzaEZyYWdtZW50ID0gZ2V0U3JjV2l0aG91dEhhc2goc3JjKTtcbiAgaWYgKCFwcmVsb2FkczJbd2l0aG91dEhhc2hGcmFnbWVudF0pIHtcbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIGlmIChoYXNoRnJhZ21lbnRJbmRleCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBwcmVsb2FkczJbd2l0aG91dEhhc2hGcmFnbWVudF0gKyBzcmMuc2xpY2UoaGFzaEZyYWdtZW50SW5kZXgpO1xuICB9XG4gIHJldHVybiBwcmVsb2FkczJbd2l0aG91dEhhc2hGcmFnbWVudF07XG59O1xudmFyIGJsb2JUb0Jhc2U2NCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZGF0YVVybCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICByZXNvbHZlKGRhdGFVcmwpO1xuICAgIH07XG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfTtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgfSk7XG59O1xudmFyIGdldEJsb2JGcm9tUmVhZGVyID0gYXN5bmMgKHtcbiAgcmVhZGVyLFxuICBjb250ZW50VHlwZSxcbiAgY29udGVudExlbmd0aCxcbiAgb25Qcm9ncmVzc1xufSkgPT4ge1xuICBsZXQgcmVjZWl2ZWRMZW5ndGggPSAwO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgIHJlY2VpdmVkTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgb25Qcm9ncmVzcyh7IGxvYWRlZEJ5dGVzOiByZWNlaXZlZExlbmd0aCwgdG90YWxCeXRlczogY29udGVudExlbmd0aCB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2h1bmtzQWxsID0gbmV3IFVpbnQ4QXJyYXkocmVjZWl2ZWRMZW5ndGgpO1xuICBsZXQgcG9zaXRpb24gPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNodW5rc0FsbC5zZXQoY2h1bmssIHBvc2l0aW9uKTtcbiAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtjaHVua3NBbGxdLCB7XG4gICAgdHlwZTogY29udGVudFR5cGUgPz8gdW5kZWZpbmVkXG4gIH0pO1xufTtcbnZhciBwcmVmZXRjaCA9IChzcmMsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgbWV0aG9kID0gb3B0aW9ucz8ubWV0aG9kID8/IFwiYmxvYi11cmxcIjtcbiAgY29uc3QgbG9nTGV2ZWwgPSBvcHRpb25zPy5sb2dMZXZlbCA/PyBcImluZm9cIjtcbiAgY29uc3Qgc3JjV2l0aG91dEhhc2ggPSBnZXRTcmNXaXRob3V0SGFzaChzcmMpO1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyZWU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSxcbiAgICAgIHdhaXRVbnRpbERvbmU6ICgpID0+IFByb21pc2UucmVzb2x2ZShzcmNXaXRob3V0SGFzaClcbiAgICB9O1xuICB9XG4gIExvZy52ZXJib3NlKHsgbG9nTGV2ZWwsIHRhZzogXCJwcmVmZXRjaFwiIH0sIGBTdGFydGluZyBwcmVmZXRjaCAke3NyY1dpdGhvdXRIYXNofWApO1xuICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgbGV0IG9iamVjdFVybCA9IG51bGw7XG4gIGxldCByZXNvbHZlID0gKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfTtcbiAgbGV0IHJlamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH07XG4gIGNvbnN0IHdhaXRVbnRpbERvbmUgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyO1xuICBsZXQgY2FuQmVBYm9ydGVkID0gdHJ1ZTtcbiAgZmV0Y2goc3JjV2l0aG91dEhhc2gsIHtcbiAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zPy5jcmVkZW50aWFscyA/PyB1bmRlZmluZWRcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgY2FuQmVBYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciwgc3RhdHVzID0gJHtyZXMuc3RhdHVzfWApO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJDb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8/IGhlYWRlckNvbnRlbnRUeXBlO1xuICAgIGNvbnN0IGhhc1Byb3BlckNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJ2aWRlby9cIikgfHwgY29udGVudFR5cGUuc3RhcnRzV2l0aChcImF1ZGlvL1wiKSB8fCBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKTtcbiAgICBpZiAoIWhhc1Byb3BlckNvbnRlbnRUeXBlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbGxlZCBwcmVmZXRjaCgpIG9uICR7c3JjV2l0aG91dEhhc2h9IHdoaWNoIHJldHVybmVkIGEgXCJDb250ZW50LVR5cGVcIiBvZiAke2hlYWRlckNvbnRlbnRUeXBlfS4gUHJlZmV0Y2hlZCBjb250ZW50IHNob3VsZCBoYXZlIGEgcHJvcGVyIGNvbnRlbnQgdHlwZSAodmlkZW8vLi4uIG9yIGF1ZGlvLy4uLikgb3IgYSBjb250ZW50VHlwZSBwYXNzZWQgdGhlIG9wdGlvbnMgb2YgcHJlZmV0Y2goKS4gT3RoZXJ3aXNlLCBwcmVmZXRjaGluZyB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IGluIGFsbCBicm93c2Vycy5gKTtcbiAgICB9XG4gICAgaWYgKCFyZXMuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIHJlc3BvbnNlIG9mICR7c3JjV2l0aG91dEhhc2h9IGhhcyBubyBib2R5YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICAgIHJldHVybiBnZXRCbG9iRnJvbVJlYWRlcih7XG4gICAgICByZWFkZXIsXG4gICAgICBjb250ZW50VHlwZTogb3B0aW9ucz8uY29udGVudFR5cGUgPz8gaGVhZGVyQ29udGVudFR5cGUgPz8gbnVsbCxcbiAgICAgIGNvbnRlbnRMZW5ndGg6IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpID8gcGFyc2VJbnQocmVzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIiksIDEwKSA6IG51bGwsXG4gICAgICBvblByb2dyZXNzOiBvcHRpb25zPy5vblByb2dyZXNzXG4gICAgfSk7XG4gIH0pLnRoZW4oKGJ1ZikgPT4ge1xuICAgIGlmICghYnVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbEJsb2IgPSBvcHRpb25zPy5jb250ZW50VHlwZSA/IG5ldyBCbG9iKFtidWZdLCB7IHR5cGU6IG9wdGlvbnMuY29udGVudFR5cGUgfSkgOiBidWY7XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgcmV0dXJuIGJsb2JUb0Jhc2U2NChhY3R1YWxCbG9iKTtcbiAgICB9XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYWN0dWFsQmxvYik7XG4gIH0pLnRoZW4oKHVybCkgPT4ge1xuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgbG9nTGV2ZWwsXG4gICAgICB0YWc6IFwicHJlZmV0Y2hcIixcbiAgICAgIG1lc3NhZ2U6IGBGaW5pc2hlZCBwcmVmZXRjaCAke3NyY1dpdGhvdXRIYXNofSB3aXRoIG1ldGhvZCAke21ldGhvZH1gLFxuICAgICAgbW91bnRUaW1lOiBudWxsXG4gICAgfSk7XG4gICAgb2JqZWN0VXJsID0gdXJsO1xuICAgIHNldFByZWxvYWRzKChwKSA9PiAoe1xuICAgICAgLi4ucCxcbiAgICAgIFtzcmNXaXRob3V0SGFzaF06IG9iamVjdFVybFxuICAgIH0pKTtcbiAgICByZXNvbHZlKG9iamVjdFVybCk7XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAoZXJyPy5tZXNzYWdlLmluY2x1ZGVzKFwiZnJlZSgpIGNhbGxlZFwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWplY3QoZXJyKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZnJlZTogKCkgPT4ge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIHRhZzogXCJwcmVmZXRjaFwiLFxuICAgICAgICBtZXNzYWdlOiBgRnJlZWluZyAke3NyY1dpdGhvdXRIYXNofWAsXG4gICAgICAgIG1vdW50VGltZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBpZiAob2JqZWN0VXJsKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiYmxvYi11cmxcIikge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVsb2FkcygocCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvcHkgPSB7IC4uLnAgfTtcbiAgICAgICAgICBkZWxldGUgY29weVtzcmNXaXRob3V0SGFzaF07XG4gICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2FuQmVBYm9ydGVkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKFwiZnJlZSgpIGNhbGxlZFwiKSk7XG4gICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB3YWl0VW50aWxEb25lOiAoKSA9PiB7XG4gICAgICByZXR1cm4gd2FpdFVudGlsRG9uZTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvdmFsaWRhdGUtbWVkaWEtcHJvcHMudHNcbnZhciB2YWxpZGF0ZU1lZGlhUHJvcHMgPSAocHJvcHMsIGNvbXBvbmVudCkgPT4ge1xuICBpZiAodHlwZW9mIHByb3BzLnZvbHVtZSAhPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcHJvcHMudm9sdW1lICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHByb3BzLnZvbHVtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHZvbHVtZSBvZiB0eXBlICR7dHlwZW9mIHByb3BzLnZvbHVtZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gVm9sdW1lIG11c3QgYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbiB3aXRoIHRoZSBzaWduYXR1cmUgJyhmcmFtZTogbnVtYmVyKSA9PiBudW1iZXInIHVuZGVmaW5lZC5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzLnZvbHVtZSA9PT0gXCJudW1iZXJcIiAmJiBwcm9wcy52b2x1bWUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgdm9sdW1lIGJlbG93IDAgdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gVm9sdW1lIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgIT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHBsYXliYWNrUmF0ZSBvZiB0eXBlICR7dHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gUGxheWJhY2sgcmF0ZSBtdXN0IGEgcmVhbCBudW1iZXIgb3IgdW5kZWZpbmVkLmApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlID09PSBcIm51bWJlclwiICYmIChpc05hTihwcm9wcy5wbGF5YmFja1JhdGUpIHx8ICFOdW1iZXIuaXNGaW5pdGUocHJvcHMucGxheWJhY2tSYXRlKSB8fCBwcm9wcy5wbGF5YmFja1JhdGUgPD0gMCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSBwbGF5YmFja1JhdGUgb2YgJHtwcm9wcy5wbGF5YmFja1JhdGV9IHRvIHlvdXIgPCR7Y29tcG9uZW50fSAvPiBjb21wb25lbnQuIFBsYXliYWNrIHJhdGUgbXVzdCBiZSBhIHJlYWwgbnVtYmVyIGFib3ZlIDAuYCk7XG4gIH1cbn07XG5cbi8vIHNyYy92YWxpZGF0ZS1zdGFydC1mcm9tLXByb3BzLnRzXG52YXIgdmFsaWRhdGVTdGFydEZyb21Qcm9wcyA9IChzdGFydEZyb20sIGVuZEF0KSA9PiB7XG4gIGlmICh0eXBlb2Ygc3RhcnRGcm9tICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGUgb2Ygc3RhcnRGcm9tIHByb3AgbXVzdCBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgdHlwZSAke3R5cGVvZiBzdGFydEZyb219LmApO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oc3RhcnRGcm9tKSB8fCBzdGFydEZyb20gPT09IEluZmluaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic3RhcnRGcm9tIHByb3AgY2FuIG5vdCBiZSBOYU4gb3IgSW5maW5pdHkuXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhcnRGcm9tIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhcnRGcm9tIG11c3QgYmUgZ3JlYXRlciB0aGFuIGVxdWFsIHRvIDAgaW5zdGVhZCBnb3QgJHtzdGFydEZyb219LmApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZSBvZiBlbmRBdCBwcm9wIG11c3QgYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IHR5cGUgJHt0eXBlb2YgZW5kQXR9LmApO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oZW5kQXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5kQXQgcHJvcCBjYW4gbm90IGJlIE5hTi5cIik7XG4gICAgfVxuICAgIGlmIChlbmRBdCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBlbmRBdCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLCBpbnN0ZWFkIGdvdCAke2VuZEF0fS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVuZEF0IDwgc3RhcnRGcm9tKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuZEF0IHByb3AgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnRGcm9tIHByb3AuXCIpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlVHJpbVByb3BzID0gKHRyaW1CZWZvcmUsIHRyaW1BZnRlcikgPT4ge1xuICBpZiAodHlwZW9mIHRyaW1CZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIHRyaW1CZWZvcmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGUgb2YgdHJpbUJlZm9yZSBwcm9wIG11c3QgYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IHR5cGUgJHt0eXBlb2YgdHJpbUJlZm9yZX0uYCk7XG4gICAgfVxuICAgIGlmIChpc05hTih0cmltQmVmb3JlKSB8fCB0cmltQmVmb3JlID09PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRyaW1CZWZvcmUgcHJvcCBjYW4gbm90IGJlIE5hTiBvciBJbmZpbml0eS5cIik7XG4gICAgfVxuICAgIGlmICh0cmltQmVmb3JlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHJpbUJlZm9yZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBlcXVhbCB0byAwIGluc3RlYWQgZ290ICR7dHJpbUJlZm9yZX0uYCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgdHJpbUFmdGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiB0cmltQWZ0ZXIgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGUgb2YgdHJpbUFmdGVyIHByb3AgbXVzdCBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgdHlwZSAke3R5cGVvZiB0cmltQWZ0ZXJ9LmApO1xuICAgIH1cbiAgICBpZiAoaXNOYU4odHJpbUFmdGVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRyaW1BZnRlciBwcm9wIGNhbiBub3QgYmUgTmFOLlwiKTtcbiAgICB9XG4gICAgaWYgKHRyaW1BZnRlciA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0cmltQWZ0ZXIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciwgaW5zdGVhZCBnb3QgJHt0cmltQWZ0ZXJ9LmApO1xuICAgIH1cbiAgfVxuICBpZiAodHJpbUFmdGVyIDw9IHRyaW1CZWZvcmUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidHJpbUFmdGVyIHByb3AgbXVzdCBiZSBncmVhdGVyIHRoYW4gdHJpbUJlZm9yZSBwcm9wLlwiKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZU1lZGlhVHJpbVByb3BzID0gKHtcbiAgc3RhcnRGcm9tLFxuICBlbmRBdCxcbiAgdHJpbUJlZm9yZSxcbiAgdHJpbUFmdGVyXG59KSA9PiB7XG4gIGlmICh0eXBlb2Ygc3RhcnRGcm9tICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB0cmltQmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgYm90aCBzdGFydEZyb20gYW5kIHRyaW1CZWZvcmUgcHJvcHMuIFVzZSB0cmltQmVmb3JlIGluc3RlYWQgYXMgc3RhcnRGcm9tIGlzIGRlcHJlY2F0ZWQuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRyaW1BZnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIGJvdGggZW5kQXQgYW5kIHRyaW1BZnRlciBwcm9wcy4gVXNlIHRyaW1BZnRlciBpbnN0ZWFkIGFzIGVuZEF0IGlzIGRlcHJlY2F0ZWQuXCIpO1xuICB9XG4gIGNvbnN0IGhhc05ld1Byb3BzID0gdHlwZW9mIHRyaW1CZWZvcmUgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHRyaW1BZnRlciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgY29uc3QgaGFzT2xkUHJvcHMgPSB0eXBlb2Ygc3RhcnRGcm9tICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKGhhc05ld1Byb3BzKSB7XG4gICAgdmFsaWRhdGVUcmltUHJvcHModHJpbUJlZm9yZSwgdHJpbUFmdGVyKTtcbiAgfSBlbHNlIGlmIChoYXNPbGRQcm9wcykge1xuICAgIHZhbGlkYXRlU3RhcnRGcm9tUHJvcHMoc3RhcnRGcm9tLCBlbmRBdCk7XG4gIH1cbn07XG52YXIgcmVzb2x2ZVRyaW1Qcm9wcyA9ICh7XG4gIHN0YXJ0RnJvbSxcbiAgZW5kQXQsXG4gIHRyaW1CZWZvcmUsXG4gIHRyaW1BZnRlclxufSkgPT4ge1xuICBjb25zdCB0cmltQmVmb3JlVmFsdWUgPSB0cmltQmVmb3JlID8/IHN0YXJ0RnJvbSA/PyB1bmRlZmluZWQ7XG4gIGNvbnN0IHRyaW1BZnRlclZhbHVlID0gdHJpbUFmdGVyID8/IGVuZEF0ID8/IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHsgdHJpbUJlZm9yZVZhbHVlLCB0cmltQWZ0ZXJWYWx1ZSB9O1xufTtcblxuLy8gc3JjL3ZpZGVvL2R1cmF0aW9uLXN0YXRlLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTUsIHVzZU1lbW8gYXMgdXNlTWVtbzEzLCB1c2VSZWR1Y2VyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBkdXJhdGlvblJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcImdvdC1kdXJhdGlvblwiOiB7XG4gICAgICBjb25zdCBhYnNvbHV0ZVNyYyA9IGdldEFic29sdXRlU3JjKGFjdGlvbi5zcmMpO1xuICAgICAgaWYgKHN0YXRlW2Fic29sdXRlU3JjXSA9PT0gYWN0aW9uLmR1cmF0aW9uSW5TZWNvbmRzKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbYWJzb2x1dGVTcmNdOiBhY3Rpb24uZHVyYXRpb25JblNlY29uZHNcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG52YXIgRHVyYXRpb25zQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNSh7XG4gIGR1cmF0aW9uczoge30sXG4gIHNldER1cmF0aW9uczogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbnRleHQgbWlzc2luZ1wiKTtcbiAgfVxufSk7XG52YXIgRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbZHVyYXRpb25zLCBzZXREdXJhdGlvbnNdID0gdXNlUmVkdWNlcihkdXJhdGlvblJlZHVjZXIsIHt9KTtcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vMTMoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkdXJhdGlvbnMsXG4gICAgICBzZXREdXJhdGlvbnNcbiAgICB9O1xuICB9LCBbZHVyYXRpb25zXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTUoRHVyYXRpb25zQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUHJldmlldy50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjQsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI1LFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTIsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTYsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzIxLFxuICB1c2VSZWYgYXMgdXNlUmVmMTIsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTVcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9nZXQtY3Jvc3Mtb3JpZ2luLXZhbHVlLnRzXG52YXIgZ2V0Q3Jvc3NPcmlnaW5WYWx1ZSA9ICh7XG4gIGNyb3NzT3JpZ2luLFxuICByZXF1ZXN0c1ZpZGVvRnJhbWVcbn0pID0+IHtcbiAgaWYgKGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgJiYgY3Jvc3NPcmlnaW4gIT09IG51bGwpIHtcbiAgICByZXR1cm4gY3Jvc3NPcmlnaW47XG4gIH1cbiAgaWYgKHJlcXVlc3RzVmlkZW9GcmFtZSkge1xuICAgIHJldHVybiBcImFub255bW91c1wiO1xuICB9XG4gIHJldHVybjtcbn07XG5cbi8vIHNyYy91c2UtYW1wbGlmaWNhdGlvbi50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTcsIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q1LCB1c2VSZWYgYXMgdXNlUmVmNyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYXVkaW8vc2hhcmVkLWF1ZGlvLXRhZ3MudHN4XG5pbXBvcnQgUmVhY3QxNSwge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNixcbiAgY3JlYXRlUmVmIGFzIGNyZWF0ZVJlZjIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNyxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTYsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzE1LFxuICB1c2VSZWYgYXMgdXNlUmVmNSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMVxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3BsYXktYW5kLWhhbmRsZS1ub3QtYWxsb3dlZC1lcnJvci50c1xudmFyIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IgPSAoe1xuICBtZWRpYVJlZixcbiAgbWVkaWFUeXBlLFxuICBvbkF1dG9QbGF5RXJyb3IsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWUsXG4gIHJlYXNvbixcbiAgaXNQbGF5ZXJcbn0pID0+IHtcbiAgY29uc3QgeyBjdXJyZW50IH0gPSBtZWRpYVJlZjtcbiAgaWYgKCFjdXJyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgbG9nTGV2ZWwsXG4gICAgdGFnOiBcInBsYXlcIixcbiAgICBtZXNzYWdlOiBgQXR0ZW1wdGluZyB0byBwbGF5ICR7Y3VycmVudC5zcmN9LiBSZWFzb246ICR7cmVhc29ufWAsXG4gICAgbW91bnRUaW1lXG4gIH0pO1xuICBjb25zdCBwcm9tID0gY3VycmVudC5wbGF5KCk7XG4gIGlmICghcHJvbS5jYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9tLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwicmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBjYWxsIHRvIHBhdXNlXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcIlRoZSBmZXRjaGluZyBwcm9jZXNzIGZvciB0aGUgbWVkaWEgcmVzb3VyY2Ugd2FzIGFib3J0ZWQgYnkgdGhlIHVzZXIgYWdlbnRcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwicmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBuZXcgbG9hZCByZXF1ZXN0XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcImJlY2F1c2UgdGhlIG1lZGlhIHdhcyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInVzZXIgZGlkbid0IGludGVyYWN0IHdpdGggdGhlIGRvY3VtZW50XCIpICYmIGN1cnJlbnQubXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coYENvdWxkIG5vdCBwbGF5ICR7bWVkaWFUeXBlfSBkdWUgdG8gZm9sbG93aW5nIGVycm9yOiBgLCBlcnIpO1xuICAgIGlmICghY3VycmVudC5tdXRlZCkge1xuICAgICAgaWYgKG9uQXV0b1BsYXlFcnJvcikge1xuICAgICAgICBvbkF1dG9QbGF5RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1lZGlhVHlwZSA9PT0gXCJ2aWRlb1wiICYmIGlzUGxheWVyKSB7XG4gICAgICAgIExvZy5pbmZvKHsgbG9nTGV2ZWwsIHRhZzogXCI8XCIgKyBtZWRpYVR5cGUgKyBcIj5cIiB9LCBgVGhlIHZpZGVvIHdpbGwgYmUgbXV0ZWQgYW5kIHdlJ2xsIHJldHJ5IHBsYXlpbmcgaXQuYCk7XG4gICAgICAgIExvZy5pbmZvKHsgbG9nTGV2ZWwsIHRhZzogXCI8XCIgKyBtZWRpYVR5cGUgKyBcIj5cIiB9LCBcIlVzZSBvbkF1dG9QbGF5RXJyb3IoKSB0byBoYW5kbGUgdGhpcyBlcnJvciB5b3Vyc2VsZi5cIik7XG4gICAgICAgIGN1cnJlbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICBjdXJyZW50LnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gc3JjL2F1ZGlvL3NoYXJlZC1lbGVtZW50LXNvdXJjZS1ub2RlLnRzXG52YXIgbWFrZVNoYXJlZEVsZW1lbnRTb3VyY2VOb2RlID0gKHtcbiAgYXVkaW9Db250ZXh0LFxuICByZWZcbn0pID0+IHtcbiAgbGV0IGNvbm5lY3RlZCA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgYXR0ZW1wdFRvQ29ubmVjdDogKCkgPT4ge1xuICAgICAgaWYgKCFjb25uZWN0ZWQgJiYgcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgbWVkaWFFbGVtZW50U291cmNlTm9kZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UocmVmLmN1cnJlbnQpO1xuICAgICAgICBjb25uZWN0ZWQgPSBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0OiAoKSA9PiB7XG4gICAgICBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdWRpbyBlbGVtZW50IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29ubmVjdGVkO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9hdWRpby91c2UtYXVkaW8tY29udGV4dC50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vMTQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB3YXJuZWQgPSBmYWxzZTtcbnZhciB3YXJuT25jZSA9IChsb2dMZXZlbCkgPT4ge1xuICBpZiAod2FybmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5lZCA9IHRydWU7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgTG9nLndhcm4oeyBsb2dMZXZlbCwgdGFnOiBudWxsIH0sIFwiQXVkaW9Db250ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuICB9XG59O1xudmFyIHVzZVNpbmdsZXRvbkF1ZGlvQ29udGV4dCA9IChsb2dMZXZlbCwgbGF0ZW5jeUhpbnQpID0+IHtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VNZW1vMTQoKCkgPT4ge1xuICAgIGlmIChlbnYuaXNSZW5kZXJpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2Fybk9uY2UobG9nTGV2ZWwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXVkaW9Db250ZXh0KHtcbiAgICAgIGxhdGVuY3lIaW50LFxuICAgICAgc2FtcGxlUmF0ZTogNDgwMDBcbiAgICB9KTtcbiAgfSwgW2xvZ0xldmVsLCBsYXRlbmN5SGludCwgZW52LmlzUmVuZGVyaW5nXSk7XG4gIHJldHVybiBhdWRpb0NvbnRleHQ7XG59O1xuXG4vLyBzcmMvYXVkaW8vc2hhcmVkLWF1ZGlvLXRhZ3MudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTYsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBFTVBUWV9BVURJTyA9IFwiZGF0YTphdWRpby9tcDM7YmFzZTY0LC8rTVl4QUFKY0FWOEFBZ0FBQm4vLy8vLy8rL2dRNUJBTUErRDRQZytCQVFCQUVBd0Q0UGcrRDRFQkFFQVFEQVBnKytoWUJILy8vaFVGUVZCVUZSRURRTkhtZi8vLy8vLy8rTVl4QlVHa0FHSU1BQUFBUC8yOVh0NmxVeEJUVVV6TGpFd01GVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVi8rTVl4RFVBQUFOSUFBQUFBRlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlwiO1xudmFyIGNvbXBhcmVQcm9wcyA9IChvYmoxLCBvYmoyKSA9PiB7XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqMSkuc29ydCgpO1xuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iajIpLnNvcnQoKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwO2kgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChrZXlzQVtpXSAhPT0ga2V5c0JbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iajFba2V5c0FbaV1dICE9PSBvYmoyW2tleXNCW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZGlkUHJvcENoYW5nZSA9IChrZXksIG5ld1Byb3AsIHByZXZQcm9wKSA9PiB7XG4gIGlmIChrZXkgPT09IFwic3JjXCIgJiYgIXByZXZQcm9wLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSAmJiAhbmV3UHJvcC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gbmV3IFVSTChwcmV2UHJvcCwgd2luZG93Lm9yaWdpbikudG9TdHJpbmcoKSAhPT0gbmV3IFVSTChuZXdQcm9wLCB3aW5kb3cub3JpZ2luKS50b1N0cmluZygpO1xuICB9XG4gIGlmIChwcmV2UHJvcCA9PT0gbmV3UHJvcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgU2hhcmVkQXVkaW9Db250ZXh0ID0gY3JlYXRlQ29udGV4dDE2KG51bGwpO1xudmFyIFNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIG51bWJlck9mQXVkaW9UYWdzLCBhdWRpb0xhdGVuY3lIaW50IH0pID0+IHtcbiAgY29uc3QgYXVkaW9zID0gdXNlUmVmNShbXSk7XG4gIGNvbnN0IFtpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3NdID0gdXNlU3RhdGUxMShudW1iZXJPZkF1ZGlvVGFncyk7XG4gIGlmIChudW1iZXJPZkF1ZGlvVGFncyAhPT0gaW5pdGlhbE51bWJlck9mQXVkaW9UYWdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiBzaGFyZWQgYXVkaW8gdGFncyBoYXMgY2hhbmdlZCBkeW5hbWljYWxseS4gT25jZSB5b3UgaGF2ZSBzZXQgdGhpcyBwcm9wZXJ0eSwgeW91IGNhbm5vdCBjaGFuZ2UgaXQgYWZ0ZXJ3YXJkcy5cIik7XG4gIH1cbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VTaW5nbGV0b25BdWRpb0NvbnRleHQobG9nTGV2ZWwsIGF1ZGlvTGF0ZW5jeUhpbnQpO1xuICBjb25zdCByZWZzID0gdXNlTWVtbzE1KCgpID0+IHtcbiAgICByZXR1cm4gbmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKHRydWUpLm1hcCgoKSA9PiB7XG4gICAgICBjb25zdCByZWYgPSBjcmVhdGVSZWYyKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgcmVmLFxuICAgICAgICBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlOiBhdWRpb0NvbnRleHQgPyBtYWtlU2hhcmVkRWxlbWVudFNvdXJjZU5vZGUoe1xuICAgICAgICAgIGF1ZGlvQ29udGV4dCxcbiAgICAgICAgICByZWZcbiAgICAgICAgfSkgOiBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbYXVkaW9Db250ZXh0LCBudW1iZXJPZkF1ZGlvVGFnc10pO1xuICBjb25zdCB0YWtlbkF1ZGlvcyA9IHVzZVJlZjUobmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKGZhbHNlKSk7XG4gIGNvbnN0IHJlcmVuZGVyQXVkaW9zID0gdXNlQ2FsbGJhY2s3KCgpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHsgcmVmLCBpZCB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXVkaW9zLmN1cnJlbnQ/LmZpbmQoKGEpID0+IGEuaWQgPT09IGlkKTtcbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gcmVmO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudC5zcmMgPSBFTVBUWV9BVURJTztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhdWRpbyBkYXRhIHRvIGJlIHRoZXJlXCIpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoZGF0YS5wcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChkaWRQcm9wQ2hhbmdlKGtleSwgZGF0YS5wcm9wc1trZXldLCBjdXJyZW50W2tleV0pKSB7XG4gICAgICAgICAgY3VycmVudFtrZXldID0gZGF0YS5wcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW3JlZnNdKTtcbiAgY29uc3QgcmVnaXN0ZXJBdWRpbyA9IHVzZUNhbGxiYWNrNygob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgYXVkLCBhdWRpb0lkLCBwcmVtb3VudGluZyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBmb3VuZCA9IGF1ZGlvcy5jdXJyZW50Py5maW5kKChhKSA9PiBhLmF1ZGlvSWQgPT09IGF1ZGlvSWQpO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdEZyZWVBdWRpbyA9IHRha2VuQXVkaW9zLmN1cnJlbnQuZmluZEluZGV4KChhKSA9PiBhID09PSBmYWxzZSk7XG4gICAgaWYgKGZpcnN0RnJlZUF1ZGlvID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmllZCB0byBzaW11bHRhbmVvdXNseSBtb3VudCAke251bWJlck9mQXVkaW9UYWdzICsgMX0gPEh0bWw1QXVkaW8gLz4gdGFncyBhdCB0aGUgc2FtZSB0aW1lLiBXaXRoIHRoZSBjdXJyZW50IHNldHRpbmdzLCB0aGUgbWF4aW11bSBhbW91bnQgb2YgPEh0bWw1QXVkaW8gLz4gdGFncyBpcyBsaW1pdGVkIHRvICR7bnVtYmVyT2ZBdWRpb1RhZ3N9IGF0IHRoZSBzYW1lIHRpbWUuIFJlbW90aW9uIHByZS1tb3VudHMgc2lsZW50IGF1ZGlvIHRhZ3MgdG8gaGVscCBhdm9pZCBicm93c2VyIGF1dG9wbGF5IHJlc3RyaWN0aW9ucy4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2F1dG9wbGF5I3VzaW5nLXRoZS1udW1iZXJvZnNoYXJlZGF1ZGlvdGFncy1wcm9wIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0byBpbmNyZWFzZSB0aGlzIGxpbWl0LmApO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCByZWYsIG1lZGlhRWxlbWVudFNvdXJjZU5vZGUgfSA9IHJlZnNbZmlyc3RGcmVlQXVkaW9dO1xuICAgIGNvbnN0IGNsb25lZCA9IFsuLi50YWtlbkF1ZGlvcy5jdXJyZW50XTtcbiAgICBjbG9uZWRbZmlyc3RGcmVlQXVkaW9dID0gaWQ7XG4gICAgdGFrZW5BdWRpb3MuY3VycmVudCA9IGNsb25lZDtcbiAgICBjb25zdCBuZXdFbGVtID0ge1xuICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgIGlkLFxuICAgICAgZWw6IHJlZixcbiAgICAgIGF1ZGlvSWQsXG4gICAgICBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlLFxuICAgICAgcHJlbW91bnRpbmdcbiAgICB9O1xuICAgIGF1ZGlvcy5jdXJyZW50Py5wdXNoKG5ld0VsZW0pO1xuICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gICAgcmV0dXJuIG5ld0VsZW07XG4gIH0sIFtudW1iZXJPZkF1ZGlvVGFncywgcmVmcywgcmVyZW5kZXJBdWRpb3NdKTtcbiAgY29uc3QgdW5yZWdpc3RlckF1ZGlvID0gdXNlQ2FsbGJhY2s3KChpZCkgPT4ge1xuICAgIGNvbnN0IGNsb25lZCA9IFsuLi50YWtlbkF1ZGlvcy5jdXJyZW50XTtcbiAgICBjb25zdCBpbmRleCA9IHJlZnMuZmluZEluZGV4KChyKSA9PiByLmlkID09PSBpZCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVycm9yIG9jY3VyZWQgaW4gXCIpO1xuICAgIH1cbiAgICBjbG9uZWRbaW5kZXhdID0gZmFsc2U7XG4gICAgdGFrZW5BdWRpb3MuY3VycmVudCA9IGNsb25lZDtcbiAgICBhdWRpb3MuY3VycmVudCA9IGF1ZGlvcy5jdXJyZW50Py5maWx0ZXIoKGEpID0+IGEuaWQgIT09IGlkKTtcbiAgICByZXJlbmRlckF1ZGlvcygpO1xuICB9LCBbcmVmcywgcmVyZW5kZXJBdWRpb3NdKTtcbiAgY29uc3QgdXBkYXRlQXVkaW8gPSB1c2VDYWxsYmFjazcoKHtcbiAgICBhdWQsXG4gICAgYXVkaW9JZCxcbiAgICBpZCxcbiAgICBwcmVtb3VudGluZ1xuICB9KSA9PiB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBhdWRpb3MuY3VycmVudCA9IGF1ZGlvcy5jdXJyZW50Py5tYXAoKHByZXZBKSA9PiB7XG4gICAgICBpZiAocHJldkEuaWQgPT09IGlkKSB7XG4gICAgICAgIGNvbnN0IGlzVGhlU2FtZSA9IGNvbXBhcmVQcm9wcyhhdWQsIHByZXZBLnByb3BzKSAmJiBwcmV2QS5wcmVtb3VudGluZyA9PT0gcHJlbW91bnRpbmc7XG4gICAgICAgIGlmIChpc1RoZVNhbWUpIHtcbiAgICAgICAgICByZXR1cm4gcHJldkE7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucHJldkEsXG4gICAgICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgICAgICBwcmVtb3VudGluZyxcbiAgICAgICAgICBhdWRpb0lkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldkE7XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gICAgfVxuICB9LCBbcmVyZW5kZXJBdWRpb3NdKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgcGxheUFsbEF1ZGlvcyA9IHVzZUNhbGxiYWNrNygoKSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIGNvbnN0IGF1ZGlvID0gYXVkaW9zLmN1cnJlbnQuZmluZCgoYSkgPT4gYS5lbCA9PT0gcmVmLnJlZik7XG4gICAgICBpZiAoYXVkaW8/LnByZW1vdW50aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3Ioe1xuICAgICAgICBtZWRpYVJlZjogcmVmLnJlZixcbiAgICAgICAgbWVkaWFUeXBlOiBcImF1ZGlvXCIsXG4gICAgICAgIG9uQXV0b1BsYXlFcnJvcjogbnVsbCxcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgcmVhc29uOiBcInBsYXlpbmcgYWxsIGF1ZGlvc1wiLFxuICAgICAgICBpc1BsYXllcjogZW52LmlzUGxheWVyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhdWRpb0NvbnRleHQ/LnJlc3VtZSgpO1xuICB9LCBbYXVkaW9Db250ZXh0LCBsb2dMZXZlbCwgbW91bnRUaW1lLCByZWZzLCBlbnYuaXNQbGF5ZXJdKTtcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vMTUoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlckF1ZGlvLFxuICAgICAgdW5yZWdpc3RlckF1ZGlvLFxuICAgICAgdXBkYXRlQXVkaW8sXG4gICAgICBwbGF5QWxsQXVkaW9zLFxuICAgICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgICBhdWRpb0NvbnRleHRcbiAgICB9O1xuICB9LCBbXG4gICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgcGxheUFsbEF1ZGlvcyxcbiAgICByZWdpc3RlckF1ZGlvLFxuICAgIHVucmVnaXN0ZXJBdWRpbyxcbiAgICB1cGRhdGVBdWRpbyxcbiAgICBhdWRpb0NvbnRleHRcbiAgXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhTaGFyZWRBdWRpb0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlbjogW1xuICAgICAgcmVmcy5tYXAoKHsgaWQsIHJlZiB9KSA9PiB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTYoXCJhdWRpb1wiLCB7XG4gICAgICAgICAgcmVmLFxuICAgICAgICAgIHByZWxvYWQ6IFwibWV0YWRhdGFcIixcbiAgICAgICAgICBzcmM6IEVNUFRZX0FVRElPXG4gICAgICAgIH0sIGlkKTtcbiAgICAgIH0pLFxuICAgICAgY2hpbGRyZW5cbiAgICBdXG4gIH0pO1xufTtcbnZhciB1c2VTaGFyZWRBdWRpbyA9ICh7XG4gIGF1ZCxcbiAgYXVkaW9JZCxcbiAgcHJlbW91bnRpbmdcbn0pID0+IHtcbiAgY29uc3QgY3R4ID0gdXNlQ29udGV4dDE2KFNoYXJlZEF1ZGlvQ29udGV4dCk7XG4gIGNvbnN0IFtlbGVtXSA9IHVzZVN0YXRlMTEoKCkgPT4ge1xuICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgcmV0dXJuIGN0eC5yZWdpc3RlckF1ZGlvKHsgYXVkLCBhdWRpb0lkLCBwcmVtb3VudGluZyB9KTtcbiAgICB9XG4gICAgY29uc3QgZWwgPSBSZWFjdDE1LmNyZWF0ZVJlZigpO1xuICAgIGNvbnN0IG1lZGlhRWxlbWVudFNvdXJjZU5vZGUgPSBjdHg/LmF1ZGlvQ29udGV4dCA/IG1ha2VTaGFyZWRFbGVtZW50U291cmNlTm9kZSh7XG4gICAgICBhdWRpb0NvbnRleHQ6IGN0eC5hdWRpb0NvbnRleHQsXG4gICAgICByZWY6IGVsXG4gICAgfSkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBlbCxcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLFxuICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgIGF1ZGlvSWQsXG4gICAgICBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlLFxuICAgICAgcHJlbW91bnRpbmdcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgZWZmZWN0VG9Vc2UgPSBSZWFjdDE1LnVzZUluc2VydGlvbkVmZmVjdCA/PyBSZWFjdDE1LnVzZUxheW91dEVmZmVjdDtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICBjdHgudXBkYXRlQXVkaW8oeyBpZDogZWxlbS5pZCwgYXVkLCBhdWRpb0lkLCBwcmVtb3VudGluZyB9KTtcbiAgICAgIH1cbiAgICB9LCBbYXVkLCBjdHgsIGVsZW0uaWQsIGF1ZGlvSWQsIHByZW1vdW50aW5nXSk7XG4gICAgZWZmZWN0VG9Vc2UoKCkgPT4ge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGN0eCAmJiBjdHgubnVtYmVyT2ZBdWRpb1RhZ3MgPiAwKSB7XG4gICAgICAgICAgY3R4LnVucmVnaXN0ZXJBdWRpbyhlbGVtLmlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBbY3R4LCBlbGVtLmlkXSk7XG4gIH1cbiAgcmV0dXJuIGVsZW07XG59O1xuXG4vLyBzcmMvaXMtYXBwcm94aW1hdGVseS10aGUtc2FtZS50c1xudmFyIEZMT0FUSU5HX1BPSU5UX0VSUk9SX1RIUkVTSE9MRCA9IDAuMDAwMDE7XG52YXIgaXNBcHByb3hpbWF0ZWx5VGhlU2FtZSA9IChudW0xLCBudW0yKSA9PiB7XG4gIHJldHVybiBNYXRoLmFicyhudW0xIC0gbnVtMikgPCBGTE9BVElOR19QT0lOVF9FUlJPUl9USFJFU0hPTEQ7XG59O1xuXG4vLyBzcmMvdmlkZW8vdmlkZW8tZnJhZ21lbnQudHNcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWY2IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdG9TZWNvbmRzID0gKHRpbWUsIGZwcykgPT4ge1xuICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lIC8gZnBzICogMTAwKSAvIDEwMDtcbn07XG52YXIgaXNTYWZhcmkgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzQXBwbGVXZWJLaXQgPSAvQXBwbGVXZWJLaXQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBpZiAoIWlzQXBwbGVXZWJLaXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaXNOb3RDaHJvbWUgPSAhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJDaHJvbWUvXCIpO1xuICByZXR1cm4gaXNOb3RDaHJvbWU7XG59O1xudmFyIGlzSW9zU2FmYXJpID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpc0lwYWRJUG9kSVBob25lID0gL2lQKGFkfG9kfGhvbmUpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJldHVybiBpc0lwYWRJUG9kSVBob25lICYmIGlzU2FmYXJpKCk7XG59O1xudmFyIGlzSU9TU2FmYXJpQW5kQmxvYiA9IChhY3R1YWxTcmMpID0+IHtcbiAgcmV0dXJuIGlzSW9zU2FmYXJpKCkgJiYgYWN0dWFsU3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKTtcbn07XG52YXIgZ2V0VmlkZW9GcmFnbWVudFN0YXJ0ID0gKHtcbiAgYWN0dWFsRnJvbSxcbiAgZnBzXG59KSA9PiB7XG4gIHJldHVybiB0b1NlY29uZHMoTWF0aC5tYXgoMCwgLWFjdHVhbEZyb20pLCBmcHMpO1xufTtcbnZhciBnZXRWaWRlb0ZyYWdtZW50RW5kID0gKHtcbiAgZHVyYXRpb24sXG4gIGZwc1xufSkgPT4ge1xuICByZXR1cm4gdG9TZWNvbmRzKGR1cmF0aW9uLCBmcHMpO1xufTtcbnZhciBhcHBlbmRWaWRlb0ZyYWdtZW50ID0gKHtcbiAgYWN0dWFsU3JjLFxuICBhY3R1YWxGcm9tLFxuICBkdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIGlmIChpc0lPU1NhZmFyaUFuZEJsb2IoYWN0dWFsU3JjKSkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgaWYgKGFjdHVhbFNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nSGFzaCA9IEJvb2xlYW4obmV3IFVSTChhY3R1YWxTcmMsICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSA/PyBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiKS5oYXNoKTtcbiAgaWYgKGV4aXN0aW5nSGFzaCkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYWN0dWFsRnJvbSkpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IHdpdGhTdGFydEhhc2ggPSBgJHthY3R1YWxTcmN9I3Q9JHtnZXRWaWRlb0ZyYWdtZW50U3RhcnQoeyBhY3R1YWxGcm9tLCBmcHMgfSl9YDtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIHdpdGhTdGFydEhhc2g7XG4gIH1cbiAgcmV0dXJuIGAke3dpdGhTdGFydEhhc2h9LCR7Z2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uLCBmcHMgfSl9YDtcbn07XG52YXIgaXNTdWJzZXRPZkR1cmF0aW9uID0gKHtcbiAgcHJldlN0YXJ0RnJvbSxcbiAgbmV3U3RhcnRGcm9tLFxuICBwcmV2RHVyYXRpb24sXG4gIG5ld0R1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgY29uc3QgcHJldmlvdXNGcm9tID0gZ2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbTogcHJldlN0YXJ0RnJvbSwgZnBzIH0pO1xuICBjb25zdCBuZXdGcm9tID0gZ2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbTogbmV3U3RhcnRGcm9tLCBmcHMgfSk7XG4gIGNvbnN0IHByZXZpb3VzRW5kID0gZ2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uOiBwcmV2RHVyYXRpb24sIGZwcyB9KTtcbiAgY29uc3QgbmV3RW5kID0gZ2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uOiBuZXdEdXJhdGlvbiwgZnBzIH0pO1xuICBpZiAobmV3RnJvbSA8IHByZXZpb3VzRnJvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmV3RW5kID4gcHJldmlvdXNFbmQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQgPSAoe1xuICBhY3R1YWxTcmM6IGluaXRpYWxBY3R1YWxTcmMsXG4gIGFjdHVhbEZyb206IGluaXRpYWxBY3R1YWxGcm9tLFxuICBkdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgY29uc3QgYWN0dWFsRnJvbVJlZiA9IHVzZVJlZjYoaW5pdGlhbEFjdHVhbEZyb20pO1xuICBjb25zdCBhY3R1YWxEdXJhdGlvbiA9IHVzZVJlZjYoaW5pdGlhbER1cmF0aW9uKTtcbiAgY29uc3QgYWN0dWFsU3JjID0gdXNlUmVmNihpbml0aWFsQWN0dWFsU3JjKTtcbiAgaWYgKCFpc1N1YnNldE9mRHVyYXRpb24oe1xuICAgIHByZXZTdGFydEZyb206IGFjdHVhbEZyb21SZWYuY3VycmVudCxcbiAgICBuZXdTdGFydEZyb206IGluaXRpYWxBY3R1YWxGcm9tLFxuICAgIHByZXZEdXJhdGlvbjogYWN0dWFsRHVyYXRpb24uY3VycmVudCxcbiAgICBuZXdEdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLFxuICAgIGZwc1xuICB9KSB8fCBpbml0aWFsQWN0dWFsU3JjICE9PSBhY3R1YWxTcmMuY3VycmVudCkge1xuICAgIGFjdHVhbEZyb21SZWYuY3VycmVudCA9IGluaXRpYWxBY3R1YWxGcm9tO1xuICAgIGFjdHVhbER1cmF0aW9uLmN1cnJlbnQgPSBpbml0aWFsRHVyYXRpb247XG4gICAgYWN0dWFsU3JjLmN1cnJlbnQgPSBpbml0aWFsQWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IGFwcGVuZGVkID0gYXBwZW5kVmlkZW9GcmFnbWVudCh7XG4gICAgYWN0dWFsU3JjOiBhY3R1YWxTcmMuY3VycmVudCxcbiAgICBhY3R1YWxGcm9tOiBhY3R1YWxGcm9tUmVmLmN1cnJlbnQsXG4gICAgZHVyYXRpb246IGFjdHVhbER1cmF0aW9uLmN1cnJlbnQsXG4gICAgZnBzXG4gIH0pO1xuICByZXR1cm4gYXBwZW5kZWQ7XG59O1xuXG4vLyBzcmMvdXNlLWFtcGxpZmljYXRpb24udHNcbnZhciB3YXJuZWQyID0gZmFsc2U7XG52YXIgd2FyblNhZmFyaU9uY2UgPSAobG9nTGV2ZWwpID0+IHtcbiAgaWYgKHdhcm5lZDIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkMiA9IHRydWU7XG4gIExvZy53YXJuKHsgbG9nTGV2ZWwsIHRhZzogbnVsbCB9LCBcIkluIFNhZmFyaSwgc2V0dGluZyBhIHZvbHVtZSBhbmQgYSBwbGF5YmFjayByYXRlIGF0IHRoZSBzYW1lIHRpbWUgaXMgYnVnZ3kuXCIpO1xuICBMb2cud2Fybih7IGxvZ0xldmVsLCB0YWc6IG51bGwgfSwgXCJJbiBEZXNrdG9wIFNhZmFyaSwgb25seSB2b2x1bWVzIDw9IDEgd2lsbCBiZSBhcHBsaWVkLlwiKTtcbiAgTG9nLndhcm4oeyBsb2dMZXZlbCwgdGFnOiBudWxsIH0sIGxvZ0xldmVsLCBcIkluIE1vYmlsZSBTYWZhcmksIHRoZSB2b2x1bWUgd2lsbCBiZSBpZ25vcmVkIGFuZCBzZXQgdG8gMSBpZiBhIHBsYXliYWNrUmF0ZSBpcyBzZXQuXCIpO1xufTtcbnZhciB1c2VWb2x1bWUgPSAoe1xuICBtZWRpYVJlZixcbiAgdm9sdW1lLFxuICBsb2dMZXZlbCxcbiAgc291cmNlLFxuICBzaG91bGRVc2VXZWJBdWRpb0FwaVxufSkgPT4ge1xuICBjb25zdCBhdWRpb1N0dWZmUmVmID0gdXNlUmVmNyhudWxsKTtcbiAgY29uc3QgY3VycmVudFZvbHVtZVJlZiA9IHVzZVJlZjcodm9sdW1lKTtcbiAgY3VycmVudFZvbHVtZVJlZi5jdXJyZW50ID0gdm9sdW1lO1xuICBjb25zdCBzaGFyZWRBdWRpb0NvbnRleHQgPSB1c2VDb250ZXh0MTcoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgaWYgKCFzaGFyZWRBdWRpb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VBbXBsaWZpY2F0aW9uIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBTaGFyZWRBdWRpb0NvbnRleHRcIik7XG4gIH1cbiAgY29uc3QgeyBhdWRpb0NvbnRleHQgfSA9IHNoYXJlZEF1ZGlvQ29udGV4dDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB1c2VMYXlvdXRFZmZlY3Q1KCgpID0+IHtcbiAgICAgIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWFSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZFVzZVdlYkF1ZGlvQXBpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYVJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSAhPT0gMSAmJiBpc1NhZmFyaSgpKSB7XG4gICAgICAgIHdhcm5TYWZhcmlPbmNlKGxvZ0xldmVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2Fpbk5vZGUgPSBuZXcgR2Fpbk5vZGUoYXVkaW9Db250ZXh0LCB7XG4gICAgICAgIGdhaW46IGN1cnJlbnRWb2x1bWVSZWYuY3VycmVudFxuICAgICAgfSk7XG4gICAgICBzb3VyY2UuYXR0ZW1wdFRvQ29ubmVjdCgpO1xuICAgICAgc291cmNlLmdldCgpLmNvbm5lY3QoZ2Fpbk5vZGUpO1xuICAgICAgZ2Fpbk5vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgYXVkaW9TdHVmZlJlZi5jdXJyZW50ID0ge1xuICAgICAgICBnYWluTm9kZVxuICAgICAgfTtcbiAgICAgIExvZy50cmFjZSh7IGxvZ0xldmVsLCB0YWc6IG51bGwgfSwgYFN0YXJ0aW5nIHRvIGFtcGxpZnkgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9LiBHYWluID0gJHtjdXJyZW50Vm9sdW1lUmVmLmN1cnJlbnR9LCBwbGF5YmFja1JhdGUgPSAke21lZGlhUmVmLmN1cnJlbnQ/LnBsYXliYWNrUmF0ZX1gKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGF1ZGlvU3R1ZmZSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc291cmNlLmdldCgpLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH07XG4gICAgfSwgW2xvZ0xldmVsLCBtZWRpYVJlZiwgYXVkaW9Db250ZXh0LCBzb3VyY2UsIHNob3VsZFVzZVdlYkF1ZGlvQXBpXSk7XG4gIH1cbiAgaWYgKGF1ZGlvU3R1ZmZSZWYuY3VycmVudCkge1xuICAgIGNvbnN0IHZhbHVlVG9TZXQgPSB2b2x1bWU7XG4gICAgaWYgKCFpc0FwcHJveGltYXRlbHlUaGVTYW1lKGF1ZGlvU3R1ZmZSZWYuY3VycmVudC5nYWluTm9kZS5nYWluLnZhbHVlLCB2YWx1ZVRvU2V0KSkge1xuICAgICAgYXVkaW9TdHVmZlJlZi5jdXJyZW50LmdhaW5Ob2RlLmdhaW4udmFsdWUgPSB2YWx1ZVRvU2V0O1xuICAgICAgTG9nLnRyYWNlKHsgbG9nTGV2ZWwsIHRhZzogbnVsbCB9LCBgU2V0dGluZyBnYWluIHRvICR7dmFsdWVUb1NldH0gZm9yICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfWApO1xuICAgIH1cbiAgfVxuICBjb25zdCBzYWZhcmlDYXNlID0gaXNTYWZhcmkoKSAmJiBtZWRpYVJlZi5jdXJyZW50ICYmIG1lZGlhUmVmLmN1cnJlbnQ/LnBsYXliYWNrUmF0ZSAhPT0gMTtcbiAgY29uc3Qgc2hvdWxkVXNlVHJhZGl0aW9uYWxWb2x1bWUgPSBzYWZhcmlDYXNlIHx8ICFzaG91bGRVc2VXZWJBdWRpb0FwaTtcbiAgaWYgKHNob3VsZFVzZVRyYWRpdGlvbmFsVm9sdW1lICYmIG1lZGlhUmVmLmN1cnJlbnQgJiYgIWlzQXBwcm94aW1hdGVseVRoZVNhbWUodm9sdW1lLCBtZWRpYVJlZi5jdXJyZW50Py52b2x1bWUpKSB7XG4gICAgbWVkaWFSZWYuY3VycmVudC52b2x1bWUgPSBNYXRoLm1pbih2b2x1bWUsIDEpO1xuICB9XG4gIHJldHVybiBhdWRpb1N0dWZmUmVmO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1pbi10aW1lbGluZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTksIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2LCB1c2VNZW1vIGFzIHVzZU1lbW8xNiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYXVkaW8vdXNlLWF1ZGlvLWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxOCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhU3RhcnRzQXQgPSAoKSA9PiB7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDE4KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHN0YXJ0c0F0ID0gTWF0aC5taW4oMCwgcGFyZW50U2VxdWVuY2U/LnJlbGF0aXZlRnJvbSA/PyAwKTtcbiAgcmV0dXJuIHN0YXJ0c0F0O1xufTtcbnZhciB1c2VGcmFtZUZvclZvbHVtZVByb3AgPSAoYmVoYXZpb3IpID0+IHtcbiAgY29uc3QgbG9vcCA9IExvb3AudXNlTG9vcCgpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCBzdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgaWYgKGJlaGF2aW9yID09PSBcInJlcGVhdFwiIHx8IGxvb3AgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZnJhbWUgKyBzdGFydHNBdDtcbiAgfVxuICByZXR1cm4gZnJhbWUgKyBzdGFydHNBdCArIGxvb3AuZHVyYXRpb25JbkZyYW1lcyAqIGxvb3AuaXRlcmF0aW9uO1xufTtcblxuLy8gc3JjL2dldC1hc3NldC1maWxlLW5hbWUudHNcbnZhciBnZXRBc3NldERpc3BsYXlOYW1lID0gKGZpbGVuYW1lKSA9PiB7XG4gIGlmICgvZGF0YTp8YmxvYjovLnRlc3QoZmlsZW5hbWUuc3Vic3RyaW5nKDAsIDUpKSkge1xuICAgIHJldHVybiBcIkRhdGEgVVJMXCI7XG4gIH1cbiAgY29uc3Qgc3BsaXR0ZWQgPSBmaWxlbmFtZS5zcGxpdChcIi9cIikubWFwKChzKSA9PiBzLnNwbGl0KFwiXFxcXFwiKSkuZmxhdCgxKTtcbiAgcmV0dXJuIHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdO1xufTtcblxuLy8gc3JjL3ZvbHVtZS1wcm9wLnRzXG52YXIgZXZhbHVhdGVWb2x1bWUgPSAoe1xuICBmcmFtZSxcbiAgdm9sdW1lLFxuICBtZWRpYVZvbHVtZSA9IDFcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdm9sdW1lICogbWVkaWFWb2x1bWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gTnVtYmVyKG1lZGlhVm9sdW1lKTtcbiAgfVxuICBjb25zdCBldmFsdWF0ZWQgPSB2b2x1bWUoZnJhbWUpICogbWVkaWFWb2x1bWU7XG4gIGlmICh0eXBlb2YgZXZhbHVhdGVkICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGEgZnVuY3Rpb24gdG8gdGhlIHZvbHVtZSBwcm9wIGJ1dCBpdCBkaWQgbm90IHJldHVybiBhIG51bWJlciBidXQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGV2YWx1YXRlZH0gZm9yIGZyYW1lICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgTmFOIGZvciBmcmFtZSAke2ZyYW1lfS5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgYSBub24tZmluaXRlIG51bWJlciBmb3IgZnJhbWUgJHtmcmFtZX0uYCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KDAsIGV2YWx1YXRlZCk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWluLXRpbWVsaW5lLnRzXG52YXIgZGlkV2FybiA9IHt9O1xudmFyIHdhcm5PbmNlMiA9IChtZXNzYWdlKSA9PiB7XG4gIGlmIChkaWRXYXJuW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgZGlkV2FyblttZXNzYWdlXSA9IHRydWU7XG59O1xudmFyIHVzZUJhc2ljTWVkaWFJblRpbWVsaW5lID0gKHtcbiAgdm9sdW1lLFxuICBtZWRpYVZvbHVtZSxcbiAgbWVkaWFUeXBlLFxuICBzcmMsXG4gIGRpc3BsYXlOYW1lLFxuICB0cmltQmVmb3JlLFxuICB0cmltQWZ0ZXIsXG4gIHBsYXliYWNrUmF0ZVxufSkgPT4ge1xuICBpZiAoIXNyYykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gIH1cbiAgY29uc3Qgc3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDE5KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgW2luaXRpYWxWb2x1bWVdID0gdXNlU3RhdGUxMigoKSA9PiB2b2x1bWUpO1xuICBjb25zdCBtZWRpYUR1cmF0aW9uID0gY2FsY3VsYXRlTWVkaWFEdXJhdGlvbih7XG4gICAgbWVkaWFEdXJhdGlvbkluRnJhbWVzOiB2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICB0cmltQmVmb3JlLFxuICAgIHRyaW1BZnRlclxuICB9KTtcbiAgY29uc3QgZHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMsIG1lZGlhRHVyYXRpb24pIDogbWVkaWFEdXJhdGlvbjtcbiAgY29uc3Qgdm9sdW1lcyA9IHVzZU1lbW8xNigoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB2b2x1bWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXkoTWF0aC5mbG9vcihNYXRoLm1heCgwLCBkdXJhdGlvbiArIHN0YXJ0c0F0KSkpLmZpbGwodHJ1ZSkubWFwKChfLCBpKSA9PiB7XG4gICAgICByZXR1cm4gZXZhbHVhdGVWb2x1bWUoe1xuICAgICAgICBmcmFtZTogaSArIHN0YXJ0c0F0LFxuICAgICAgICB2b2x1bWUsXG4gICAgICAgIG1lZGlhVm9sdW1lXG4gICAgICB9KTtcbiAgICB9KS5qb2luKFwiLFwiKTtcbiAgfSwgW2R1cmF0aW9uLCBzdGFydHNBdCwgdm9sdW1lLCBtZWRpYVZvbHVtZV0pO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZvbHVtZSA9PT0gXCJudW1iZXJcIiAmJiB2b2x1bWUgIT09IGluaXRpYWxWb2x1bWUpIHtcbiAgICAgIHdhcm5PbmNlMihgUmVtb3Rpb246IFRoZSAke21lZGlhVHlwZX0gd2l0aCBzcmMgJHtzcmN9IGhhcyBjaGFuZ2VkIGl0J3Mgdm9sdW1lLiBQcmVmZXIgdGhlIGNhbGxiYWNrIHN5bnRheCBmb3Igc2V0dGluZyB2b2x1bWUgdG8gZ2V0IGJldHRlciB0aW1lbGluZSBkaXNwbGF5OiBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9hdWRpby92b2x1bWVgKTtcbiAgICB9XG4gIH0sIFtpbml0aWFsVm9sdW1lLCBtZWRpYVR5cGUsIHNyYywgdm9sdW1lXSk7XG4gIGNvbnN0IGRvZXNWb2x1bWVDaGFuZ2UgPSB0eXBlb2Ygdm9sdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gIGNvbnN0IG5vbmNlID0gdXNlTm9uY2UoKTtcbiAgY29uc3QgeyByb290SWQgfSA9IHVzZUNvbnRleHQxOShUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIHJldHVybiB7XG4gICAgdm9sdW1lcyxcbiAgICBkdXJhdGlvbixcbiAgICBkb2VzVm9sdW1lQ2hhbmdlLFxuICAgIG5vbmNlLFxuICAgIHJvb3RJZCxcbiAgICBpc1N0dWRpbzogZW52LmlzU3R1ZGlvLFxuICAgIGZpbmFsRGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lID8/IGdldEFzc2V0RGlzcGxheU5hbWUoc3JjKVxuICB9O1xufTtcbnZhciB1c2VNZWRpYUluVGltZWxpbmUgPSAoe1xuICB2b2x1bWUsXG4gIG1lZGlhVm9sdW1lLFxuICBzcmMsXG4gIG1lZGlhVHlwZSxcbiAgcGxheWJhY2tSYXRlLFxuICBkaXNwbGF5TmFtZSxcbiAgaWQsXG4gIHN0YWNrLFxuICBzaG93SW5UaW1lbGluZSxcbiAgcHJlbW91bnREaXNwbGF5LFxuICBwb3N0bW91bnREaXNwbGF5LFxuICBsb29wRGlzcGxheVxufSkgPT4ge1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxOShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBzdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgeyByZWdpc3RlclNlcXVlbmNlLCB1bnJlZ2lzdGVyU2VxdWVuY2UgfSA9IHVzZUNvbnRleHQxOShTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCB7XG4gICAgdm9sdW1lcyxcbiAgICBkdXJhdGlvbixcbiAgICBkb2VzVm9sdW1lQ2hhbmdlLFxuICAgIG5vbmNlLFxuICAgIHJvb3RJZCxcbiAgICBpc1N0dWRpbyxcbiAgICBmaW5hbERpc3BsYXlOYW1lXG4gIH0gPSB1c2VCYXNpY01lZGlhSW5UaW1lbGluZSh7XG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lLFxuICAgIG1lZGlhVHlwZSxcbiAgICBzcmMsXG4gICAgZGlzcGxheU5hbWUsXG4gICAgdHJpbUFmdGVyOiB1bmRlZmluZWQsXG4gICAgdHJpbUJlZm9yZTogdW5kZWZpbmVkLFxuICAgIHBsYXliYWNrUmF0ZVxuICB9KTtcbiAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmICghaXNTdHVkaW8gJiYgd2luZG93LnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgIT09IFwidGVzdFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc2hvd0luVGltZWxpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSh7XG4gICAgICB0eXBlOiBtZWRpYVR5cGUsXG4gICAgICBzcmMsXG4gICAgICBpZCxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZnJvbTogMCxcbiAgICAgIHBhcmVudDogcGFyZW50U2VxdWVuY2U/LmlkID8/IG51bGwsXG4gICAgICBkaXNwbGF5TmFtZTogZmluYWxEaXNwbGF5TmFtZSxcbiAgICAgIHJvb3RJZCxcbiAgICAgIHZvbHVtZTogdm9sdW1lcyxcbiAgICAgIHNob3dJblRpbWVsaW5lOiB0cnVlLFxuICAgICAgbm9uY2UsXG4gICAgICBzdGFydE1lZGlhRnJvbTogMCAtIHN0YXJ0c0F0LFxuICAgICAgZG9lc1ZvbHVtZUNoYW5nZSxcbiAgICAgIGxvb3BEaXNwbGF5LFxuICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgc3RhY2ssXG4gICAgICBwcmVtb3VudERpc3BsYXksXG4gICAgICBwb3N0bW91bnREaXNwbGF5XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZShpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGR1cmF0aW9uLFxuICAgIGlkLFxuICAgIHBhcmVudFNlcXVlbmNlLFxuICAgIHNyYyxcbiAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgIHVucmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICB2b2x1bWVzLFxuICAgIGRvZXNWb2x1bWVDaGFuZ2UsXG4gICAgbm9uY2UsXG4gICAgbWVkaWFUeXBlLFxuICAgIHN0YXJ0c0F0LFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBzdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBwcmVtb3VudERpc3BsYXksXG4gICAgcG9zdG1vdW50RGlzcGxheSxcbiAgICBpc1N0dWRpbyxcbiAgICBsb29wRGlzcGxheSxcbiAgICByb290SWQsXG4gICAgZmluYWxEaXNwbGF5TmFtZVxuICBdKTtcbn07XG5cbi8vIHNyYy91c2UtbWVkaWEtcGxheWJhY2sudHNcbmltcG9ydCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTAsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIyLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTAsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q3LFxuICB1c2VSZWYgYXMgdXNlUmVmMTFcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9idWZmZXItdW50aWwtZmlyc3QtZnJhbWUudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOSwgdXNlTWVtbyBhcyB1c2VNZW1vMTksIHVzZVJlZiBhcyB1c2VSZWY5IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2UtYnVmZmVyLXN0YXRlLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMSwgdXNlTWVtbyBhcyB1c2VNZW1vMTggfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2J1ZmZlcmluZy50c3hcbmltcG9ydCBSZWFjdDE2LCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOCxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjAsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q3LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0NixcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTcsXG4gIHVzZVJlZiBhcyB1c2VSZWY4LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEzXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgdXNlQnVmZmVyTWFuYWdlciA9IChsb2dMZXZlbCwgbW91bnRUaW1lKSA9PiB7XG4gIGNvbnN0IFtibG9ja3MsIHNldEJsb2Nrc10gPSB1c2VTdGF0ZTEzKFtdKTtcbiAgY29uc3QgW29uQnVmZmVyaW5nQ2FsbGJhY2tzLCBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrc10gPSB1c2VTdGF0ZTEzKFtdKTtcbiAgY29uc3QgW29uUmVzdW1lQ2FsbGJhY2tzLCBzZXRPblJlc3VtZUNhbGxiYWNrc10gPSB1c2VTdGF0ZTEzKFtdKTtcbiAgY29uc3QgYnVmZmVyaW5nID0gdXNlUmVmOChmYWxzZSk7XG4gIGNvbnN0IGFkZEJsb2NrID0gdXNlQ2FsbGJhY2s4KChibG9jaykgPT4ge1xuICAgIHNldEJsb2NrcygoYikgPT4gWy4uLmIsIGJsb2NrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuYmxvY2s6ICgpID0+IHtcbiAgICAgICAgc2V0QmxvY2tzKChiKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3QXJyID0gYi5maWx0ZXIoKGJ4KSA9PiBieCAhPT0gYmxvY2spO1xuICAgICAgICAgIGlmIChuZXdBcnIubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdBcnI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yQnVmZmVyaW5nID0gdXNlQ2FsbGJhY2s4KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yUmVzdW1lID0gdXNlQ2FsbGJhY2s4KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0NygoKSA9PiB7XG4gICAgaWYgKGJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbkJ1ZmZlcmluZ0NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IFwiUGxheWVyIGlzIGVudGVyaW5nIGJ1ZmZlciBzdGF0ZVwiLFxuICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgIHRhZzogXCJwbGF5ZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbYmxvY2tzXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0NigoKSA9PiB7XG4gICAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvblJlc3VtZUNhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiUGxheWVyIGlzIGV4aXRpbmcgYnVmZmVyIHN0YXRlXCIsXG4gICAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICAgIHRhZzogXCJwbGF5ZXJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbYmxvY2tzXSk7XG4gIH1cbiAgcmV0dXJuIHVzZU1lbW8xNygoKSA9PiB7XG4gICAgcmV0dXJuIHsgYWRkQmxvY2ssIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lLCBidWZmZXJpbmcgfTtcbiAgfSwgW2FkZEJsb2NrLCBidWZmZXJpbmcsIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lXSk7XG59O1xudmFyIEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCA9IFJlYWN0MTYuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBCdWZmZXJpbmdQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgeyBsb2dMZXZlbCwgbW91bnRUaW1lIH0gPSB1c2VDb250ZXh0MjAoTG9nTGV2ZWxDb250ZXh0KTtcbiAgY29uc3QgYnVmZmVyTWFuYWdlciA9IHVzZUJ1ZmZlck1hbmFnZXIobG9nTGV2ZWwgPz8gXCJpbmZvXCIsIG1vdW50VGltZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTcoQnVmZmVyaW5nQ29udGV4dFJlYWN0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGJ1ZmZlck1hbmFnZXIsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZUlzUGxheWVyQnVmZmVyaW5nID0gKGJ1ZmZlck1hbmFnZXIpID0+IHtcbiAgY29uc3QgW2lzQnVmZmVyaW5nLCBzZXRJc0J1ZmZlcmluZ10gPSB1c2VTdGF0ZTEzKGJ1ZmZlck1hbmFnZXIuYnVmZmVyaW5nLmN1cnJlbnQpO1xuICB1c2VFZmZlY3Q3KCgpID0+IHtcbiAgICBjb25zdCBvbkJ1ZmZlciA9ICgpID0+IHtcbiAgICAgIHNldElzQnVmZmVyaW5nKHRydWUpO1xuICAgIH07XG4gICAgY29uc3Qgb25SZXN1bWUgPSAoKSA9PiB7XG4gICAgICBzZXRJc0J1ZmZlcmluZyhmYWxzZSk7XG4gICAgfTtcbiAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvckJ1ZmZlcmluZyhvbkJ1ZmZlcik7XG4gICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JSZXN1bWUob25SZXN1bWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvckJ1ZmZlcmluZygoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JSZXN1bWUoKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbYnVmZmVyTWFuYWdlcl0pO1xuICByZXR1cm4gaXNCdWZmZXJpbmc7XG59O1xuXG4vLyBzcmMvdXNlLWJ1ZmZlci1zdGF0ZS50c1xudmFyIHVzZUJ1ZmZlclN0YXRlID0gKCkgPT4ge1xuICBjb25zdCBidWZmZXIgPSB1c2VDb250ZXh0MjEoQnVmZmVyaW5nQ29udGV4dFJlYWN0KTtcbiAgY29uc3QgYWRkQmxvY2sgPSBidWZmZXIgPyBidWZmZXIuYWRkQmxvY2sgOiBudWxsO1xuICByZXR1cm4gdXNlTWVtbzE4KCgpID0+ICh7XG4gICAgZGVsYXlQbGF5YmFjazogKCkgPT4ge1xuICAgICAgaWYgKCFhZGRCbG9jaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBlbmFibGUgdGhlIGJ1ZmZlcmluZyBzdGF0ZSwgYnV0IGEgUmVtb3Rpb24gY29udGV4dCB3YXMgbm90IGZvdW5kLiBUaGlzIEFQSSBjYW4gb25seSBiZSBjYWxsZWQgaW4gYSBjb21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBSZW1vdGlvbiBQbGF5ZXIgb3IgYSA8Q29tcG9zaXRpb24+LiBPciB5b3UgbWlnaHQgaGF2ZSBleHBlcmllbmNlZCBhIHZlcnNpb24gbWlzbWF0Y2ggLSBydW4gYG5weCByZW1vdGlvbiB2ZXJzaW9uc2AgYW5kIGVuc3VyZSBhbGwgcGFja2FnZXMgaGF2ZSB0aGUgc2FtZSB2ZXJzaW9uLiBUaGlzIGVycm9yIGlzIHRocm93biBieSB0aGUgYnVmZmVyIHN0YXRlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2J1ZmZlci1zdGF0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdW5ibG9jayB9ID0gYWRkQmxvY2soe1xuICAgICAgICBpZDogU3RyaW5nKE1hdGgucmFuZG9tKCkpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHVuYmxvY2sgfTtcbiAgICB9XG4gIH0pLCBbYWRkQmxvY2tdKTtcbn07XG5cbi8vIHNyYy9idWZmZXItdW50aWwtZmlyc3QtZnJhbWUudHNcbnZhciBpc1NhZmFyaVdlYmtpdCA9ICgpID0+IHtcbiAgY29uc3QgaXNTYWZhcmkyID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJldHVybiBpc1NhZmFyaTI7XG59O1xudmFyIHVzZUJ1ZmZlclVudGlsRmlyc3RGcmFtZSA9ICh7XG4gIG1lZGlhUmVmLFxuICBtZWRpYVR5cGUsXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkLFxuICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgYnVmZmVyaW5nUmVmID0gdXNlUmVmOShmYWxzZSk7XG4gIGNvbnN0IHsgZGVsYXlQbGF5YmFjayB9ID0gdXNlQnVmZmVyU3RhdGUoKTtcbiAgY29uc3QgYnVmZmVyVW50aWxGaXJzdEZyYW1lID0gdXNlQ2FsbGJhY2s5KChyZXF1ZXN0ZWRUaW1lKSA9PiB7XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGF1c2VXaGVuQnVmZmVyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSBtZWRpYVJlZi5jdXJyZW50O1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5yZWFkeVN0YXRlID49IGN1cnJlbnQuSEFWRV9GVVRVUkVfREFUQSAmJiAhaXNTYWZhcmlXZWJraXQoKSkge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IGBOb3QgdXNpbmcgYnVmZmVyIHVudGlsIGZpcnN0IGZyYW1lLCBiZWNhdXNlIHJlYWR5U3RhdGUgaXMgJHtjdXJyZW50LnJlYWR5U3RhdGV9IGFuZCBpcyBub3QgU2FmYXJpIG9yIERlc2t0b3AgQ2hyb21lYCxcbiAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICB0YWc6IFwiYnVmZmVyXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWN1cnJlbnQucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IGBOb3QgdXNpbmcgYnVmZmVyIHVudGlsIGZpcnN0IGZyYW1lLCBiZWNhdXNlIHJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sgaXMgbm90IHN1cHBvcnRlZGAsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgdGFnOiBcImJ1ZmZlclwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYnVmZmVyaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICBsb2dMZXZlbCxcbiAgICAgIG1lc3NhZ2U6IGBCdWZmZXJpbmcgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9IHVudGlsIHRoZSBmaXJzdCBmcmFtZSBpcyByZWNlaXZlZGAsXG4gICAgICBtb3VudFRpbWUsXG4gICAgICB0YWc6IFwiYnVmZmVyXCJcbiAgICB9KTtcbiAgICBjb25zdCBwbGF5YmFjayA9IGRlbGF5UGxheWJhY2soKTtcbiAgICBjb25zdCB1bmJsb2NrID0gKCkgPT4ge1xuICAgICAgcGxheWJhY2sudW5ibG9jaygpO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgdW5ibG9jaywge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIHVuYmxvY2ssIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBidWZmZXJpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmRlZE9yUGF1c2VPckNhblBsYXkgPSAoKSA9PiB7XG4gICAgICB1bmJsb2NrKCk7XG4gICAgfTtcbiAgICBjdXJyZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soKF8sIGluZm8yKSA9PiB7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlRnJvbVJlcXVlc3RlZCA9IE1hdGguYWJzKGluZm8yLm1lZGlhVGltZSAtIHJlcXVlc3RlZFRpbWUpO1xuICAgICAgaWYgKGRpZmZlcmVuY2VGcm9tUmVxdWVzdGVkID4gMC41KSB7XG4gICAgICAgIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkKCk7XG4gICAgICB9XG4gICAgICB1bmJsb2NrKCk7XG4gICAgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgb25FbmRlZE9yUGF1c2VPckNhblBsYXksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25FbmRlZE9yUGF1c2VPckNhblBsYXksIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgfSwgW1xuICAgIGRlbGF5UGxheWJhY2ssXG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG1vdW50VGltZSxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmdcbiAgXSk7XG4gIHJldHVybiB1c2VNZW1vMTkoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBpc0J1ZmZlcmluZzogKCkgPT4gYnVmZmVyaW5nUmVmLmN1cnJlbnQsXG4gICAgICBidWZmZXJVbnRpbEZpcnN0RnJhbWVcbiAgICB9O1xuICB9LCBbYnVmZmVyVW50aWxGaXJzdEZyYW1lXSk7XG59O1xuXG4vLyBzcmMvbWVkaWEtdGFnLWN1cnJlbnQtdGltZS10aW1lc3RhbXAudHNcbmltcG9ydCBSZWFjdDE3IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUN1cnJlbnRUaW1lT2ZNZWRpYVRhZ1dpdGhVcGRhdGVUaW1lU3RhbXAgPSAobWVkaWFSZWYpID0+IHtcbiAgY29uc3QgbGFzdFVwZGF0ZSA9IFJlYWN0MTcudXNlUmVmKHtcbiAgICB0aW1lOiBtZWRpYVJlZi5jdXJyZW50Py5jdXJyZW50VGltZSA/PyAwLFxuICAgIGxhc3RVcGRhdGU6IHBlcmZvcm1hbmNlLm5vdygpXG4gIH0pO1xuICBjb25zdCBub3dDdXJyZW50VGltZSA9IG1lZGlhUmVmLmN1cnJlbnQ/LmN1cnJlbnRUaW1lID8/IG51bGw7XG4gIGlmIChub3dDdXJyZW50VGltZSAhPT0gbnVsbCkge1xuICAgIGlmIChsYXN0VXBkYXRlLmN1cnJlbnQudGltZSAhPT0gbm93Q3VycmVudFRpbWUpIHtcbiAgICAgIGxhc3RVcGRhdGUuY3VycmVudC50aW1lID0gbm93Q3VycmVudFRpbWU7XG4gICAgICBsYXN0VXBkYXRlLmN1cnJlbnQubGFzdFVwZGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGFzdFVwZGF0ZTtcbn07XG5cbi8vIHNyYy9zZWVrLnRzXG52YXIgc2VlayA9ICh7XG4gIG1lZGlhUmVmLFxuICB0aW1lLFxuICBsb2dMZXZlbCxcbiAgd2h5LFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgdGltZVRvU2V0ID0gaXNJb3NTYWZhcmkoKSA/IE51bWJlcih0aW1lLnRvRml4ZWQoMSkpIDogdGltZTtcbiAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICBsb2dMZXZlbCxcbiAgICB0YWc6IFwic2Vla1wiLFxuICAgIG1lc3NhZ2U6IGBTZWVraW5nIGZyb20gJHttZWRpYVJlZi5jdXJyZW50VGltZX0gdG8gJHt0aW1lVG9TZXR9LiBzcmM9ICR7bWVkaWFSZWYuc3JjfSBSZWFzb246ICR7d2h5fWAsXG4gICAgbW91bnRUaW1lXG4gIH0pO1xuICBtZWRpYVJlZi5jdXJyZW50VGltZSA9IHRpbWVUb1NldDtcbiAgcmV0dXJuIHRpbWVUb1NldDtcbn07XG5cbi8vIHNyYy91c2UtbWVkaWEtYnVmZmVyaW5nLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OCwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxNCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhQnVmZmVyaW5nID0gKHtcbiAgZWxlbWVudCxcbiAgc2hvdWxkQnVmZmVyLFxuICBpc1ByZW1vdW50aW5nLFxuICBpc1Bvc3Rtb3VudGluZyxcbiAgbG9nTGV2ZWwsXG4gIG1vdW50VGltZSxcbiAgc3JjXG59KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IHVzZUJ1ZmZlclN0YXRlKCk7XG4gIGNvbnN0IFtpc0J1ZmZlcmluZywgc2V0SXNCdWZmZXJpbmddID0gdXNlU3RhdGUxNChmYWxzZSk7XG4gIHVzZUVmZmVjdDgoKCkgPT4ge1xuICAgIGxldCBjbGVhbnVwRm5zID0gW107XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBlbGVtZW50O1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNob3VsZEJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNQcmVtb3VudGluZyB8fCBpc1Bvc3Rtb3VudGluZykge1xuICAgICAgaWYgKChpc1ByZW1vdW50aW5nIHx8IGlzUG9zdG1vdW50aW5nKSAmJiBjdXJyZW50LnJlYWR5U3RhdGUgPCBjdXJyZW50LkhBVkVfRlVUVVJFX0RBVEEpIHtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveC9cIikpIHtcbiAgICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQ2FsbGluZyAubG9hZCgpIG9uICR7Y3VycmVudC5zcmN9IGJlY2F1c2UgcmVhZHlTdGF0ZSBpcyAke2N1cnJlbnQucmVhZHlTdGF0ZX0gYW5kIGl0IGlzIG5vdCBGaXJlZm94LiBFbGVtZW50IGlzIHByZW1vdW50ZWQgJHtjdXJyZW50LnBsYXliYWNrUmF0ZX1gLFxuICAgICAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGxheWJhY2tSYXRlID0gY3VycmVudC5wbGF5YmFja1JhdGU7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgICAgY3VycmVudC5wbGF5YmFja1JhdGUgPSBwcmV2aW91c1BsYXliYWNrUmF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGVhbnVwID0gKHJlYXNvbikgPT4ge1xuICAgICAgbGV0IGRpZERvU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICBjbGVhbnVwRm5zLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICAgIGZuKHJlYXNvbik7XG4gICAgICAgIGRpZERvU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucyA9IFtdO1xuICAgICAgc2V0SXNCdWZmZXJpbmcoKHByZXZpb3VzKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgIGRpZERvU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmIChkaWREb1NvbWV0aGluZykge1xuICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbm1hcmtpbmcgYXMgYnVmZmVyaW5nOiAke2N1cnJlbnQuc3JjfS4gUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICAgIHRhZzogXCJidWZmZXJcIixcbiAgICAgICAgICBtb3VudFRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBibG9ja01lZGlhID0gKHJlYXNvbikgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcodHJ1ZSk7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbWVzc2FnZTogYE1hcmtpbmcgYXMgYnVmZmVyaW5nOiAke2N1cnJlbnQuc3JjfS4gUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICB0YWc6IFwiYnVmZmVyXCIsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IHVuYmxvY2sgfSA9IGJ1ZmZlci5kZWxheVBsYXliYWNrKCk7XG4gICAgICBjb25zdCBvbkNhblBsYXkgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoJ1wiY2FucGxheVwiIHdhcyBmaXJlZCcpO1xuICAgICAgICBpbml0KCk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25FcnJvciA9ICgpID0+IHtcbiAgICAgICAgY2xlYW51cCgnXCJlcnJvclwiIGV2ZW50IHdhcyBvY2N1cnJlZCcpO1xuICAgICAgICBpbml0KCk7XG4gICAgICB9O1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkNhblBsYXksIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjbGVhbnVwRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIG9uQ2FuUGxheSk7XG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjbGVhbnVwRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKChjbGVhbnVwUmVhc29uKSA9PiB7XG4gICAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZTogYFVuYmxvY2tpbmcgJHtjdXJyZW50LnNyY30gZnJvbSBidWZmZXIuIFJlYXNvbjogJHtjbGVhbnVwUmVhc29ufWAsXG4gICAgICAgICAgdGFnOiBcImJ1ZmZlclwiLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgdW5ibG9jaygpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQucmVhZHlTdGF0ZSA8IGN1cnJlbnQuSEFWRV9GVVRVUkVfREFUQSkge1xuICAgICAgICBibG9ja01lZGlhKGByZWFkeVN0YXRlIGlzICR7Y3VycmVudC5yZWFkeVN0YXRlfSwgd2hpY2ggaXMgbGVzcyB0aGFuIEhBVkVfRlVUVVJFX0RBVEFgKTtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveC9cIikpIHtcbiAgICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQ2FsbGluZyAubG9hZCgpIG9uICR7c3JjfSBiZWNhdXNlIHJlYWR5U3RhdGUgaXMgJHtjdXJyZW50LnJlYWR5U3RhdGV9IGFuZCBpdCBpcyBub3QgRmlyZWZveC4gJHtjdXJyZW50LnBsYXliYWNrUmF0ZX1gLFxuICAgICAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGxheWJhY2tSYXRlID0gY3VycmVudC5wbGF5YmFja1JhdGU7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgICAgY3VycmVudC5wbGF5YmFja1JhdGUgPSBwcmV2aW91c1BsYXliYWNrUmF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgICAgIGJsb2NrTWVkaWEoJ1wid2FpdGluZ1wiIGV2ZW50IHdhcyBmaXJlZCcpO1xuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsIG9uV2FpdGluZyk7XG4gICAgICAgIGNsZWFudXBGbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLCBvbldhaXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGluaXQoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cChcImVsZW1lbnQgd2FzIHVubW91bnRlZCBvciBwcm9wIGNoYW5nZWRcIik7XG4gICAgfTtcbiAgfSwgW1xuICAgIGJ1ZmZlcixcbiAgICBzcmMsXG4gICAgZWxlbWVudCxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIHNob3VsZEJ1ZmZlcixcbiAgICBtb3VudFRpbWVcbiAgXSk7XG4gIHJldHVybiBpc0J1ZmZlcmluZztcbn07XG5cbi8vIHNyYy91c2UtcmVxdWVzdC12aWRlby1jYWxsYmFjay10aW1lLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OSwgdXNlUmVmIGFzIHVzZVJlZjEwIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlUmVxdWVzdFZpZGVvQ2FsbGJhY2tUaW1lID0gKHtcbiAgbWVkaWFSZWYsXG4gIG1lZGlhVHlwZSxcbiAgbGFzdFNlZWssXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG59KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlUmVmMTAobnVsbCk7XG4gIHVzZUVmZmVjdDkoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gbWVkaWFSZWY7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSB7XG4gICAgICAgIHRpbWU6IGN1cnJlbnQuY3VycmVudFRpbWUsXG4gICAgICAgIGxhc3RVcGRhdGU6IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9UYWcgPSBjdXJyZW50O1xuICAgIGlmICghdmlkZW9UYWcucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgIGlmICghdmlkZW9UYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2IgPSB2aWRlb1RhZy5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvMikgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFRpbWUuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBNYXRoLmFicyhjdXJyZW50VGltZS5jdXJyZW50LnRpbWUgLSBpbmZvMi5tZWRpYVRpbWUpO1xuICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2VUb0xhc3RTZWVrID0gTWF0aC5hYnMobGFzdFNlZWsuY3VycmVudCA9PT0gbnVsbCA/IEluZmluaXR5IDogaW5mbzIubWVkaWFUaW1lIC0gbGFzdFNlZWsuY3VycmVudCk7XG4gICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPiAwLjUgJiYgZGlmZmVyZW5jZVRvTGFzdFNlZWsgPiAwLjUgJiYgaW5mbzIubWVkaWFUaW1lID4gY3VycmVudFRpbWUuY3VycmVudC50aW1lKSB7XG4gICAgICAgICAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0ge1xuICAgICAgICAgIHRpbWU6IGluZm8yLm1lZGlhVGltZSxcbiAgICAgICAgICBsYXN0VXBkYXRlOiBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0KCk7XG4gICAgICB9KTtcbiAgICAgIGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgdmlkZW9UYWcuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKGNiKTtcbiAgICAgICAgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXF1ZXN0KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH07XG4gIH0sIFtsYXN0U2VlaywgbWVkaWFSZWYsIG1lZGlhVHlwZSwgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWRdKTtcbiAgcmV0dXJuIGN1cnJlbnRUaW1lO1xufTtcblxuLy8gc3JjL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgZWFzaW5nIH0gPSBvcHRpb25zO1xuICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gIGNvbnN0IFtpbnB1dE1pbiwgaW5wdXRNYXhdID0gaW5wdXRSYW5nZTtcbiAgY29uc3QgW291dHB1dE1pbiwgb3V0cHV0TWF4XSA9IG91dHB1dFJhbmdlO1xuICBpZiAocmVzdWx0IDwgaW5wdXRNaW4pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJleHRlbmRcIikge31cbiAgfVxuICBpZiAocmVzdWx0ID4gaW5wdXRNYXgpIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiZXh0ZW5kXCIpIHt9XG4gIH1cbiAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgfVxuICByZXN1bHQgPSAocmVzdWx0IC0gaW5wdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcbiAgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpIHtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7aSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgaWYgKGlucHV0UmFuZ2VbaV0gPj0gaW5wdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSAtIDE7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkSW5wdXRSYW5nZShhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDE7aSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmICghKGFycltpXSA+IGFycltpIC0gMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0UmFuZ2UgbXVzdCBiZSBzdHJpY3RseSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbmZpbml0ZVJhbmdlKG5hbWUsIGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGVsZW1lbnRzXCIpO1xuICB9XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgZmluaXRlIG51bWJlcnMsIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG91dHB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIpIGFuZCBvdXRwdXRSYW5nZSAoXCIgKyBvdXRwdXRSYW5nZS5sZW5ndGggKyBcIikgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjaGVja0luZmluaXRlUmFuZ2UoXCJpbnB1dFJhbmdlXCIsIGlucHV0UmFuZ2UpO1xuICBjaGVja0luZmluaXRlUmFuZ2UoXCJvdXRwdXRSYW5nZVwiLCBvdXRwdXRSYW5nZSk7XG4gIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGlucHV0UmFuZ2UpO1xuICBjb25zdCBlYXNpbmcgPSBvcHRpb25zPy5lYXNpbmcgPz8gKChudW0pID0+IG51bSk7XG4gIGxldCBleHRyYXBvbGF0ZUxlZnQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdDtcbiAgfVxuICBsZXQgZXh0cmFwb2xhdGVSaWdodCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZVJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZVJpZ2h0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0O1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGludGVycG9sYXRlIGFuIGlucHV0IHdoaWNoIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBbaW5wdXRSYW5nZVtyYW5nZV0sIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIFtvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV1dLCB7XG4gICAgZWFzaW5nLFxuICAgIGV4dHJhcG9sYXRlTGVmdCxcbiAgICBleHRyYXBvbGF0ZVJpZ2h0XG4gIH0pO1xufVxuXG4vLyBzcmMvdmlkZW8vZ2V0LWN1cnJlbnQtdGltZS50c1xudmFyIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkID0gKHtcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIHJldHVybiBpbnRlcnBvbGF0ZShmcmFtZSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIDFdLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgcGxheWJhY2tSYXRlXSk7XG59O1xudmFyIGdldE1lZGlhVGltZSA9ICh7XG4gIGZwcyxcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkRnJhbWUgPSBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHN0YXJ0RnJvbVxuICB9KTtcbiAgY29uc3QgbXNQZXJGcmFtZSA9IDEwMDAgLyBmcHM7XG4gIHJldHVybiBleHBlY3RlZEZyYW1lICogbXNQZXJGcmFtZSAvIDEwMDA7XG59O1xuXG4vLyBzcmMvd2Fybi1hYm91dC1ub24tc2Vla2FibGUtbWVkaWEudHNcbnZhciBhbHJlYWR5V2FybmVkID0ge307XG52YXIgd2FybkFib3V0Tm9uU2Vla2FibGVNZWRpYSA9IChyZWYsIHR5cGUpID0+IHtcbiAgaWYgKHJlZiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFscmVhZHlXYXJuZWRbcmVmLnNyY10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0OiByZWYuc2Vla2FibGUuc3RhcnQoMCksIGVuZDogcmVmLnNlZWthYmxlLmVuZCgwKSB9O1xuICBpZiAocmFuZ2Uuc3RhcnQgPT09IDAgJiYgcmFuZ2UuZW5kID09PSAwKSB7XG4gICAgY29uc3QgbXNnID0gW1xuICAgICAgYFRoZSBtZWRpYSAke3JlZi5zcmN9IGNhbm5vdCBiZSBzZWVrZWQuIFRoaXMgY291bGQgYmUgb25lIG9mIGZldyByZWFzb25zOmAsXG4gICAgICBcIjEpIFRoZSBtZWRpYSByZXNvdXJjZSB3YXMgcmVwbGFjZWQgd2hpbGUgdGhlIHZpZGVvIGlzIHBsYXlpbmcgYnV0IGl0IHdhcyBub3QgbG9hZGVkIHlldC5cIixcbiAgICAgIFwiMikgVGhlIG1lZGlhIGRvZXMgbm90IHN1cHBvcnQgc2Vla2luZy5cIixcbiAgICAgIFwiMykgVGhlIG1lZGlhIHdhcyBsb2FkZWQgd2l0aCBzZWN1cml0eSBoZWFkZXJzIHBydmVudGluZyBpdCBmcm9tIGJlaW5nIGluY2x1ZGVkLlwiLFxuICAgICAgXCJQbGVhc2Ugc2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvbm9uLXNlZWthYmxlLW1lZGlhIGZvciBhc3Npc3RhbmNlLlwiXG4gICAgXS5qb2luKGBcbmApO1xuICAgIGlmICh0eXBlID09PSBcImNvbnNvbGUtZXJyb3JcIikge1xuICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb25zb2xlLXdhcm5pbmdcIikge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgbWVkaWEgJHtyZWYuc3JjfSBkb2VzIG5vdCBzdXBwb3J0IHNlZWtpbmcuIFRoZSB2aWRlbyB3aWxsIHJlbmRlciBmaW5lLCBidXQgbWF5IG5vdCBwbGF5IGNvcnJlY3RseSBpbiB0aGUgUmVtb3Rpb24gU3R1ZGlvIGFuZCBpbiB0aGUgPFBsYXllcj4uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL25vbi1zZWVrYWJsZS1tZWRpYSBmb3IgYW4gZXhwbGFuYXRpb24uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBhbHJlYWR5V2FybmVkW3JlZi5zcmNdID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1wbGF5YmFjay50c1xudmFyIHVzZU1lZGlhUGxheWJhY2sgPSAoe1xuICBtZWRpYVJlZixcbiAgc3JjLFxuICBtZWRpYVR5cGUsXG4gIHBsYXliYWNrUmF0ZTogbG9jYWxQbGF5YmFja1JhdGUsXG4gIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gIGFjY2VwdGFibGVUaW1lc2hpZnQsXG4gIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgaXNQcmVtb3VudGluZyxcbiAgaXNQb3N0bW91bnRpbmcsXG4gIG9uQXV0b1BsYXlFcnJvclxufSkgPT4ge1xuICBjb25zdCB7IHBsYXliYWNrUmF0ZTogZ2xvYmFsUGxheWJhY2tSYXRlIH0gPSB1c2VDb250ZXh0MjIoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgW3BsYXlpbmddID0gdXNlUGxheWluZ1N0YXRlKCk7XG4gIGNvbnN0IGJ1ZmZlcmluZyA9IHVzZUNvbnRleHQyMihCdWZmZXJpbmdDb250ZXh0UmVhY3QpO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgbGFzdFNlZWtEdWVUb1NoaWZ0ID0gdXNlUmVmMTEobnVsbCk7XG4gIGNvbnN0IGxhc3RTZWVrID0gdXNlUmVmMTEobnVsbCk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGlmICghYnVmZmVyaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlTWVkaWFQbGF5YmFjayBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgPEJ1ZmZlcmluZ0NvbnRleHQ+XCIpO1xuICB9XG4gIGNvbnN0IGlzVmFyaWFibGVGcHNWaWRlb01hcCA9IHVzZVJlZjExKHt9KTtcbiAgY29uc3Qgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQgPSB1c2VDYWxsYmFjazEwKCgpID0+IHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNWYXJpYWJsZUZwc1ZpZGVvTWFwLmN1cnJlbnRbc3JjXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBMb2cudmVyYm9zZSh7IGxvZ0xldmVsLCB0YWc6IG51bGwgfSwgYERldGVjdGVkICR7c3JjfSBhcyBhIHZhcmlhYmxlIEZQUyB2aWRlby4gRGlzYWJsaW5nIGJ1ZmZlcmluZyB3aGlsZSBzZWVraW5nLmApO1xuICAgIGlzVmFyaWFibGVGcHNWaWRlb01hcC5jdXJyZW50W3NyY10gPSB0cnVlO1xuICB9LCBbbG9nTGV2ZWwsIHNyY10pO1xuICBjb25zdCBydmNDdXJyZW50VGltZSA9IHVzZVJlcXVlc3RWaWRlb0NhbGxiYWNrVGltZSh7XG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIGxhc3RTZWVrLFxuICAgIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG4gIH0pO1xuICBjb25zdCBtZWRpYVRhZ0N1cnJlbnRUaW1lID0gdXNlQ3VycmVudFRpbWVPZk1lZGlhVGFnV2l0aFVwZGF0ZVRpbWVTdGFtcChtZWRpYVJlZik7XG4gIGNvbnN0IGRlc2lyZWRVbmNsYW1wZWRUaW1lID0gZ2V0TWVkaWFUaW1lKHtcbiAgICBmcmFtZSxcbiAgICBwbGF5YmFja1JhdGU6IGxvY2FsUGxheWJhY2tSYXRlLFxuICAgIHN0YXJ0RnJvbTogLW1lZGlhU3RhcnRzQXQsXG4gICAgZnBzXG4gIH0pO1xuICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nID0gdXNlTWVkaWFCdWZmZXJpbmcoe1xuICAgIGVsZW1lbnQ6IG1lZGlhUmVmLFxuICAgIHNob3VsZEJ1ZmZlcjogcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGlzUHJlbW91bnRpbmcsXG4gICAgaXNQb3N0bW91bnRpbmcsXG4gICAgbG9nTGV2ZWwsXG4gICAgbW91bnRUaW1lLFxuICAgIHNyYzogc3JjID8/IG51bGxcbiAgfSk7XG4gIGNvbnN0IHsgYnVmZmVyVW50aWxGaXJzdEZyYW1lLCBpc0J1ZmZlcmluZyB9ID0gdXNlQnVmZmVyVW50aWxGaXJzdEZyYW1lKHtcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgY29uc3QgcGxheWJhY2tSYXRlID0gbG9jYWxQbGF5YmFja1JhdGUgKiBnbG9iYWxQbGF5YmFja1JhdGU7XG4gIGNvbnN0IGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uID0gKCgpID0+IHtcbiAgICBjb25zdCBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfTk9STUFMX1BMQVlCQUNLID0gMC40NTtcbiAgICBjb25zdCBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfQU1QTElGSUNBVElPTiA9IERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlRfV0lUSF9OT1JNQUxfUExBWUJBQ0sgKyAwLjI7XG4gICAgY29uc3QgZGVmYXVsdEFjY2VwdGFibGVUaW1lc2hpZnQgPSBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfQU1QTElGSUNBVElPTjtcbiAgICBpZiAobWVkaWFSZWYuY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihtZWRpYVJlZi5jdXJyZW50LmR1cmF0aW9uLCBhY2NlcHRhYmxlVGltZXNoaWZ0ID8/IGRlZmF1bHRBY2NlcHRhYmxlVGltZXNoaWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY2VwdGFibGVUaW1lc2hpZnQgPz8gZGVmYXVsdEFjY2VwdGFibGVUaW1lc2hpZnQ7XG4gIH0pKCk7XG4gIGNvbnN0IGlzUGxheWVyQnVmZmVyaW5nID0gdXNlSXNQbGF5ZXJCdWZmZXJpbmcoYnVmZmVyaW5nKTtcbiAgdXNlRWZmZWN0MTAoKCkgPT4ge1xuICAgIGlmIChtZWRpYVJlZi5jdXJyZW50Py5wYXVzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwbGF5aW5nKSB7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgdGFnOiBcInBhdXNlXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBQYXVzaW5nICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfSBiZWNhdXNlICR7aXNQcmVtb3VudGluZyA/IFwibWVkaWEgaXMgcHJlbW91bnRpbmdcIiA6IGlzUG9zdG1vdW50aW5nID8gXCJtZWRpYSBpcyBwb3N0bW91bnRpbmdcIiA6IFwiUGxheWVyIGlzIG5vdCBwbGF5aW5nXCJ9YCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQ/LnBhdXNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQgPSBpc01lZGlhVGFnQnVmZmVyaW5nIHx8IGlzQnVmZmVyaW5nKCk7XG4gICAgY29uc3QgcGxheWVyQnVmZmVyaW5nTm90U3RhdGVCdXRMaXZlID0gYnVmZmVyaW5nLmJ1ZmZlcmluZy5jdXJyZW50O1xuICAgIGlmIChwbGF5ZXJCdWZmZXJpbmdOb3RTdGF0ZUJ1dExpdmUgJiYgIWlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQpIHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB0YWc6IFwicGF1c2VcIixcbiAgICAgICAgbWVzc2FnZTogYFBhdXNpbmcgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9IGJlY2F1c2UgcGxheWVyIGlzIGJ1ZmZlcmluZyBidXQgbWVkaWEgdGFnIGlzIG5vdGAsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBtZWRpYVJlZi5jdXJyZW50Py5wYXVzZSgpO1xuICAgIH1cbiAgfSwgW1xuICAgIGlzQnVmZmVyaW5nLFxuICAgIGlzTWVkaWFUYWdCdWZmZXJpbmcsXG4gICAgYnVmZmVyaW5nLFxuICAgIGlzUGxheWVyQnVmZmVyaW5nLFxuICAgIGlzUHJlbW91bnRpbmcsXG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG1vdW50VGltZSxcbiAgICBwbGF5aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nXG4gIF0pO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIHVzZUxheW91dEVmZmVjdDcoKCkgPT4ge1xuICAgIGNvbnN0IHBsYXliYWNrUmF0ZVRvU2V0ID0gTWF0aC5tYXgoMCwgcGxheWJhY2tSYXRlKTtcbiAgICBpZiAobWVkaWFSZWYuY3VycmVudCAmJiBtZWRpYVJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSAhPT0gcGxheWJhY2tSYXRlVG9TZXQpIHtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQucGxheWJhY2tSYXRlID0gcGxheWJhY2tSYXRlVG9TZXQ7XG4gICAgfVxuICB9LCBbbWVkaWFSZWYsIHBsYXliYWNrUmF0ZV0pO1xuICB1c2VFZmZlY3QxMCgoKSA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IG1lZGlhVHlwZSA9PT0gXCJhdWRpb1wiID8gXCI8SHRtbDVBdWRpbz5cIiA6IFwiPEh0bWw1VmlkZW8+XCI7XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vICR7bWVkaWFUeXBlfSByZWYgZm91bmRgKTtcbiAgICB9XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJ3NyYycgYXR0cmlidXRlIHdhcyBwYXNzZWQgdG8gdGhlICR7dGFnTmFtZX0gZWxlbWVudC5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBjb25zdCBzaG91bGRCZVRpbWUgPSAhTnVtYmVyLmlzTmFOKGR1cmF0aW9uKSAmJiBOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pID8gTWF0aC5taW4oZHVyYXRpb24sIGRlc2lyZWRVbmNsYW1wZWRUaW1lKSA6IGRlc2lyZWRVbmNsYW1wZWRUaW1lO1xuICAgIGNvbnN0IG1lZGlhVGFnVGltZSA9IG1lZGlhVGFnQ3VycmVudFRpbWUuY3VycmVudC50aW1lO1xuICAgIGNvbnN0IHJ2Y1RpbWUgPSBydmNDdXJyZW50VGltZS5jdXJyZW50Py50aW1lID8/IG51bGw7XG4gICAgY29uc3QgaXNWYXJpYWJsZUZwc1ZpZGVvID0gaXNWYXJpYWJsZUZwc1ZpZGVvTWFwLmN1cnJlbnRbc3JjXTtcbiAgICBjb25zdCB0aW1lU2hpZnRNZWRpYVRhZyA9IE1hdGguYWJzKHNob3VsZEJlVGltZSAtIG1lZGlhVGFnVGltZSk7XG4gICAgY29uc3QgdGltZVNoaWZ0UnZjVGFnID0gcnZjVGltZSA/IE1hdGguYWJzKHNob3VsZEJlVGltZSAtIHJ2Y1RpbWUpIDogbnVsbDtcbiAgICBjb25zdCBtb3N0UmVjZW50VGltZXNoaWZ0ID0gcnZjQ3VycmVudFRpbWUuY3VycmVudD8ubGFzdFVwZGF0ZSAmJiBydmNDdXJyZW50VGltZS5jdXJyZW50LnRpbWUgPiBtZWRpYVRhZ0N1cnJlbnRUaW1lLmN1cnJlbnQubGFzdFVwZGF0ZSA/IHRpbWVTaGlmdFJ2Y1RhZyA6IHRpbWVTaGlmdE1lZGlhVGFnO1xuICAgIGNvbnN0IHRpbWVTaGlmdCA9IHRpbWVTaGlmdFJ2Y1RhZyAmJiAhaXNWYXJpYWJsZUZwc1ZpZGVvID8gbW9zdFJlY2VudFRpbWVzaGlmdCA6IHRpbWVTaGlmdE1lZGlhVGFnO1xuICAgIGlmICh0aW1lU2hpZnQgPiBhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiAmJiBsYXN0U2Vla0R1ZVRvU2hpZnQuY3VycmVudCAhPT0gc2hvdWxkQmVUaW1lKSB7XG4gICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgIG1lZGlhUmVmOiBtZWRpYVJlZi5jdXJyZW50LFxuICAgICAgICB0aW1lOiBzaG91bGRCZVRpbWUsXG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB3aHk6IGBiZWNhdXNlIHRpbWUgc2hpZnQgaXMgdG9vIGJpZy4gc2hvdWxkQmVUaW1lID0gJHtzaG91bGRCZVRpbWV9LCBpc1RpbWUgPSAke21lZGlhVGFnVGltZX0sIHJlcXVlc3RWaWRlb0NhbGxiYWNrVGltZSA9ICR7cnZjVGltZX0sIHRpbWVTaGlmdCA9ICR7dGltZVNoaWZ0fSR7aXNWYXJpYWJsZUZwc1ZpZGVvID8gXCIsIGlzVmFyaWFibGVGcHNWaWRlbyA9IHRydWVcIiA6IFwiXCJ9LCBpc1ByZW1vdW50aW5nID0gJHtpc1ByZW1vdW50aW5nfSwgaXNQb3N0bW91bnRpbmcgPSAke2lzUG9zdG1vdW50aW5nfSwgcGF1c2VXaGVuQnVmZmVyaW5nID0gJHtwYXVzZVdoZW5CdWZmZXJpbmd9YCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIGxhc3RTZWVrRHVlVG9TaGlmdC5jdXJyZW50ID0gbGFzdFNlZWsuY3VycmVudDtcbiAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgIGlmIChwbGF5YmFja1JhdGUgPiAwKSB7XG4gICAgICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lKHNob3VsZEJlVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQucGF1c2VkKSB7XG4gICAgICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgICAgICBtZWRpYVJlZixcbiAgICAgICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICAgICAgcmVhc29uOiBcInBsYXllciBpcyBwbGF5aW5nIGJ1dCBtZWRpYSB0YWcgaXMgcGF1c2VkLCBhbmQganVzdCBzZWVrZWRcIixcbiAgICAgICAgICAgIGlzUGxheWVyOiBlbnYuaXNQbGF5ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yKSB7XG4gICAgICAgIHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEobWVkaWFSZWYuY3VycmVudCwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciA/IFwiY29uc29sZS13YXJuaW5nXCIgOiBcImNvbnNvbGUtZXJyb3JcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlZWtUaHJlc2hvbGQgPSBwbGF5aW5nID8gMC4xNSA6IDAuMDE7XG4gICAgY29uc3QgbWFrZXNTZW5zZVRvU2VlayA9IE1hdGguYWJzKG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgLSBzaG91bGRCZVRpbWUpID4gc2Vla1RocmVzaG9sZDtcbiAgICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkID0gaXNNZWRpYVRhZ0J1ZmZlcmluZyB8fCBpc0J1ZmZlcmluZygpO1xuICAgIGNvbnN0IGlzU29tZXRoaW5nRWxzZUJ1ZmZlcmluZyA9IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCAmJiAhaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZDtcbiAgICBpZiAoIXBsYXlpbmcgfHwgaXNTb21ldGhpbmdFbHNlQnVmZmVyaW5nKSB7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgICAgbWVkaWFSZWY6IG1lZGlhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIHdoeTogYG5vdCBwbGF5aW5nIG9yIHNvbWV0aGluZyBlbHNlIGlzIGJ1ZmZlcmluZy4gdGltZSBvZmZzZXQgaXMgb3ZlciBzZWVrIHRocmVzaG9sZCAoJHtzZWVrVGhyZXNob2xkfSlgLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwbGF5aW5nIHx8IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXVzZWRDb25kaXRpb24gPSBtZWRpYVJlZi5jdXJyZW50LnBhdXNlZCAmJiAhbWVkaWFSZWYuY3VycmVudC5lbmRlZDtcbiAgICBjb25zdCBmaXJzdEZyYW1lQ29uZGl0aW9uID0gYWJzb2x1dGVGcmFtZSA9PT0gMDtcbiAgICBpZiAocGF1c2VkQ29uZGl0aW9uIHx8IGZpcnN0RnJhbWVDb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IHJlYXNvbiA9IHBhdXNlZENvbmRpdGlvbiA/IFwibWVkaWEgdGFnIGlzIHBhdXNlZFwiIDogXCJhYnNvbHV0ZSBmcmFtZSBpcyAwXCI7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgICAgbWVkaWFSZWY6IG1lZGlhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIHdoeTogYGlzIG92ZXIgdGltZXNoaWZ0IHRocmVzaG9sZCAodGhyZXNob2xkID0gJHtzZWVrVGhyZXNob2xkfSkgYW5kICR7cmVhc29ufWAsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgIG1lZGlhUmVmLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgcmVhc29uOiBgcGxheWVyIGlzIHBsYXlpbmcgYW5kICR7cmVhc29ufWAsXG4gICAgICAgIGlzUGxheWVyOiBlbnYuaXNQbGF5ZXJcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc1ZhcmlhYmxlRnBzVmlkZW8gJiYgcGxheWJhY2tSYXRlID4gMCkge1xuICAgICAgICBidWZmZXJVbnRpbEZpcnN0RnJhbWUoc2hvdWxkQmVUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uLFxuICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZSxcbiAgICBidWZmZXJpbmcuYnVmZmVyaW5nLFxuICAgIHJ2Y0N1cnJlbnRUaW1lLFxuICAgIGxvZ0xldmVsLFxuICAgIGRlc2lyZWRVbmNsYW1wZWRUaW1lLFxuICAgIGlzQnVmZmVyaW5nLFxuICAgIGlzTWVkaWFUYWdCdWZmZXJpbmcsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHBsYXlpbmcsXG4gICAgc3JjLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBtb3VudFRpbWUsXG4gICAgbWVkaWFUYWdDdXJyZW50VGltZSxcbiAgICBlbnYuaXNQbGF5ZXJcbiAgXSk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLXRhZy50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjMsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhVGFnID0gKHtcbiAgbWVkaWFSZWYsXG4gIGlkLFxuICBtZWRpYVR5cGUsXG4gIG9uQXV0b1BsYXlFcnJvcixcbiAgaXNQcmVtb3VudGluZyxcbiAgaXNQb3N0bW91bnRpbmdcbn0pID0+IHtcbiAgY29uc3QgeyBhdWRpb0FuZFZpZGVvVGFncywgaW1wZXJhdGl2ZVBsYXlpbmcgfSA9IHVzZUNvbnRleHQyMyhUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IG1vdW50VGltZSA9IHVzZU1vdW50VGltZSgpO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIHVzZUVmZmVjdDExKCgpID0+IHtcbiAgICBjb25zdCB0YWcgPSB7XG4gICAgICBpZCxcbiAgICAgIHBsYXk6IChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKCFpbXBlcmF0aXZlUGxheWluZy5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZW1vdW50aW5nIHx8IGlzUG9zdG1vdW50aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yKHtcbiAgICAgICAgICBtZWRpYVJlZixcbiAgICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgICAgb25BdXRvUGxheUVycm9yLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgaXNQbGF5ZXI6IGVudi5pc1BsYXllclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQucHVzaCh0YWcpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhdWRpb0FuZFZpZGVvVGFncy5jdXJyZW50ID0gYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudC5maWx0ZXIoKGEpID0+IGEuaWQgIT09IGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYXVkaW9BbmRWaWRlb1RhZ3MsXG4gICAgaWQsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBpbXBlcmF0aXZlUGxheWluZyxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1vdW50VGltZSxcbiAgICBlbnYuaXNQbGF5ZXJcbiAgXSk7XG59O1xuXG4vLyBzcmMvdm9sdW1lLXBvc2l0aW9uLXN0YXRlLnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNywgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjQsIHVzZU1lbW8gYXMgdXNlTWVtbzIwIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTWVkaWFWb2x1bWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE3KHtcbiAgbWVkaWFNdXRlZDogZmFsc2UsXG4gIG1lZGlhVm9sdW1lOiAxXG59KTtcbnZhciBTZXRNZWRpYVZvbHVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTcoe1xuICBzZXRNZWRpYU11dGVkOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfSxcbiAgc2V0TWVkaWFWb2x1bWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9XG59KTtcbnZhciB1c2VNZWRpYVZvbHVtZVN0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IG1lZGlhVm9sdW1lIH0gPSB1c2VDb250ZXh0MjQoTWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgY29uc3QgeyBzZXRNZWRpYVZvbHVtZSB9ID0gdXNlQ29udGV4dDI0KFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMjAoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFWb2x1bWUsIHNldE1lZGlhVm9sdW1lXTtcbiAgfSwgW21lZGlhVm9sdW1lLCBzZXRNZWRpYVZvbHVtZV0pO1xufTtcbnZhciB1c2VNZWRpYU11dGVkU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDI0KE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0TWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDI0KFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMjAoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFNdXRlZCwgc2V0TWVkaWFNdXRlZF07XG4gIH0sIFttZWRpYU11dGVkLCBzZXRNZWRpYU11dGVkXSk7XG59O1xuXG4vLyBzcmMvdm9sdW1lLXNhZmVndWFyZC50c1xudmFyIHdhcm5BYm91dFRvb0hpZ2hWb2x1bWUgPSAodm9sdW1lKSA9PiB7XG4gIGlmICh2b2x1bWUgPj0gMTAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBWb2x1bWUgd2FzIHNldCB0byAke3ZvbHVtZX0sIGJ1dCByZWd1bGFyIHZvbHVtZSBpcyAxLCBub3QgMTAwLiBEaWQgeW91IGZvcmdldCB0byBkaXZpZGUgYnkgMTAwPyBTZXQgYSB2b2x1bWUgb2YgbGVzcyB0aGFuIDEwMCB0byBkaXNtaXNzIHRoaXMgZXJyb3IuYCk7XG4gIH1cbn07XG5cbi8vIHNyYy9hdWRpby9BdWRpb0ZvclByZXZpZXcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBdWRpb0ZvckRldmVsb3BtZW50Rm9yd2FyZFJlZkZ1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgW2luaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHNdID0gdXNlU3RhdGUxNShwcm9wcy5zaG91bGRQcmVNb3VudEF1ZGlvVGFncyk7XG4gIGlmIChwcm9wcy5zaG91bGRQcmVNb3VudEF1ZGlvVGFncyAhPT0gaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjaGFuZ2UgdGhlIGJlaGF2aW9yIGZvciBwcmUtbW91bnRpbmcgYXVkaW8gdGFncyBkeW5hbWljYWxseS5cIik7XG4gIH1cbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBzaG91bGRQcmVNb3VudEF1ZGlvVGFncyxcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBzdGFjayxcbiAgICBjcm9zc09yaWdpbixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICB1c2VXZWJBdWRpb0FwaSxcbiAgICBvbkVycm9yLFxuICAgIG9uTmF0aXZlRXJyb3IsXG4gICAgYXVkaW9TdHJlYW1JbmRleCxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IF9wcm9wc1ZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFfcHJvcHNWYWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGVjaGVjayBlcnJvclwiKTtcbiAgfVxuICBjb25zdCBbbWVkaWFWb2x1bWVdID0gdXNlTWVkaWFWb2x1bWVTdGF0ZSgpO1xuICBjb25zdCBbbWVkaWFNdXRlZF0gPSB1c2VNZWRpYU11dGVkU3RhdGUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcEZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB7IGhpZGRlbiB9ID0gdXNlQ29udGV4dDI1KFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQpO1xuICBpZiAoIXNyYykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyAnc3JjJyB3YXMgcGFzc2VkIHRvIDxIdG1sNUF1ZGlvPi5cIik7XG4gIH1cbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChzcmMpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjUoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgW3RpbWVsaW5lSWRdID0gdXNlU3RhdGUxNSgoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICBjb25zdCBpc1NlcXVlbmNlSGlkZGVuID0gaGlkZGVuW3RpbWVsaW5lSWRdID8/IGZhbHNlO1xuICBjb25zdCB1c2VyUHJlZmVycmVkVm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lXG4gIH0pO1xuICB3YXJuQWJvdXRUb29IaWdoVm9sdW1lKHVzZXJQcmVmZXJyZWRWb2x1bWUpO1xuICBjb25zdCBjcm9zc09yaWdpblZhbHVlID0gZ2V0Q3Jvc3NPcmlnaW5WYWx1ZSh7XG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgcmVxdWVzdHNWaWRlb0ZyYW1lOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgcHJvcHNUb1Bhc3MgPSB1c2VNZW1vMjEoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBtdXRlZDogbXV0ZWQgfHwgbWVkaWFNdXRlZCB8fCBpc1NlcXVlbmNlSGlkZGVuIHx8IHVzZXJQcmVmZXJyZWRWb2x1bWUgPD0gMCxcbiAgICAgIHNyYzogcHJlbG9hZGVkU3JjLFxuICAgICAgbG9vcDogX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luVmFsdWUsXG4gICAgICAuLi5uYXRpdmVQcm9wc1xuICAgIH07XG4gIH0sIFtcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgaXNTZXF1ZW5jZUhpZGRlbixcbiAgICBtZWRpYU11dGVkLFxuICAgIG11dGVkLFxuICAgIG5hdGl2ZVByb3BzLFxuICAgIHByZWxvYWRlZFNyYyxcbiAgICB1c2VyUHJlZmVycmVkVm9sdW1lLFxuICAgIGNyb3NzT3JpZ2luVmFsdWVcbiAgXSk7XG4gIGNvbnN0IGlkID0gdXNlTWVtbzIxKCgpID0+IGBhdWRpby0ke3JhbmRvbShzcmMgPz8gXCJcIil9LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc30tbXV0ZWQ6JHtwcm9wcy5tdXRlZH0tbG9vcDoke3Byb3BzLmxvb3B9YCwgW1xuICAgIHNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzLFxuICAgIHByb3BzLm11dGVkLFxuICAgIHByb3BzLmxvb3BcbiAgXSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MjUoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcmVkQXVkaW9Db250ZXh0IG5vdCBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB7IGVsOiBhdWRpb1JlZiwgbWVkaWFFbGVtZW50U291cmNlTm9kZSB9ID0gdXNlU2hhcmVkQXVkaW8oe1xuICAgIGF1ZDogcHJvcHNUb1Bhc3MsXG4gICAgYXVkaW9JZDogaWQsXG4gICAgcHJlbW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZylcbiAgfSk7XG4gIHVzZU1lZGlhSW5UaW1lbGluZSh7XG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lLFxuICAgIHNyYyxcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW9cIixcbiAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIGRpc3BsYXlOYW1lOiBuYW1lID8/IG51bGwsXG4gICAgaWQ6IHRpbWVsaW5lSWQsXG4gICAgc3RhY2s6IF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5OiBzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50RGlzcGxheSA/PyBudWxsLFxuICAgIHBvc3Rtb3VudERpc3BsYXk6IHNlcXVlbmNlQ29udGV4dD8ucG9zdG1vdW50RGlzcGxheSA/PyBudWxsLFxuICAgIGxvb3BEaXNwbGF5OiB1bmRlZmluZWRcbiAgfSk7XG4gIHVzZU1lZGlhUGxheWJhY2soe1xuICAgIG1lZGlhUmVmOiBhdWRpb1JlZixcbiAgICBzcmMsXG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvXCIsXG4gICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yOiBmYWxzZSxcbiAgICBhY2NlcHRhYmxlVGltZXNoaWZ0OiBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzID8/IG51bGwsXG4gICAgaXNQcmVtb3VudGluZzogQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50aW5nKSxcbiAgICBpc1Bvc3Rtb3VudGluZzogQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnBvc3Rtb3VudGluZyksXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogbnVsbFxuICB9KTtcbiAgdXNlTWVkaWFUYWcoe1xuICAgIGlkOiB0aW1lbGluZUlkLFxuICAgIGlzUG9zdG1vdW50aW5nOiBCb29sZWFuKHNlcXVlbmNlQ29udGV4dD8ucG9zdG1vdW50aW5nKSxcbiAgICBpc1ByZW1vdW50aW5nOiBCb29sZWFuKHNlcXVlbmNlQ29udGV4dD8ucHJlbW91bnRpbmcpLFxuICAgIG1lZGlhUmVmOiBhdWRpb1JlZixcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW9cIixcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG51bGxcbiAgfSk7XG4gIHVzZVZvbHVtZSh7XG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmLFxuICAgIHNvdXJjZTogbWVkaWFFbGVtZW50U291cmNlTm9kZSxcbiAgICB2b2x1bWU6IHVzZXJQcmVmZXJyZWRWb2x1bWUsXG4gICAgc2hvdWxkVXNlV2ViQXVkaW9BcGk6IHVzZVdlYkF1ZGlvQXBpID8/IGZhbHNlXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNihyZWYsICgpID0+IHtcbiAgICByZXR1cm4gYXVkaW9SZWYuY3VycmVudDtcbiAgfSwgW2F1ZGlvUmVmXSk7XG4gIGNvbnN0IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2sgPSB1c2VSZWYxMihvbkR1cmF0aW9uKTtcbiAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50ID0gb25EdXJhdGlvbjtcbiAgdXNlRWZmZWN0MTIoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gYXVkaW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LmR1cmF0aW9uKSB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTG9hZGVkTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgfTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgfTtcbiAgfSwgW2F1ZGlvUmVmLCBzcmNdKTtcbiAgaWYgKGluaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE4KFwiYXVkaW9cIiwge1xuICAgIHJlZjogYXVkaW9SZWYsXG4gICAgcHJlbG9hZDogXCJtZXRhZGF0YVwiLFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblZhbHVlLFxuICAgIC4uLnByb3BzVG9QYXNzXG4gIH0pO1xufTtcbnZhciBBdWRpb0ZvclByZXZpZXcgPSBmb3J3YXJkUmVmNChBdWRpb0ZvckRldmVsb3BtZW50Rm9yd2FyZFJlZkZ1bmN0aW9uKTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjYsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMyxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNyxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDgsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzIyLFxuICB1c2VSZWYgYXMgdXNlUmVmMTNcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTkgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBdWRpb0ZvclJlbmRlcmluZ1JlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IGF1ZGlvUmVmID0gdXNlUmVmMTMobnVsbCk7XG4gIGNvbnN0IHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgICBvbkR1cmF0aW9uLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24sXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgbmFtZSxcbiAgICBvbk5hdGl2ZUVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgYXVkaW9TdHJlYW1JbmRleCxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDI2KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MjYoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgeyBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyLCBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICBjb25zdCBpZCA9IHVzZU1lbW8yMigoKSA9PiBgYXVkaW8tJHtyYW5kb20ocHJvcHMuc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9YCwgW1xuICAgIHByb3BzLnNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDFcbiAgfSk7XG4gIHdhcm5BYm91dFRvb0hpZ2hWb2x1bWUodm9sdW1lKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTcocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIGF1ZGlvUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0MTMoKCkgPT4ge1xuICAgIGlmICghcHJvcHMuc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9hdWRpb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm11dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2b2x1bWUgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwiYXVkaW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKSxcbiAgICAgIGlkLFxuICAgICAgZnJhbWU6IGFic29sdXRlRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYUZyYW1lOiBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICB0b25lRnJlcXVlbmN5OiB0b25lRnJlcXVlbmN5ID8/IDEsXG4gICAgICBhdWRpb1N0YXJ0RnJhbWU6IE1hdGgubWF4KDAsIC0oc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMCkpLFxuICAgICAgYXVkaW9TdHJlYW1JbmRleDogYXVkaW9TdHJlYW1JbmRleCA/PyAwXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJSZW5kZXJBc3NldChpZCk7XG4gIH0sIFtcbiAgICBwcm9wcy5tdXRlZCxcbiAgICBwcm9wcy5zcmMsXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgdm9sdW1lUHJvcEZyYW1lLFxuICAgIGZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBwcm9wcy5wbGF5YmFja1JhdGUsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBhdWRpb1N0cmVhbUluZGV4XG4gIF0pO1xuICBjb25zdCB7IHNyYyB9ID0gcHJvcHM7XG4gIGNvbnN0IG5lZWRzVG9SZW5kZXJBdWRpb1RhZyA9IHJlZiB8fCBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjtcbiAgdXNlTGF5b3V0RWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5lZWRzVG9SZW5kZXJBdWRpb1RhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcjIoXCJMb2FkaW5nIDxIdG1sNUF1ZGlvPiBkdXJhdGlvbiB3aXRoIHNyYz1cIiArIHNyYywge1xuICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBhdWRpb1JlZjtcbiAgICBjb25zdCBkaWRMb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICAgIG9uRHVyYXRpb24oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgfTtcbiAgICBpZiAoY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgIG9uRHVyYXRpb24oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCk7XG4gICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICB9O1xuICB9LCBbXG4gICAgc3JjLFxuICAgIG9uRHVyYXRpb24sXG4gICAgbmVlZHNUb1JlbmRlckF1ZGlvVGFnLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBjb250aW51ZVJlbmRlcjIsXG4gICAgZGVsYXlSZW5kZXIyXG4gIF0pO1xuICBpZiAoIW5lZWRzVG9SZW5kZXJBdWRpb1RhZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoXCJhdWRpb1wiLCB7XG4gICAgcmVmOiBhdWRpb1JlZixcbiAgICAuLi5uYXRpdmVQcm9wcyxcbiAgICBvbkVycm9yOiBvbk5hdGl2ZUVycm9yXG4gIH0pO1xufTtcbnZhciBBdWRpb0ZvclJlbmRlcmluZyA9IGZvcndhcmRSZWY1KEF1ZGlvRm9yUmVuZGVyaW5nUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIwIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VDb250ZXh0MjcoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICB0cmltQmVmb3JlLFxuICAgIHRyaW1BZnRlcixcbiAgICBuYW1lLFxuICAgIHN0YWNrLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBvbkVycm9yOiBvblJlbW90aW9uRXJyb3IsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wcztcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCB7IGR1cmF0aW9ucywgc2V0RHVyYXRpb25zIH0gPSB1c2VDb250ZXh0MjcoRHVyYXRpb25zQ29udGV4dCk7XG4gIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxIdG1sNUF1ZGlvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzLnNyYyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChwcm9wcy5zcmMpO1xuICBjb25zdCBvbkVycm9yID0gdXNlQ2FsbGJhY2sxMSgoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUuY3VycmVudFRhcmdldC5lcnJvcik7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9IGBDb3VsZCBub3QgcGxheSBhdWRpbyB3aXRoIHNyYyAke3ByZWxvYWRlZFNyY306ICR7ZS5jdXJyZW50VGFyZ2V0LmVycm9yfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuYDtcbiAgICBpZiAobG9vcCkge1xuICAgICAgaWYgKG9uUmVtb3Rpb25FcnJvcikge1xuICAgICAgICBvblJlbW90aW9uRXJyb3IobmV3IEVycm9yKGVyck1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FuY2VsUmVuZGVyKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uUmVtb3Rpb25FcnJvcj8uKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgICBjb25zb2xlLndhcm4oZXJyTWVzc2FnZSk7XG4gICAgfVxuICB9LCBbbG9vcCwgb25SZW1vdGlvbkVycm9yLCBwcmVsb2FkZWRTcmNdKTtcbiAgY29uc3Qgb25EdXJhdGlvbiA9IHVzZUNhbGxiYWNrMTEoKHNyYywgZHVyYXRpb25JblNlY29uZHMpID0+IHtcbiAgICBzZXREdXJhdGlvbnMoeyB0eXBlOiBcImdvdC1kdXJhdGlvblwiLCBkdXJhdGlvbkluU2Vjb25kcywgc3JjIH0pO1xuICB9LCBbc2V0RHVyYXRpb25zXSk7XG4gIGNvbnN0IGR1cmF0aW9uRmV0Y2hlZCA9IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcmVsb2FkZWRTcmMpXSA/PyBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKV07XG4gIHZhbGlkYXRlTWVkaWFUcmltUHJvcHMoeyBzdGFydEZyb20sIGVuZEF0LCB0cmltQmVmb3JlLCB0cmltQWZ0ZXIgfSk7XG4gIGNvbnN0IHsgdHJpbUJlZm9yZVZhbHVlLCB0cmltQWZ0ZXJWYWx1ZSB9ID0gcmVzb2x2ZVRyaW1Qcm9wcyh7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdHJpbUFmdGVyXG4gIH0pO1xuICBpZiAobG9vcCAmJiBkdXJhdGlvbkZldGNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uRmV0Y2hlZCkpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjAoSHRtbDVBdWRpbywge1xuICAgICAgICAuLi5wcm9wc090aGVyVGhhbkxvb3AsXG4gICAgICAgIHJlZixcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSBkdXJhdGlvbkZldGNoZWQgKiBmcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMChMb29wLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogY2FsY3VsYXRlTWVkaWFEdXJhdGlvbih7XG4gICAgICAgIHRyaW1BZnRlcjogdHJpbUFmdGVyVmFsdWUsXG4gICAgICAgIG1lZGlhRHVyYXRpb25JbkZyYW1lczogZHVyYXRpb24sXG4gICAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHRyaW1CZWZvcmU6IHRyaW1CZWZvcmVWYWx1ZVxuICAgICAgfSksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIwKEh0bWw1QXVkaW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHRyaW1CZWZvcmVWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdHJpbUFmdGVyVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIwKFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtICh0cmltQmVmb3JlVmFsdWUgPz8gMCksXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiB0cmltQWZ0ZXJWYWx1ZSxcbiAgICAgIG5hbWUsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIwKEh0bWw1QXVkaW8sIHtcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCksXG4gICAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgICByZWZcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGVNZWRpYVByb3BzKHsgcGxheWJhY2tSYXRlOiBwcm9wcy5wbGF5YmFja1JhdGUsIHZvbHVtZTogcHJvcHMudm9sdW1lIH0sIFwiSHRtbDVBdWRpb1wiKTtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMChBdWRpb0ZvclJlbmRlcmluZywge1xuICAgICAgb25EdXJhdGlvbixcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmLFxuICAgICAgb25OYXRpdmVFcnJvcjogb25FcnJvcixcbiAgICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uOiBCb29sZWFuKGxvb3ApXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMChBdWRpb0ZvclByZXZpZXcsIHtcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHByb3BzLl9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCA/PyBmYWxzZSxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrOiBzdGFjayA/PyBudWxsLFxuICAgIHNob3VsZFByZU1vdW50QXVkaW9UYWdzOiBhdWRpb0NvbnRleHQgIT09IG51bGwgJiYgYXVkaW9Db250ZXh0Lm51bWJlck9mQXVkaW9UYWdzID4gMCxcbiAgICAuLi5wcm9wcyxcbiAgICByZWYsXG4gICAgb25OYXRpdmVFcnJvcjogb25FcnJvcixcbiAgICBvbkR1cmF0aW9uLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uOiBCb29sZWFuKGxvb3ApLFxuICAgIHNob3dJblRpbWVsaW5lOiBzaG93SW5UaW1lbGluZSA/PyB0cnVlXG4gIH0pO1xufTtcbnZhciBIdG1sNUF1ZGlvID0gZm9yd2FyZFJlZjYoQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhIdG1sNUF1ZGlvKTtcbnZhciBBdWRpbyA9IEh0bWw1QXVkaW87XG4vLyBzcmMvQ29tcG9zaXRpb24udHN4XG5pbXBvcnQgeyBTdXNwZW5zZSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjksIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuXG4vLyBzcmMvRm9sZGVyLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTgsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI4LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTQsIHVzZU1lbW8gYXMgdXNlTWVtbzIzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWZvbGRlci1uYW1lLnRzXG52YXIgZ2V0UmVnZXggPSAoKSA9PiAvXihbYS16QS1aMC05LVxcdTRFMDAtXFx1OUZGRl0pKyQvZztcbnZhciBpc0ZvbGRlck5hbWVWYWxpZCA9IChuYW1lKSA9PiBuYW1lLm1hdGNoKGdldFJlZ2V4KCkpO1xudmFyIHZhbGlkYXRlRm9sZGVyTmFtZSA9IChuYW1lKSA9PiB7XG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgbmFtZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgbmFtZSB0byBhIDxGb2xkZXIgLz4uXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm5hbWVcIiB5b3UgcGFzcyBpbnRvIDxGb2xkZXIgLz4gbXVzdCBiZSBhIHN0cmluZy4gR290OiAke3R5cGVvZiBuYW1lfWApO1xuICB9XG4gIGlmICghaXNGb2xkZXJOYW1lVmFsaWQobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZvbGRlciBuYW1lIGNhbiBvbmx5IGNvbnRhaW4gYS16LCBBLVosIDAtOSBhbmQgLS4gWW91IHBhc3NlZCAke25hbWV9YCk7XG4gIH1cbn07XG52YXIgaW52YWxpZEZvbGRlck5hbWVFcnJvck1lc3NhZ2UgPSBgRm9sZGVyIG5hbWUgbXVzdCBtYXRjaCAke1N0cmluZyhnZXRSZWdleCgpKX1gO1xuXG4vLyBzcmMvRm9sZGVyLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIxIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRm9sZGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxOCh7XG4gIGZvbGRlck5hbWU6IG51bGwsXG4gIHBhcmVudE5hbWU6IG51bGxcbn0pO1xudmFyIEZvbGRlciA9ICh7IG5hbWUsIGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgcGFyZW50ID0gdXNlQ29udGV4dDI4KEZvbGRlckNvbnRleHQpO1xuICBjb25zdCB7IHJlZ2lzdGVyRm9sZGVyLCB1bnJlZ2lzdGVyRm9sZGVyIH0gPSB1c2VDb250ZXh0MjgoQ29tcG9zaXRpb25TZXR0ZXJzKTtcbiAgdmFsaWRhdGVGb2xkZXJOYW1lKG5hbWUpO1xuICBjb25zdCBwYXJlbnROYW1lQXJyID0gW3BhcmVudC5wYXJlbnROYW1lLCBwYXJlbnQuZm9sZGVyTmFtZV0uZmlsdGVyKHRydXRoeSk7XG4gIGNvbnN0IHBhcmVudE5hbWUgPSBwYXJlbnROYW1lQXJyLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBwYXJlbnROYW1lQXJyLmpvaW4oXCIvXCIpO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8yMygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbGRlck5hbWU6IG5hbWUsXG4gICAgICBwYXJlbnROYW1lXG4gICAgfTtcbiAgfSwgW25hbWUsIHBhcmVudE5hbWVdKTtcbiAgdXNlRWZmZWN0MTQoKCkgPT4ge1xuICAgIHJlZ2lzdGVyRm9sZGVyKG5hbWUsIHBhcmVudE5hbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyRm9sZGVyKG5hbWUsIHBhcmVudE5hbWUpO1xuICAgIH07XG4gIH0sIFtuYW1lLCBwYXJlbnQuZm9sZGVyTmFtZSwgcGFyZW50TmFtZSwgcmVnaXN0ZXJGb2xkZXIsIHVucmVnaXN0ZXJGb2xkZXJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMShGb2xkZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvbG9hZGluZy1pbmRpY2F0b3IudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjIsIGpzeHMgYXMganN4czIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciByb3RhdGUgPSB7XG4gIHRyYW5zZm9ybTogYHJvdGF0ZSg5MGRlZylgXG59O1xudmFyIElDT05fU0laRSA9IDQwO1xudmFyIGxhYmVsID0ge1xuICBjb2xvcjogXCJ3aGl0ZVwiLFxuICBmb250U2l6ZTogMTQsXG4gIGZvbnRGYW1pbHk6IFwic2Fucy1zZXJpZlwiXG59O1xudmFyIGNvbnRhaW5lciA9IHtcbiAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gIGFsaWduSXRlbXM6IFwiY2VudGVyXCJcbn07XG52YXIgTG9hZGluZyA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihBYnNvbHV0ZUZpbGwsIHtcbiAgICBzdHlsZTogY29udGFpbmVyLFxuICAgIGlkOiBcInJlbW90aW9uLWNvbXAtbG9hZGluZ1wiLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MjIoXCJzdHlsZVwiLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9jc3NcIixcbiAgICAgICAgY2hpbGRyZW46IGBcblx0XHRcdFx0QGtleWZyYW1lcyBhbmltIHtcblx0XHRcdFx0XHRmcm9tIHtcblx0XHRcdFx0XHRcdG9wYWNpdHk6IDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG8ge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTogMVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQjcmVtb3Rpb24tY29tcC1sb2FkaW5nIHtcblx0XHRcdFx0XHRhbmltYXRpb246IGFuaW0gMnM7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLWZpbGwtbW9kZTogZm9yd2FyZHM7XG5cdFx0XHRcdH1cblx0XHRcdGBcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIyKFwic3ZnXCIsIHtcbiAgICAgICAgd2lkdGg6IElDT05fU0laRSxcbiAgICAgICAgaGVpZ2h0OiBJQ09OX1NJWkUsXG4gICAgICAgIHZpZXdCb3g6IFwiLTEwMCAtMTAwIDQwMCA0MDBcIixcbiAgICAgICAgc3R5bGU6IHJvdGF0ZSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihcInBhdGhcIiwge1xuICAgICAgICAgIGZpbGw6IFwiIzU1NVwiLFxuICAgICAgICAgIHN0cm9rZTogXCIjNTU1XCIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMTAwXCIsXG4gICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgICAgICBkOiBcIk0gMiAxNzIgYSAxOTYgMTAwIDAgMCAwIDE5NSA1IEEgMTk2IDI0MCAwIDAgMCAxMDAgMi4yNTkgQSAxOTYgMjQwIDAgMCAwIDIgMTcyIHpcIlxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4czIoXCJwXCIsIHtcbiAgICAgICAgc3R5bGU6IGxhYmVsLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIFwiUmVzb2x2aW5nIFwiLFxuICAgICAgICAgIFwiPFN1c3BlbnNlPlwiLFxuICAgICAgICAgIFwiLi4uXCJcbiAgICAgICAgXVxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufTtcblxuLy8gc3JjL3BvcnRhbC1ub2RlLnRzXG52YXIgX3BvcnRhbE5vZGUgPSBudWxsO1xudmFyIHBvcnRhbE5vZGUgPSAoKSA9PiB7XG4gIGlmICghX3BvcnRhbE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBjYWxsIGFuIEFQSSB0aGF0IG9ubHkgd29ya3MgaW4gdGhlIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHRoZSBicm93c2VyXCIpO1xuICAgIH1cbiAgICBfcG9ydGFsTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcbiAgICBjb25zdCBjb250YWluZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXJOb2RlLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIGNvbnRhaW5lck5vZGUuc3R5bGUudG9wID0gLTk5OTk5OSArIFwicHhcIjtcbiAgICBjb250YWluZXJOb2RlLmFwcGVuZENoaWxkKF9wb3J0YWxOb2RlKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lck5vZGUpO1xuICB9XG4gIHJldHVybiBfcG9ydGFsTm9kZTtcbn07XG5cbi8vIHNyYy91c2UtbGF6eS1jb21wb25lbnQudHNcbmltcG9ydCBSZWFjdDIxLCB7IHVzZU1lbW8gYXMgdXNlTWVtbzI0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTGF6eUNvbXBvbmVudCA9ICh7XG4gIGNvbXBQcm9wcyxcbiAgY29tcG9uZW50TmFtZSxcbiAgbm9TdXNwZW5zZVxufSkgPT4ge1xuICBjb25zdCBsYXp5ID0gdXNlTWVtbzI0KCgpID0+IHtcbiAgICBpZiAoXCJjb21wb25lbnRcIiBpbiBjb21wUHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgbm9TdXNwZW5zZSkge1xuICAgICAgICByZXR1cm4gY29tcFByb3BzLmNvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29tcFByb3BzLmNvbXBvbmVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgdmFsdWUgb2YgXFxgdW5kZWZpbmVkXFxgIHdhcyBwYXNzZWQgdG8gdGhlIFxcYGNvbXBvbmVudFxcYCBwcm9wLiBDaGVjayB0aGUgdmFsdWUgeW91IGFyZSBwYXNzaW5nIHRvIHRoZSA8JHtjb21wb25lbnROYW1lfS8+IGNvbXBvbmVudC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wUHJvcHMuY29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoXCJsYXp5Q29tcG9uZW50XCIgaW4gY29tcFByb3BzICYmIHR5cGVvZiBjb21wUHJvcHMubGF6eUNvbXBvbmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHR5cGVvZiBjb21wUHJvcHMubGF6eUNvbXBvbmVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgdmFsdWUgb2YgXFxgdW5kZWZpbmVkXFxgIHdhcyBwYXNzZWQgdG8gdGhlIFxcYGxhenlDb21wb25lbnRcXGAgcHJvcC4gQ2hlY2sgdGhlIHZhbHVlIHlvdSBhcmUgcGFzc2luZyB0byB0aGUgPCR7Y29tcG9uZW50TmFtZX0vPiBjb21wb25lbnQuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QyMS5sYXp5KGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBlaXRoZXIgJ2NvbXBvbmVudCcgb3IgJ2xhenlDb21wb25lbnQnXCIpO1xuICB9LCBbY29tcFByb3BzLmNvbXBvbmVudCwgY29tcFByb3BzLmxhenlDb21wb25lbnRdKTtcbiAgcmV0dXJuIGxhenk7XG59O1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1jb21wb3NpdGlvbi1pZC50c1xudmFyIGdldFJlZ2V4MiA9ICgpID0+IC9eKFthLXpBLVowLTktXFx1NEUwMC1cXHU5RkZGXSkrJC9nO1xudmFyIGlzQ29tcG9zaXRpb25JZFZhbGlkID0gKGlkKSA9PiBpZC5tYXRjaChnZXRSZWdleDIoKSk7XG52YXIgdmFsaWRhdGVDb21wb3NpdGlvbklkID0gKGlkKSA9PiB7XG4gIGlmICghaXNDb21wb3NpdGlvbklkVmFsaWQoaWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb3NpdGlvbiBpZCBjYW4gb25seSBjb250YWluIGEteiwgQS1aLCAwLTksIENKSyBjaGFyYWN0ZXJzIGFuZCAtLiBZb3UgcGFzc2VkICR7aWR9YCk7XG4gIH1cbn07XG52YXIgaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlID0gYENvbXBvc2l0aW9uIElEIG11c3QgbWF0Y2ggJHtTdHJpbmcoZ2V0UmVnZXgyKCkpfWA7XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtcHJvcHMudHNcbnZhciB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzID0gKGRlZmF1bHRQcm9wcywgbmFtZSwgY29tcG9zaXRpb25JZCkgPT4ge1xuICBpZiAoIWRlZmF1bHRQcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRQcm9wcyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0UHJvcHN9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFByb3BzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGFuIGFycmF5IHdhcyBwYXNzZWQgJHtjb21wb3NpdGlvbklkID8gYGZvciBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImAgOiBcIlwifWApO1xuICB9XG59O1xuXG4vLyBzcmMvQ29tcG9zaXRpb24udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBGYWxsYmFjayA9ICgpID0+IHtcbiAgY29uc3QgeyBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyLCBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICB1c2VFZmZlY3QxNSgoKSA9PiB7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBkZWxheVJlbmRlcjIoXCJXYWl0aW5nIGZvciBSb290IGNvbXBvbmVudCB0byB1bnN1c3BlbmRcIik7XG4gICAgcmV0dXJuICgpID0+IGNvbnRpbnVlUmVuZGVyMihmYWxsYmFjayk7XG4gIH0sIFtjb250aW51ZVJlbmRlcjIsIGRlbGF5UmVuZGVyMl0pO1xuICByZXR1cm4gbnVsbDtcbn07XG52YXIgSW5uZXJDb21wb3NpdGlvbiA9ICh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGZwcyxcbiAgZHVyYXRpb25JbkZyYW1lcyxcbiAgaWQsXG4gIGRlZmF1bHRQcm9wcyxcbiAgc2NoZW1hLFxuICAuLi5jb21wUHJvcHNcbn0pID0+IHtcbiAgY29uc3QgY29tcE1hbmFnZXIgPSB1c2VDb250ZXh0MjkoQ29tcG9zaXRpb25TZXR0ZXJzKTtcbiAgY29uc3QgeyByZWdpc3RlckNvbXBvc2l0aW9uLCB1bnJlZ2lzdGVyQ29tcG9zaXRpb24gfSA9IGNvbXBNYW5hZ2VyO1xuICBjb25zdCB2aWRlbyA9IHVzZVZpZGVvKCk7XG4gIGNvbnN0IGxhenkgPSB1c2VMYXp5Q29tcG9uZW50KHtcbiAgICBjb21wUHJvcHMsXG4gICAgY29tcG9uZW50TmFtZTogXCJDb21wb3NpdGlvblwiLFxuICAgIG5vU3VzcGVuc2U6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGNvbnN0IGlzUGxheWVyID0gdXNlSXNQbGF5ZXIoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IGNhblVzZUNvbXBvc2l0aW9uID0gdXNlQ29udGV4dDI5KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5yZW1vdGlvbl9zZWVuQ29tcG9zaXRpb25JZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLndpbmRvdy5yZW1vdGlvbl9zZWVuQ29tcG9zaXRpb25JZHMgPz8gW10sIGlkXSkpO1xuICB9XG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbikge1xuICAgIGlmIChpc1BsYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiPENvbXBvc2l0aW9uPiB3YXMgbW91bnRlZCBpbnNpZGUgdGhlIGBjb21wb25lbnRgIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgPFBsYXllcj4uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3dyb25nLWNvbXBvc2l0aW9uLW1vdW50IGZvciBoZWxwLlwiKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiPENvbXBvc2l0aW9uPiBtb3VudGVkIGluc2lkZSBhbm90aGVyIGNvbXBvc2l0aW9uLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy93cm9uZy1jb21wb3NpdGlvbi1tb3VudCBmb3IgaGVscC5cIik7XG4gIH1cbiAgY29uc3QgeyBmb2xkZXJOYW1lLCBwYXJlbnROYW1lIH0gPSB1c2VDb250ZXh0MjkoRm9sZGVyQ29udGV4dCk7XG4gIHVzZUVmZmVjdDE1KCgpID0+IHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBpZCBmb3IgY29tcG9zaXRpb24gcGFzc2VkLlwiKTtcbiAgICB9XG4gICAgdmFsaWRhdGVDb21wb3NpdGlvbklkKGlkKTtcbiAgICB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzKGRlZmF1bHRQcm9wcywgXCJkZWZhdWx0UHJvcHNcIiwgaWQpO1xuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24oe1xuICAgICAgZHVyYXRpb25JbkZyYW1lczogZHVyYXRpb25JbkZyYW1lcyA/PyB1bmRlZmluZWQsXG4gICAgICBmcHM6IGZwcyA/PyB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/PyB1bmRlZmluZWQsXG4gICAgICB3aWR0aDogd2lkdGggPz8gdW5kZWZpbmVkLFxuICAgICAgaWQsXG4gICAgICBmb2xkZXJOYW1lLFxuICAgICAgY29tcG9uZW50OiBsYXp5LFxuICAgICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMgPz8ge30pLFxuICAgICAgbm9uY2UsXG4gICAgICBwYXJlbnRGb2xkZXJOYW1lOiBwYXJlbnROYW1lLFxuICAgICAgc2NoZW1hOiBzY2hlbWEgPz8gbnVsbCxcbiAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiBjb21wUHJvcHMuY2FsY3VsYXRlTWV0YWRhdGEgPz8gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyQ29tcG9zaXRpb24oaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgIGZwcyxcbiAgICBoZWlnaHQsXG4gICAgbGF6eSxcbiAgICBpZCxcbiAgICBmb2xkZXJOYW1lLFxuICAgIGRlZmF1bHRQcm9wcyxcbiAgICB3aWR0aCxcbiAgICBub25jZSxcbiAgICBwYXJlbnROYW1lLFxuICAgIHNjaGVtYSxcbiAgICBjb21wUHJvcHMuY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICB1bnJlZ2lzdGVyQ29tcG9zaXRpb25cbiAgXSk7XG4gIHVzZUVmZmVjdDE1KCgpID0+IHtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoUFJPUFNfVVBEQVRFRF9FWFRFUk5BTExZLCB7XG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgcmVzZXRVbnNhdmVkOiBpZFxuICAgICAgfVxuICAgIH0pKTtcbiAgfSwgW2RlZmF1bHRQcm9wcywgaWRdKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnKGlkKTtcbiAgaWYgKGVudmlyb25tZW50LmlzU3R1ZGlvICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSAmJiB2aWRlby5pZCA9PT0gaWQpIHtcbiAgICBjb25zdCBDb21wID0gbGF6eTtcbiAgICBpZiAocmVzb2x2ZWQgPT09IG51bGwgfHwgcmVzb2x2ZWQudHlwZSAhPT0gXCJzdWNjZXNzXCIgJiYgcmVzb2x2ZWQudHlwZSAhPT0gXCJzdWNjZXNzLWFuZC1yZWZyZXNoaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKC8qIEBfX1BVUkVfXyAqLyBqc3gyMyhDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsIHtcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjMoU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qIEBfX1BVUkVfXyAqLyBqc3gyMyhMb2FkaW5nLCB7fSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjMoQ29tcCwge1xuICAgICAgICAgIC4uLnJlc29sdmVkLnJlc3VsdC5wcm9wcyA/PyB7fVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSwgcG9ydGFsTm9kZSgpKTtcbiAgfVxuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcgJiYgdmlkZW8gJiYgdmlkZW8uY29tcG9uZW50ID09PSBsYXp5ICYmIHZpZGVvLmlkID09PSBpZCkge1xuICAgIGNvbnN0IENvbXAgPSBsYXp5O1xuICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3NcIiAmJiByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLyogQF9fUFVSRV9fICovIGpzeDIzKENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMyhTdXNwZW5zZSwge1xuICAgICAgICBmYWxsYmFjazogLyogQF9fUFVSRV9fICovIGpzeDIzKEZhbGxiYWNrLCB7fSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjMoQ29tcCwge1xuICAgICAgICAgIC4uLnJlc29sdmVkLnJlc3VsdC5wcm9wcyA/PyB7fVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSwgcG9ydGFsTm9kZSgpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgQ29tcG9zaXRpb24gPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IHsgb25seVJlbmRlckNvbXBvc2l0aW9uIH0gPSB1c2VDb250ZXh0MjkoQ29tcG9zaXRpb25TZXR0ZXJzKTtcbiAgaWYgKG9ubHlSZW5kZXJDb21wb3NpdGlvbiAmJiBvbmx5UmVuZGVyQ29tcG9zaXRpb24gIT09IHByb3BzMi5pZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjMoSW5uZXJDb21wb3NpdGlvbiwge1xuICAgIC4uLnByb3BzMlxuICB9KTtcbn07XG4vLyBzcmMvYmV6aWVyLnRzXG52YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0O1xudmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbnZhciBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG52YXIgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcbnZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG52YXIga1NhbXBsZVN0ZXBTaXplID0gMSAvIChrU3BsaW5lVGFibGVTaXplIC0gMSk7XG52YXIgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gYShhQTEsIGFBMikge1xuICByZXR1cm4gMSAtIDMgKiBhQTIgKyAzICogYUExO1xufVxuZnVuY3Rpb24gYihhQTEsIGFBMikge1xuICByZXR1cm4gMyAqIGFBMiAtIDYgKiBhQTE7XG59XG5mdW5jdGlvbiBjKGFBMSkge1xuICByZXR1cm4gMyAqIGFBMTtcbn1cbmZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gIHJldHVybiAoKGEoYUExLCBhQTIpICogYVQgKyBiKGFBMSwgYUEyKSkgKiBhVCArIGMoYUExKSkgKiBhVDtcbn1cbmZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICByZXR1cm4gMyAqIGEoYUExLCBhQTIpICogYVQgKiBhVCArIDIgKiBiKGFBMSwgYUEyKSAqIGFUICsgYyhhQTEpO1xufVxuZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKHtcbiAgYVgsXG4gIF9hQSxcbiAgX2FCLFxuICBtWDEsXG4gIG1YMlxufSkge1xuICBsZXQgY3VycmVudFg7XG4gIGxldCBjdXJyZW50VDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgYUEgPSBfYUE7XG4gIGxldCBhQiA9IF9hQjtcbiAgZG8ge1xuICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyO1xuICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgaWYgKGN1cnJlbnRYID4gMCkge1xuICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICB9IGVsc2Uge1xuICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICB9XG4gIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gIHJldHVybiBjdXJyZW50VDtcbn1cbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBfYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgbGV0IGFHdWVzc1QgPSBfYUd1ZXNzVDtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcbiAgICBjb25zdCBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICB9XG4gIHJldHVybiBhR3Vlc3NUO1xufVxuZnVuY3Rpb24gYmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICBpZiAoIShtWDEgPj0gMCAmJiBtWDEgPD0gMSAmJiBtWDIgPj0gMCAmJiBtWDIgPD0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2VcIik7XG4gIH1cbiAgY29uc3Qgc2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7aSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgbGV0IGludGVydmFsU3RhcnQgPSAwO1xuICAgIGxldCBjdXJyZW50U2FtcGxlID0gMTtcbiAgICBjb25zdCBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG4gICAgZm9yICg7Y3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICBjb25zdCBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICBjb25zdCBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICBjb25zdCBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgfVxuICAgIGlmIChpbml0aWFsU2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoe1xuICAgICAgYVgsXG4gICAgICBfYUE6IGludGVydmFsU3RhcnQsXG4gICAgICBfYUI6IGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsXG4gICAgICBtWDEsXG4gICAgICBtWDJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHggPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xuICB9O1xufVxuXG4vLyBzcmMvZWFzaW5nLnRzXG5jbGFzcyBFYXNpbmcge1xuICBzdGF0aWMgc3RlcDAobikge1xuICAgIHJldHVybiBuID4gMCA/IDEgOiAwO1xuICB9XG4gIHN0YXRpYyBzdGVwMShuKSB7XG4gICAgcmV0dXJuIG4gPj0gMSA/IDEgOiAwO1xuICB9XG4gIHN0YXRpYyBsaW5lYXIodCkge1xuICAgIHJldHVybiB0O1xuICB9XG4gIHN0YXRpYyBlYXNlKHQpIHtcbiAgICByZXR1cm4gRWFzaW5nLmJlemllcigwLjQyLCAwLCAxLCAxKSh0KTtcbiAgfVxuICBzdGF0aWMgcXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG4gIHN0YXRpYyBjdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBzdGF0aWMgcG9seShuKSB7XG4gICAgcmV0dXJuICh0KSA9PiB0ICoqIG47XG4gIH1cbiAgc3RhdGljIHNpbih0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpO1xuICB9XG4gIHN0YXRpYyBjaXJjbGUodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG4gIH1cbiAgc3RhdGljIGV4cCh0KSB7XG4gICAgcmV0dXJuIDIgKiogKDEwICogKHQgLSAxKSk7XG4gIH1cbiAgc3RhdGljIGVsYXN0aWMoYm91bmNpbmVzcyA9IDEpIHtcbiAgICBjb25zdCBwID0gYm91bmNpbmVzcyAqIE1hdGguUEk7XG4gICAgcmV0dXJuICh0KSA9PiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKSAqKiAzICogTWF0aC5jb3ModCAqIHApO1xuICB9XG4gIHN0YXRpYyBiYWNrKHMgPSAxLjcwMTU4KSB7XG4gICAgcmV0dXJuICh0KSA9PiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9XG4gIHN0YXRpYyBib3VuY2UodCkge1xuICAgIGlmICh0IDwgMSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAyIC8gMi43NSkge1xuICAgICAgY29uc3QgdDJfID0gdCAtIDEuNSAvIDIuNzU7XG4gICAgICByZXR1cm4gNy41NjI1ICogdDJfICogdDJfICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAyLjUgLyAyLjc1KSB7XG4gICAgICBjb25zdCB0Ml8gPSB0IC0gMi4yNSAvIDIuNzU7XG4gICAgICByZXR1cm4gNy41NjI1ICogdDJfICogdDJfICsgMC45Mzc1O1xuICAgIH1cbiAgICBjb25zdCB0MiA9IHQgLSAyLjYyNSAvIDIuNzU7XG4gICAgcmV0dXJuIDcuNTYyNSAqIHQyICogdDIgKyAwLjk4NDM3NTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIGJlemllcih4MSwgeTEsIHgyLCB5Mik7XG4gIH1cbiAgc3RhdGljIGluKGVhc2luZykge1xuICAgIHJldHVybiBlYXNpbmc7XG4gIH1cbiAgc3RhdGljIG91dChlYXNpbmcpIHtcbiAgICByZXR1cm4gKHQpID0+IDEgLSBlYXNpbmcoMSAtIHQpO1xuICB9XG4gIHN0YXRpYyBpbk91dChlYXNpbmcpIHtcbiAgICByZXR1cm4gKHQpID0+IHtcbiAgICAgIGlmICh0IDwgMC41KSB7XG4gICAgICAgIHJldHVybiBlYXNpbmcodCAqIDIpIC8gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC0gZWFzaW5nKCgxIC0gdCkgKiAyKSAvIDI7XG4gICAgfTtcbiAgfVxufVxuLy8gc3JjL3Y1LWZsYWcudHNcbnZhciBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyA9IGZhbHNlO1xuXG4vLyBzcmMvZ2V0LXN0YXRpYy1maWxlcy50c1xudmFyIHdhcm5lZFNlcnZlciA9IGZhbHNlO1xudmFyIHdhcm5lZFBsYXllciA9IGZhbHNlO1xudmFyIHdhcm5TZXJ2ZXJPbmNlID0gKCkgPT4ge1xuICBpZiAod2FybmVkU2VydmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5lZFNlcnZlciA9IHRydWU7XG4gIGNvbnNvbGUud2FybihcIkNhbGxlZCBnZXRTdGF0aWNGaWxlcygpIG9uIHRoZSBzZXJ2ZXIuIFRoZSBBUEkgaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXIuIEFuIGVtcHR5IGFycmF5IHdhcyByZXR1cm5lZC5cIik7XG59O1xudmFyIHdhcm5QbGF5ZXJPbmNlID0gKCkgPT4ge1xuICBpZiAod2FybmVkUGxheWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5lZFBsYXllciA9IHRydWU7XG4gIGNvbnNvbGUud2FybihcIkNhbGxlZCBnZXRTdGF0aWNGaWxlcygpIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBQbGF5ZXIuIFRoZSBBUEkgaXMgb25seSBhdmFpbGFibGUgd2hpbGUgdXNpbmcgdGhlIFJlbW90aW9uIFN0dWRpby4gQW4gZW1wdHkgYXJyYXkgd2FzIHJldHVybmVkLlwiKTtcbn07XG52YXIgZ2V0U3RhdGljRmlsZXMgPSAoKSA9PiB7XG4gIGlmIChFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImdldFN0YXRpY0ZpbGVzKCkgaGFzIG1vdmVkIGludG8gdGhlIGBAcmVtb3Rpb24vc3R1ZGlvYCBwYWNrYWdlLiBVcGRhdGUgeW91ciBpbXBvcnRzLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2FyblNlcnZlck9uY2UoKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllcikge1xuICAgIHdhcm5QbGF5ZXJPbmNlKCk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVtb3Rpb25fc3RhdGljRmlsZXM7XG59O1xuLy8gc3JjL0lGcmFtZS50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjcsIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTIsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIElGcmFtZVJlZkZvcndhcmRpbmcgPSAoe1xuICBvbkxvYWQsXG4gIG9uRXJyb3IsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIC4uLnByb3BzMlxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHsgZGVsYXlSZW5kZXI6IGRlbGF5UmVuZGVyMiwgY29udGludWVSZW5kZXI6IGNvbnRpbnVlUmVuZGVyMiB9ID0gdXNlRGVsYXlSZW5kZXIoKTtcbiAgY29uc3QgW2hhbmRsZV0gPSB1c2VTdGF0ZTE2KCgpID0+IGRlbGF5UmVuZGVyMihgTG9hZGluZyA8SUZyYW1lPiB3aXRoIHNvdXJjZSAke3Byb3BzMi5zcmN9YCwge1xuICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgfSkpO1xuICBjb25zdCBkaWRMb2FkID0gdXNlQ2FsbGJhY2sxMigoZSkgPT4ge1xuICAgIGNvbnRpbnVlUmVuZGVyMihoYW5kbGUpO1xuICAgIG9uTG9hZD8uKGUpO1xuICB9LCBbaGFuZGxlLCBvbkxvYWQsIGNvbnRpbnVlUmVuZGVyMl0pO1xuICBjb25zdCBkaWRHZXRFcnJvciA9IHVzZUNhbGxiYWNrMTIoKGUpID0+IHtcbiAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgaWZyYW1lOlwiLCBlLCBcIkhhbmRsZSB0aGUgZXZlbnQgdXNpbmcgdGhlIG9uRXJyb3IoKSBwcm9wIHRvIG1ha2UgdGhpcyBtZXNzYWdlIGRpc2FwcGVhci5cIik7XG4gICAgfVxuICB9LCBbaGFuZGxlLCBvbkVycm9yLCBjb250aW51ZVJlbmRlcjJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNChcImlmcmFtZVwiLCB7XG4gICAgcmVmZXJyZXJQb2xpY3k6IFwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLFxuICAgIC4uLnByb3BzMixcbiAgICByZWYsXG4gICAgb25FcnJvcjogZGlkR2V0RXJyb3IsXG4gICAgb25Mb2FkOiBkaWRMb2FkXG4gIH0pO1xufTtcbnZhciBJRnJhbWUgPSBmb3J3YXJkUmVmNyhJRnJhbWVSZWZGb3J3YXJkaW5nKTtcbi8vIHNyYy9JbWcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY4LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazEzLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzMCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlOCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDksXG4gIHVzZVJlZiBhcyB1c2VSZWYxNFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyNSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gZXhwb25lbnRpYWxCYWNrb2ZmKGVycm9yQ291bnQpIHtcbiAgcmV0dXJuIDEwMDAgKiAyICoqIChlcnJvckNvdW50IC0gMSk7XG59XG52YXIgSW1nUmVmRm9yd2FyZGluZyA9ICh7XG4gIG9uRXJyb3IsXG4gIG1heFJldHJpZXMgPSAyLFxuICBzcmMsXG4gIHBhdXNlV2hlbkxvYWRpbmcsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIG9uSW1hZ2VGcmFtZSxcbiAgY3Jvc3NPcmlnaW4sXG4gIC4uLnByb3BzMlxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IGltYWdlUmVmID0gdXNlUmVmMTQobnVsbCk7XG4gIGNvbnN0IGVycm9ycyA9IHVzZVJlZjE0KHt9KTtcbiAgY29uc3QgeyBkZWxheVBsYXliYWNrIH0gPSB1c2VCdWZmZXJTdGF0ZSgpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MzAoU2VxdWVuY2VDb250ZXh0KTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwic3JjXCIgcHJvcCB3YXMgcGFzc2VkIHRvIDxJbWc+LicpO1xuICB9XG4gIGNvbnN0IF9wcm9wc1ZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFfcHJvcHNWYWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGVjaGVjayBlcnJvclwiKTtcbiAgfVxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOChyZWYsICgpID0+IHtcbiAgICByZXR1cm4gaW1hZ2VSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VQcmVsb2FkKHNyYyk7XG4gIGNvbnN0IHJldHJ5SW4gPSB1c2VDYWxsYmFjazEzKCh0aW1lb3V0KSA9PiB7XG4gICAgaWYgKCFpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTcmMgPSBpbWFnZVJlZi5jdXJyZW50LnNyYztcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghaW1hZ2VSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdTcmMgPSBpbWFnZVJlZi5jdXJyZW50Py5zcmM7XG4gICAgICBpZiAobmV3U3JjICE9PSBjdXJyZW50U3JjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGltYWdlUmVmLmN1cnJlbnQucmVtb3ZlQXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgaW1hZ2VSZWYuY3VycmVudC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgbmV3U3JjKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfSwgW10pO1xuICBjb25zdCBkaWRHZXRFcnJvciA9IHVzZUNhbGxiYWNrMTMoKGUpID0+IHtcbiAgICBpZiAoIWVycm9ycy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPSAoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSArIDE7XG4gICAgaWYgKG9uRXJyb3IgJiYgKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCkgPiBtYXhSZXRyaWVzKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCkgPD0gbWF4UmV0cmllcykge1xuICAgICAgY29uc3QgYmFja29mZiA9IGV4cG9uZW50aWFsQmFja29mZihlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApO1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgbG9hZCBpbWFnZSB3aXRoIHNvdXJjZSAke2ltYWdlUmVmLmN1cnJlbnQ/LnNyY30sIHJldHJ5aW5nIGFnYWluIGluICR7YmFja29mZn1tc2ApO1xuICAgICAgcmV0cnlJbihiYWNrb2ZmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FuY2VsUmVuZGVyKFwiRXJyb3IgbG9hZGluZyBpbWFnZSB3aXRoIHNyYzogXCIgKyBpbWFnZVJlZi5jdXJyZW50Py5zcmMpO1xuICB9LCBbbWF4UmV0cmllcywgb25FcnJvciwgcmV0cnlJbl0pO1xuICBjb25zdCB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIgfSA9IHVzZURlbGF5UmVuZGVyKCk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgaXNQcmVtb3VudGluZyA9IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyk7XG4gICAgY29uc3QgaXNQb3N0bW91bnRpbmcgPSBCb29sZWFuKHNlcXVlbmNlQ29udGV4dD8ucG9zdG1vdW50aW5nKTtcbiAgICB1c2VMYXlvdXRFZmZlY3Q5KCgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgaWYgKGltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBpbWFnZVJlZi5jdXJyZW50LnNyYyA9IGFjdHVhbFNyYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGltYWdlUmVmO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0hhbmRsZSA9IGRlbGF5UmVuZGVyMihcIkxvYWRpbmcgPEltZz4gd2l0aCBzcmM9XCIgKyBhY3R1YWxTcmMsIHtcbiAgICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdW5ibG9jayA9IHBhdXNlV2hlbkxvYWRpbmcgJiYgIWlzUHJlbW91bnRpbmcgJiYgIWlzUG9zdG1vdW50aW5nID8gZGVsYXlQbGF5YmFjaygpLnVuYmxvY2sgOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH07XG4gICAgICBsZXQgdW5tb3VudGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodW5tb3VudGVkKSB7XG4gICAgICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA+IDApIHtcbiAgICAgICAgICBkZWxldGUgZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXTtcbiAgICAgICAgICBjb25zb2xlLmluZm8oYFJldHJ5IHN1Y2Nlc3NmdWwgLSAke2ltYWdlUmVmLmN1cnJlbnQ/LnNyY30gaXMgbm93IGxvYWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgb25JbWFnZUZyYW1lPy4oY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBpZiAoIWltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50LnNyYyA9IGFjdHVhbFNyYztcbiAgICAgIGN1cnJlbnQuZGVjb2RlKCkudGhlbihvbkNvbXBsZXRlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICBpZiAoY3VycmVudC5jb21wbGV0ZSkge1xuICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uQ29tcGxldGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVubW91bnRlZCA9IHRydWU7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Db21wbGV0ZSk7XG4gICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgIH0sIFtcbiAgICAgIGFjdHVhbFNyYyxcbiAgICAgIGRlbGF5UGxheWJhY2ssXG4gICAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAgIHBhdXNlV2hlbkxvYWRpbmcsXG4gICAgICBpc1ByZW1vdW50aW5nLFxuICAgICAgaXNQb3N0bW91bnRpbmcsXG4gICAgICBvbkltYWdlRnJhbWUsXG4gICAgICBjb250aW51ZVJlbmRlcjIsXG4gICAgICBkZWxheVJlbmRlcjJcbiAgICBdKTtcbiAgfVxuICBjb25zdCBjcm9zc09yaWdpblZhbHVlID0gZ2V0Q3Jvc3NPcmlnaW5WYWx1ZSh7XG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgcmVxdWVzdHNWaWRlb0ZyYW1lOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNShcImltZ1wiLCB7XG4gICAgLi4ucHJvcHMyLFxuICAgIHJlZjogaW1hZ2VSZWYsXG4gICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luVmFsdWUsXG4gICAgb25FcnJvcjogZGlkR2V0RXJyb3IsXG4gICAgZGVjb2Rpbmc6IFwic3luY1wiXG4gIH0pO1xufTtcbnZhciBJbWcgPSBmb3J3YXJkUmVmOChJbWdSZWZGb3J3YXJkaW5nKTtcbi8vIHNyYy9pbnRlcm5hbHMudHNcbmltcG9ydCB7IGNyZWF0ZVJlZiBhcyBjcmVhdGVSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9Db21wb3NpdGlvbk1hbmFnZXIudHN4XG5pbXBvcnQgUmVhY3QyNSBmcm9tIFwicmVhY3RcIjtcbnZhciBjb21wb3NpdGlvbnNSZWYgPSBSZWFjdDI1LmNyZWF0ZVJlZigpO1xuXG4vLyBzcmMvQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIudHN4XG5pbXBvcnQge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU5LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yNSxcbiAgdXNlUmVmIGFzIHVzZVJlZjE1LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE3XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI2IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlbixcbiAgb25seVJlbmRlckNvbXBvc2l0aW9uLFxuICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgaW5pdGlhbENvbXBvc2l0aW9ucyxcbiAgaW5pdGlhbENhbnZhc0NvbnRlbnRcbn0pID0+IHtcbiAgY29uc3QgW2ZvbGRlcnMsIHNldEZvbGRlcnNdID0gdXNlU3RhdGUxNyhbXSk7XG4gIGNvbnN0IFtjYW52YXNDb250ZW50LCBzZXRDYW52YXNDb250ZW50XSA9IHVzZVN0YXRlMTcoaW5pdGlhbENhbnZhc0NvbnRlbnQpO1xuICBjb25zdCBbY29tcG9zaXRpb25zLCBzZXRDb21wb3NpdGlvbnNdID0gdXNlU3RhdGUxNyhpbml0aWFsQ29tcG9zaXRpb25zKTtcbiAgY29uc3QgY3VycmVudGNvbXBvc2l0aW9uc1JlZiA9IHVzZVJlZjE1KGNvbXBvc2l0aW9ucyk7XG4gIGNvbnN0IHVwZGF0ZUNvbXBvc2l0aW9ucyA9IHVzZUNhbGxiYWNrMTQoKHVwZGF0ZUNvbXBzKSA9PiB7XG4gICAgc2V0Q29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHVwZGF0ZUNvbXBzKGNvbXBzKTtcbiAgICAgIGN1cnJlbnRjb21wb3NpdGlvbnNSZWYuY3VycmVudCA9IHVwZGF0ZWQ7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCByZWdpc3RlckNvbXBvc2l0aW9uID0gdXNlQ2FsbGJhY2sxNCgoY29tcCkgPT4ge1xuICAgIHVwZGF0ZUNvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgIGlmIChjb21wcy5maW5kKChjMikgPT4gYzIuaWQgPT09IGNvbXAuaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgY29tcG9zaXRpb24gd2l0aCBpZCAke2NvbXAuaWR9IGFyZSByZWdpc3RlcmVkLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBbLi4uY29tcHMsIGNvbXBdLnNsaWNlKCkuc29ydCgoYTIsIGIyKSA9PiBhMi5ub25jZSAtIGIyLm5vbmNlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSwgW3VwZGF0ZUNvbXBvc2l0aW9uc10pO1xuICBjb25zdCB1bnJlZ2lzdGVyQ29tcG9zaXRpb24gPSB1c2VDYWxsYmFjazE0KChpZCkgPT4ge1xuICAgIHNldENvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgIHJldHVybiBjb21wcy5maWx0ZXIoKGMyKSA9PiBjMi5pZCAhPT0gaWQpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyRm9sZGVyID0gdXNlQ2FsbGJhY2sxNCgobmFtZSwgcGFyZW50KSA9PiB7XG4gICAgc2V0Rm9sZGVycygocHJldkZvbGRlcnMpID0+IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLnByZXZGb2xkZXJzLFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwYXJlbnRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyRm9sZGVyID0gdXNlQ2FsbGJhY2sxNCgobmFtZSwgcGFyZW50KSA9PiB7XG4gICAgc2V0Rm9sZGVycygocHJldkZvbGRlcnMpID0+IHtcbiAgICAgIHJldHVybiBwcmV2Rm9sZGVycy5maWx0ZXIoKHApID0+ICEocC5uYW1lID09PSBuYW1lICYmIHAucGFyZW50ID09PSBwYXJlbnQpKTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlOShjb21wb3NpdGlvbnNSZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Q29tcG9zaXRpb25zOiAoKSA9PiBjdXJyZW50Y29tcG9zaXRpb25zUmVmLmN1cnJlbnRcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzID0gdXNlQ2FsbGJhY2sxNCgoaWQsIG5ld0RlZmF1bHRQcm9wcykgPT4ge1xuICAgIHNldENvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBjb21wcy5tYXAoKGMyKSA9PiB7XG4gICAgICAgIGlmIChjMi5pZCA9PT0gaWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYzIsXG4gICAgICAgICAgICBkZWZhdWx0UHJvcHM6IG5ld0RlZmF1bHRQcm9wc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGMyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCBjb21wb3NpdGlvbk1hbmFnZXJTZXR0ZXJzID0gdXNlTWVtbzI1KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgICAgdW5yZWdpc3RlckZvbGRlcixcbiAgICAgIHNldENhbnZhc0NvbnRlbnQsXG4gICAgICB1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wcyxcbiAgICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvblxuICAgIH07XG4gIH0sIFtcbiAgICByZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICB1bnJlZ2lzdGVyRm9sZGVyLFxuICAgIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzLFxuICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvblxuICBdKTtcbiAgY29uc3QgY29tcG9zaXRpb25NYW5hZ2VyQ29udGV4dFZhbHVlID0gdXNlTWVtbzI1KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcG9zaXRpb25zLFxuICAgICAgZm9sZGVycyxcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgICAgY2FudmFzQ29udGVudFxuICAgIH07XG4gIH0sIFtjb21wb3NpdGlvbnMsIGZvbGRlcnMsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCBjYW52YXNDb250ZW50XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjYoQ29tcG9zaXRpb25NYW5hZ2VyLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbXBvc2l0aW9uTWFuYWdlckNvbnRleHRWYWx1ZSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KENvbXBvc2l0aW9uU2V0dGVycy5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbXBvc2l0aW9uTWFuYWdlclNldHRlcnMsXG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL2RlZmF1bHQtY3NzLnRzXG52YXIgZXhwb3J0c19kZWZhdWx0X2NzcyA9IHt9O1xuX19leHBvcnQoZXhwb3J0c19kZWZhdWx0X2Nzcywge1xuICBtYWtlRGVmYXVsdFByZXZpZXdDU1M6ICgpID0+IG1ha2VEZWZhdWx0UHJldmlld0NTUyxcbiAgaW5qZWN0Q1NTOiAoKSA9PiBpbmplY3RDU1MsXG4gIE9CSkVDVEZJVF9DT05UQUlOX0NMQVNTX05BTUU6ICgpID0+IE9CSkVDVEZJVF9DT05UQUlOX0NMQVNTX05BTUVcbn0pO1xudmFyIGluamVjdGVkID0ge307XG52YXIgaW5qZWN0Q1NTID0gKGNzcykgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbmplY3RlZFtjc3NdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICBoZWFkLnByZXBlbmQoc3R5bGUpO1xuICBpbmplY3RlZFtjc3NdID0gdHJ1ZTtcbn07XG52YXIgT0JKRUNURklUX0NPTlRBSU5fQ0xBU1NfTkFNRSA9IFwiX19yZW1vdGlvbl9vYmplY3RmaXRjb250YWluXCI7XG52YXIgbWFrZURlZmF1bHRQcmV2aWV3Q1NTID0gKHNjb3BlLCBiYWNrZ3JvdW5kQ29sb3IpID0+IHtcbiAgaWYgKCFzY29wZSkge1xuICAgIHJldHVybiBgXG4gICAgKiB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICBib2R5IHtcbiAgICAgIG1hcmdpbjogMDtcblx0ICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yfTtcbiAgICB9XG4gICAgLiR7T0JKRUNURklUX0NPTlRBSU5fQ0xBU1NfTkFNRX0ge1xuICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgICR7c2NvcGV9ICoge1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG4gICAgJHtzY29wZX0gKjotd2Via2l0LWZ1bGwtc2NyZWVuIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbiAgICAke3Njb3BlfSAuJHtPQkpFQ1RGSVRfQ09OVEFJTl9DTEFTU19OQU1FfSB7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cbiAgYDtcbn07XG5cbi8vIHNyYy9nZXQtcHJldmlldy1kb20tZWxlbWVudC50c1xudmFyIFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCA9IFwiX19yZW1vdGlvbi1zdHVkaW8tY29udGFpbmVyXCI7XG52YXIgZ2V0UHJldmlld0RvbUVsZW1lbnQgPSAoKSA9PiB7XG4gIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChSRU1PVElPTl9TVFVESU9fQ09OVEFJTkVSX0VMRU1FTlQpO1xufTtcblxuLy8gc3JjL21heC12aWRlby1jYWNoZS1zaXplLnRzXG5pbXBvcnQgUmVhY3QyNiBmcm9tIFwicmVhY3RcIjtcbnZhciBNYXhNZWRpYUNhY2hlU2l6ZUNvbnRleHQgPSBSZWFjdDI2LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbi8vIHNyYy9yZWdpc3Rlci1yb290LnRzXG52YXIgUm9vdCA9IG51bGw7XG52YXIgbGlzdGVuZXJzID0gW107XG52YXIgcmVnaXN0ZXJSb290ID0gKGNvbXApID0+IHtcbiAgaWYgKCFjb21wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgUmVhY3QgY29tcG9uZW50IHRvIHJlZ2lzdGVyUm9vdCgpLCBidXQgJHtKU09OLnN0cmluZ2lmeShjb21wKX0gd2FzIHBhc3NlZC5gKTtcbiAgfVxuICBpZiAoUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlZ2lzdGVyUm9vdCgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2UuXCIpO1xuICB9XG4gIFJvb3QgPSBjb21wO1xuICBsaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4ge1xuICAgIGwoY29tcCk7XG4gIH0pO1xufTtcbnZhciBnZXRSb290ID0gKCkgPT4ge1xuICByZXR1cm4gUm9vdDtcbn07XG52YXIgd2FpdEZvclJvb3QgPSAoZm4pID0+IHtcbiAgaWYgKFJvb3QpIHtcbiAgICBmbihSb290KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gIH1cbiAgbGlzdGVuZXJzLnB1c2goZm4pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKGwpID0+IGwgIT09IGZuKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9SZW1vdGlvblJvb3QudHN4XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTYsIHVzZU1lbW8gYXMgdXNlTWVtbzI3LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE4IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2UtbWVkaWEtZW5hYmxlZC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE5LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzMSwgdXNlTWVtbyBhcyB1c2VNZW1vMjYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyNyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE1lZGlhRW5hYmxlZENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTkobnVsbCk7XG52YXIgdXNlVmlkZW9FbmFibGVkID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDMxKE1lZGlhRW5hYmxlZENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICByZXR1cm4gd2luZG93LnJlbW90aW9uX3ZpZGVvRW5hYmxlZDtcbiAgfVxuICBpZiAoY29udGV4dC52aWRlb0VuYWJsZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gd2luZG93LnJlbW90aW9uX3ZpZGVvRW5hYmxlZDtcbiAgfVxuICByZXR1cm4gY29udGV4dC52aWRlb0VuYWJsZWQ7XG59O1xudmFyIHVzZUF1ZGlvRW5hYmxlZCA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQzMShNZWRpYUVuYWJsZWRDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9hdWRpb0VuYWJsZWQ7XG4gIH1cbiAgaWYgKGNvbnRleHQuYXVkaW9FbmFibGVkID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9hdWRpb0VuYWJsZWQ7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQuYXVkaW9FbmFibGVkO1xufTtcbnZhciBNZWRpYUVuYWJsZWRQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICB2aWRlb0VuYWJsZWQsXG4gIGF1ZGlvRW5hYmxlZFxufSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8yNigoKSA9PiAoeyB2aWRlb0VuYWJsZWQsIGF1ZGlvRW5hYmxlZCB9KSwgW3ZpZGVvRW5hYmxlZCwgYXVkaW9FbmFibGVkXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjcoTWVkaWFFbmFibGVkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL1JlbW90aW9uUm9vdC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyOCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlbW90aW9uUm9vdENvbnRleHRzID0gKHtcbiAgY2hpbGRyZW4sXG4gIG51bWJlck9mQXVkaW9UYWdzLFxuICBsb2dMZXZlbCxcbiAgYXVkaW9MYXRlbmN5SGludCxcbiAgdmlkZW9FbmFibGVkLFxuICBhdWRpb0VuYWJsZWQsXG4gIGZyYW1lU3RhdGVcbn0pID0+IHtcbiAgY29uc3QgW2Zhc3RSZWZyZXNoZXMsIHNldEZhc3RSZWZyZXNoZXNdID0gdXNlU3RhdGUxOCgwKTtcbiAgY29uc3QgW21hbnVhbFJlZnJlc2hlcywgc2V0TWFudWFsUmVmcmVzaGVzXSA9IHVzZVN0YXRlMTgoMCk7XG4gIGNvbnN0IG5vbmNlQ29udGV4dCA9IHVzZU1lbW8yNygoKSA9PiB7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICBnZXROb25jZTogKCkgPT4gY291bnRlcisrLFxuICAgICAgZmFzdFJlZnJlc2hlcyxcbiAgICAgIG1hbnVhbFJlZnJlc2hlc1xuICAgIH07XG4gIH0sIFtmYXN0UmVmcmVzaGVzLCBtYW51YWxSZWZyZXNoZXNdKTtcbiAgY29uc3Qgc2V0Tm9uY2VDb250ZXh0ID0gdXNlTWVtbzI3KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5jcmVhc2VNYW51YWxSZWZyZXNoZXM6ICgpID0+IHtcbiAgICAgICAgc2V0TWFudWFsUmVmcmVzaGVzKChpKSA9PiBpICsgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QxNigoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBfX3dlYnBhY2tfbW9kdWxlX18gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfX3dlYnBhY2tfbW9kdWxlX18uaG90KSB7XG4gICAgICAgIF9fd2VicGFja19tb2R1bGVfXy5ob3QuYWRkU3RhdHVzSGFuZGxlcigoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICAgIHNldEZhc3RSZWZyZXNoZXMoKGkpID0+IGkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBsb2dnaW5nID0gdXNlTWVtbzI3KCgpID0+IHtcbiAgICByZXR1cm4geyBsb2dMZXZlbCwgbW91bnRUaW1lOiBEYXRlLm5vdygpIH07XG4gIH0sIFtsb2dMZXZlbF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI4KExvZ0xldmVsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBsb2dnaW5nLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjgoTm9uY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogbm9uY2VDb250ZXh0LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChTZXROb25jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHNldE5vbmNlQ29udGV4dCxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChUaW1lbGluZUNvbnRleHRQcm92aWRlciwge1xuICAgICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChNZWRpYUVuYWJsZWRQcm92aWRlciwge1xuICAgICAgICAgICAgdmlkZW9FbmFibGVkLFxuICAgICAgICAgICAgYXVkaW9FbmFibGVkLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChFZGl0b3JQcm9wc1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjgoUHJlZmV0Y2hQcm92aWRlciwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjgoU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjgoU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvTGF0ZW5jeUhpbnQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjgoRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChCdWZmZXJpbmdQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9zZXR1cC1lbnYtdmFyaWFibGVzLnRzXG52YXIgZ2V0RW52VmFyaWFibGVzID0gKCkgPT4ge1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25fZW52VmFyaWFibGVzO1xuICAgIGlmICghcGFyYW0pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uSlNPTi5wYXJzZShwYXJhbSksIE5PREVfRU5WOiBcInByb2R1Y3Rpb25cIiB9O1xuICB9XG4gIGlmIChmYWxzZSkge31cbiAgcmV0dXJuIHtcbiAgICBOT0RFX0VOVjogXCJwcm9kdWN0aW9uXCJcbiAgfTtcbn07XG52YXIgc2V0dXBFbnZWYXJpYWJsZXMgPSAoKSA9PiB7XG4gIGNvbnN0IGVudiA9IGdldEVudlZhcmlhYmxlcygpO1xuICBpZiAoIXdpbmRvdy5wcm9jZXNzKSB7XG4gICAgd2luZG93LnByb2Nlc3MgPSB7fTtcbiAgfVxuICBpZiAoIXdpbmRvdy5wcm9jZXNzLmVudikge1xuICAgIHdpbmRvdy5wcm9jZXNzLmVudiA9IHt9O1xuICB9XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgd2luZG93LnByb2Nlc3MuZW52W2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvdXNlLWN1cnJlbnQtc2NhbGUudHNcbmltcG9ydCBSZWFjdDI4LCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIwIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgQ3VycmVudFNjYWxlQ29udGV4dCA9IFJlYWN0MjguY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBQcmV2aWV3U2l6ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MjAoe1xuICBzZXRTaXplOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBzaXplOiB7IHNpemU6IFwiYXV0b1wiLCB0cmFuc2xhdGlvbjogeyB4OiAwLCB5OiAwIH0gfVxufSk7XG52YXIgY2FsY3VsYXRlU2NhbGUgPSAoe1xuICBjYW52YXNTaXplLFxuICBjb21wb3NpdGlvbkhlaWdodCxcbiAgY29tcG9zaXRpb25XaWR0aCxcbiAgcHJldmlld1NpemVcbn0pID0+IHtcbiAgY29uc3QgaGVpZ2h0UmF0aW8gPSBjYW52YXNTaXplLmhlaWdodCAvIGNvbXBvc2l0aW9uSGVpZ2h0O1xuICBjb25zdCB3aWR0aFJhdGlvID0gY2FudmFzU2l6ZS53aWR0aCAvIGNvbXBvc2l0aW9uV2lkdGg7XG4gIGNvbnN0IHJhdGlvID0gTWF0aC5taW4oaGVpZ2h0UmF0aW8sIHdpZHRoUmF0aW8pO1xuICBpZiAocHJldmlld1NpemUgPT09IFwiYXV0b1wiKSB7XG4gICAgaWYgKHJhdGlvID09PSAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG4gIHJldHVybiBOdW1iZXIocHJldmlld1NpemUpO1xufTtcbnZhciB1c2VDdXJyZW50U2NhbGUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBoYXNDb250ZXh0ID0gUmVhY3QyOC51c2VDb250ZXh0KEN1cnJlbnRTY2FsZUNvbnRleHQpO1xuICBjb25zdCB6b29tQ29udGV4dCA9IFJlYWN0MjgudXNlQ29udGV4dChQcmV2aWV3U2l6ZUNvbnRleHQpO1xuICBjb25zdCBjb25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGlmIChoYXNDb250ZXh0ID09PSBudWxsIHx8IGNvbmZpZyA9PT0gbnVsbCB8fCB6b29tQ29udGV4dCA9PT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zPy5kb250VGhyb3dJZk91dHNpZGVPZlJlbW90aW9uKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGVudi5pc1JlbmRlcmluZykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICBcInVzZUN1cnJlbnRTY2FsZSgpIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBhIFJlbW90aW9uIGNvbnRleHQuXCIsXG4gICAgICBcIlRoaXMgaG9vayBjYW4gb25seSBiZSBjYWxsZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBiZWluZyByZW5kZXJlZCBieSBSZW1vdGlvbi5cIixcbiAgICAgIFwiSWYgeW91IHdhbnQgdG8gdGhpcyBob29rIHRvIHJldHVybiAxIG91dHNpZGUgb2YgUmVtb3Rpb24sIHBhc3Mge2RvbnRUaHJvd0lmT3V0c2lkZU9mUmVtb3Rpb246IHRydWV9IGFzIGFuIG9wdGlvbi5cIixcbiAgICAgIFwiSWYgeW91IHRoaW5rIHlvdSBjYWxsZWQgdGhpcyBob29rIGluIGEgUmVtb3Rpb24gY29tcG9uZW50LCBtYWtlIHN1cmUgYWxsIHZlcnNpb25zIG9mIFJlbW90aW9uIGFyZSBhbGlnbmVkLlwiXG4gICAgXS5qb2luKGBcbmApKTtcbiAgfVxuICBpZiAoaGFzQ29udGV4dC50eXBlID09PSBcInNjYWxlXCIpIHtcbiAgICByZXR1cm4gaGFzQ29udGV4dC5zY2FsZTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlU2NhbGUoe1xuICAgIGNhbnZhc1NpemU6IGhhc0NvbnRleHQuY2FudmFzU2l6ZSxcbiAgICBjb21wb3NpdGlvbkhlaWdodDogY29uZmlnLmhlaWdodCxcbiAgICBjb21wb3NpdGlvbldpZHRoOiBjb25maWcud2lkdGgsXG4gICAgcHJldmlld1NpemU6IHpvb21Db250ZXh0LnNpemUuc2l6ZVxuICB9KTtcbn07XG5cbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlby50c3hcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL09mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxNSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MzIsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNyxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDEwLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yOCxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxOVxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL29mZnRocmVhZC12aWRlby1zb3VyY2UudHNcbnZhciBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSA9ICh7XG4gIHNyYyxcbiAgdHJhbnNwYXJlbnQsXG4gIGN1cnJlbnRUaW1lLFxuICB0b25lTWFwcGVkXG59KSA9PiB7XG4gIHJldHVybiBgaHR0cDovL2xvY2FsaG9zdDoke3dpbmRvdy5yZW1vdGlvbl9wcm94eVBvcnR9L3Byb3h5P3NyYz0ke2VuY29kZVVSSUNvbXBvbmVudChnZXRBYnNvbHV0ZVNyYyhzcmMpKX0mdGltZT0ke2VuY29kZVVSSUNvbXBvbmVudChNYXRoLm1heCgwLCBjdXJyZW50VGltZSkpfSZ0cmFuc3BhcmVudD0ke1N0cmluZyh0cmFuc3BhcmVudCl9JnRvbmVNYXBwZWQ9JHtTdHJpbmcodG9uZU1hcHBlZCl9YDtcbn07XG5cbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlb0ZvclJlbmRlcmluZy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyOSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nID0gKHtcbiAgb25FcnJvcixcbiAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICBwbGF5YmFja1JhdGUsXG4gIHNyYyxcbiAgbXV0ZWQsXG4gIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgdHJhbnNwYXJlbnQsXG4gIHRvbmVNYXBwZWQsXG4gIHRvbmVGcmVxdWVuY3ksXG4gIG5hbWUsXG4gIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBvblZpZGVvRnJhbWUsXG4gIGNyb3NzT3JpZ2luLFxuICBhdWRpb1N0cmVhbUluZGV4LFxuICAuLi5wcm9wczJcbn0pID0+IHtcbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcHNGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvcik7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDMyKFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IG1lZGlhU3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MzIoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gYHNyY2Agd2FzIHBhc3NlZCB0byA8T2ZmdGhyZWFkVmlkZW8+LlwiKTtcbiAgfVxuICBjb25zdCBpZCA9IHVzZU1lbW8yOCgoKSA9PiBgb2ZmdGhyZWFkdmlkZW8tJHtyYW5kb20oc3JjKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfWAsIFtcbiAgICBzcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc1xuICBdKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIG1lZGlhVm9sdW1lOiAxXG4gIH0pO1xuICB3YXJuQWJvdXRUb29IaWdoVm9sdW1lKHZvbHVtZSk7XG4gIHVzZUVmZmVjdDE3KCgpID0+IHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3JjIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fYXVkaW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodm9sdW1lIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICB0eXBlOiBcInZpZGVvXCIsXG4gICAgICBzcmM6IGdldEFic29sdXRlU3JjKHNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGUsXG4gICAgICB0b25lRnJlcXVlbmN5LFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKSxcbiAgICAgIGF1ZGlvU3RyZWFtSW5kZXhcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgfSwgW1xuICAgIG11dGVkLFxuICAgIHNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgZnJhbWUsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBhdWRpb1N0cmVhbUluZGV4XG4gIF0pO1xuICBjb25zdCBjdXJyZW50VGltZSA9IHVzZU1lbW8yOCgoKSA9PiB7XG4gICAgcmV0dXJuIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkKHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgfHwgMSxcbiAgICAgIHN0YXJ0RnJvbTogLW1lZGlhU3RhcnRzQXRcbiAgICB9KSAvIHZpZGVvQ29uZmlnLmZwcztcbiAgfSwgW2ZyYW1lLCBtZWRpYVN0YXJ0c0F0LCBwbGF5YmFja1JhdGUsIHZpZGVvQ29uZmlnLmZwc10pO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VNZW1vMjgoKCkgPT4ge1xuICAgIHJldHVybiBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSh7XG4gICAgICBzcmMsXG4gICAgICBjdXJyZW50VGltZSxcbiAgICAgIHRyYW5zcGFyZW50LFxuICAgICAgdG9uZU1hcHBlZFxuICAgIH0pO1xuICB9LCBbdG9uZU1hcHBlZCwgY3VycmVudFRpbWUsIHNyYywgdHJhbnNwYXJlbnRdKTtcbiAgY29uc3QgW2ltYWdlU3JjLCBzZXRJbWFnZVNyY10gPSB1c2VTdGF0ZTE5KG51bGwpO1xuICBjb25zdCB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIgfSA9IHVzZURlbGF5UmVuZGVyKCk7XG4gIHVzZUxheW91dEVmZmVjdDEwKCgpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xlYW51cCA9IFtdO1xuICAgIHNldEltYWdlU3JjKG51bGwpO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyO1xuICAgIGNvbnN0IG5ld0hhbmRsZSA9IGRlbGF5UmVuZGVyMihgRmV0Y2hpbmcgJHthY3R1YWxTcmN9IGZyb20gc2VydmVyYCwge1xuICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFjdHVhbFNyYywge1xuICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgaWYgKGpzb24uZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFVwRXJyb3JNZXNzYWdlID0ganNvbi5lcnJvci5yZXBsYWNlKC9eRXJyb3I6IC8sIFwiXCIpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2xlYW5lZFVwRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmV0dXJuZWQgc3RhdHVzICR7cmVzLnN0YXR1c30gd2hpbGUgZmV0Y2hpbmcgJHthY3R1YWxTcmN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcy5ibG9iKCk7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIGNsZWFudXAucHVzaCgoKSA9PiBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCkpO1xuICAgICAgICBzZXRJbWFnZVNyYyh7XG4gICAgICAgICAgc3JjOiB1cmwsXG4gICAgICAgICAgaGFuZGxlOiBuZXdIYW5kbGVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiYWJvcnRlZFwiKSkge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke2FjdHVhbFNyY30uIFRoaXMgY291bGQgYmUgY2F1c2VkIGJ5IENocm9tZSByZWplY3RpbmcgdGhlIHJlcXVlc3QgYmVjYXVzZSB0aGUgZGlzayBzcGFjZSBpcyBsb3cuIENvbnNpZGVyIGluY3JlYXNpbmcgdGhlIGRpc2sgc2l6ZSBvZiB5b3VyIGVudmlyb25tZW50LmAsIHsgY2F1c2U6IGVyciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5jZWxSZW5kZXIoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZXhlY3V0ZSgpO1xuICAgIGNsZWFudXAucHVzaCgoKSA9PiB7XG4gICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXAuZm9yRWFjaCgoYzIpID0+IGMyKCkpO1xuICAgIH07XG4gIH0sIFtcbiAgICBhY3R1YWxTcmMsXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAgIG9uRXJyb3IsXG4gICAgY29udGludWVSZW5kZXIyLFxuICAgIGRlbGF5UmVuZGVyMlxuICBdKTtcbiAgY29uc3Qgb25FcnIgPSB1c2VDYWxsYmFjazE1KCgpID0+IHtcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgb25FcnJvcj8uKG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGltYWdlIHdpdGggc3JjIFwiICsgaW1hZ2VTcmMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuY2VsUmVuZGVyKFwiRmFpbGVkIHRvIGxvYWQgaW1hZ2Ugd2l0aCBzcmMgXCIgKyBpbWFnZVNyYyk7XG4gICAgfVxuICB9LCBbaW1hZ2VTcmMsIG9uRXJyb3JdKTtcbiAgY29uc3QgY2xhc3NOYW1lID0gdXNlTWVtbzI4KCgpID0+IHtcbiAgICByZXR1cm4gW09CSkVDVEZJVF9DT05UQUlOX0NMQVNTX05BTUUsIHByb3BzMi5jbGFzc05hbWVdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgXCIpO1xuICB9LCBbcHJvcHMyLmNsYXNzTmFtZV0pO1xuICBjb25zdCBvbkltYWdlRnJhbWUgPSB1c2VDYWxsYmFjazE1KChpbWcpID0+IHtcbiAgICBpZiAob25WaWRlb0ZyYW1lKSB7XG4gICAgICBvblZpZGVvRnJhbWUoaW1nKTtcbiAgICB9XG4gIH0sIFtvblZpZGVvRnJhbWVdKTtcbiAgaWYgKCFpbWFnZVNyYyB8fCAhd2luZG93LnJlbW90aW9uX3ZpZGVvRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnRpbnVlUmVuZGVyMihpbWFnZVNyYy5oYW5kbGUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI5KEltZywge1xuICAgIHNyYzogaW1hZ2VTcmMuc3JjLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBvbkltYWdlRnJhbWUsXG4gICAgLi4ucHJvcHMyLFxuICAgIG9uRXJyb3I6IG9uRXJyLFxuICAgIGNsYXNzTmFtZVxuICB9KTtcbn07XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclByZXZpZXcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY5LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzMyxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE5LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUxMCxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjksXG4gIHVzZVJlZiBhcyB1c2VSZWYxNixcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUyMFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL2VtaXQtdmlkZW8tZnJhbWUudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxOCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUVtaXRWaWRlb0ZyYW1lID0gKHtcbiAgcmVmLFxuICBvblZpZGVvRnJhbWVcbn0pID0+IHtcbiAgdXNlRWZmZWN0MTgoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gcmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9uVmlkZW9GcmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlID0gMDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmICghcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25WaWRlb0ZyYW1lKHJlZi5jdXJyZW50KTtcbiAgICAgIGhhbmRsZSA9IHJlZi5jdXJyZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIH07XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2soaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbb25WaWRlb0ZyYW1lLCByZWZdKTtcbn07XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclByZXZpZXcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzAgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBWaWRlb0ZvckRldmVsb3BtZW50UmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzMiwgcmVmKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MzMoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcmVkQXVkaW9Db250ZXh0IG5vdCBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjE2KG51bGwpO1xuICBjb25zdCBzaGFyZWRTb3VyY2UgPSB1c2VNZW1vMjkoKCkgPT4ge1xuICAgIGlmICghY29udGV4dC5hdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVNoYXJlZEVsZW1lbnRTb3VyY2VOb2RlKHtcbiAgICAgIGF1ZGlvQ29udGV4dDogY29udGV4dC5hdWRpb0NvbnRleHQsXG4gICAgICByZWY6IHZpZGVvUmVmXG4gICAgfSk7XG4gIH0sIFtjb250ZXh0LmF1ZGlvQ29udGV4dF0pO1xuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIHNyYyxcbiAgICBvbkR1cmF0aW9uLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnQsXG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyxcbiAgICB0b25lRnJlcXVlbmN5LFxuICAgIG5hbWUsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc3R5bGUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICAgIG9uRXJyb3IsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIG9uVmlkZW9GcmFtZSxcbiAgICBjcm9zc09yaWdpbixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgIHVzZVdlYkF1ZGlvQXBpLFxuICAgIGF1ZGlvU3RyZWFtSW5kZXgsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzMjtcbiAgY29uc3QgX3Byb3BzVmFsaWQgPSB0cnVlO1xuICBpZiAoIV9wcm9wc1ZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZWNoZWNrIGVycm9yXCIpO1xuICB9XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgeyBmcHMsIGR1cmF0aW9uSW5GcmFtZXMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDMzKFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MzMoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGNvbnN0IFt0aW1lbGluZUlkXSA9IHVzZVN0YXRlMjAoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlblt0aW1lbGluZUlkXSA/PyBmYWxzZTtcbiAgaWYgKHR5cGVvZiBhY2NlcHRhYmxlVGltZVNoaWZ0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWNjZXB0YWJsZVRpbWVTaGlmdCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjb25zdCBbbWVkaWFWb2x1bWVdID0gdXNlTWVkaWFWb2x1bWVTdGF0ZSgpO1xuICBjb25zdCBbbWVkaWFNdXRlZF0gPSB1c2VNZWRpYU11dGVkU3RhdGUoKTtcbiAgY29uc3QgdXNlclByZWZlcnJlZFZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICBmcmFtZTogdm9sdW1lUHJvcEZyYW1lLFxuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZVxuICB9KTtcbiAgd2FybkFib3V0VG9vSGlnaFZvbHVtZSh1c2VyUHJlZmVycmVkVm9sdW1lKTtcbiAgdXNlTWVkaWFJblRpbWVsaW5lKHtcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFUeXBlOiBcInZpZGVvXCIsXG4gICAgc3JjLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIGRpc3BsYXlOYW1lOiBuYW1lID8/IG51bGwsXG4gICAgaWQ6IHRpbWVsaW5lSWQsXG4gICAgc3RhY2s6IF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5OiBwYXJlbnRTZXF1ZW5jZT8ucHJlbW91bnREaXNwbGF5ID8/IG51bGwsXG4gICAgcG9zdG1vdW50RGlzcGxheTogcGFyZW50U2VxdWVuY2U/LnBvc3Rtb3VudERpc3BsYXkgPz8gbnVsbCxcbiAgICBsb29wRGlzcGxheTogdW5kZWZpbmVkXG4gIH0pO1xuICB1c2VNZWRpYVBsYXliYWNrKHtcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJ2aWRlb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgYWNjZXB0YWJsZVRpbWVzaGlmdDogYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyA/PyBudWxsLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4ocGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nKSxcbiAgICBpc1Bvc3Rtb3VudGluZzogQm9vbGVhbihwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nKSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gbnVsbFxuICB9KTtcbiAgdXNlTWVkaWFUYWcoe1xuICAgIGlkOiB0aW1lbGluZUlkLFxuICAgIGlzUG9zdG1vdW50aW5nOiBCb29sZWFuKHBhcmVudFNlcXVlbmNlPy5wb3N0bW91bnRpbmcpLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4ocGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nKSxcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgbWVkaWFUeXBlOiBcInZpZGVvXCIsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gbnVsbFxuICB9KTtcbiAgdXNlVm9sdW1lKHtcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgdm9sdW1lOiB1c2VyUHJlZmVycmVkVm9sdW1lLFxuICAgIHNvdXJjZTogc2hhcmVkU291cmNlLFxuICAgIHNob3VsZFVzZVdlYkF1ZGlvQXBpOiB1c2VXZWJBdWRpb0FwaSA/PyBmYWxzZVxuICB9KTtcbiAgY29uc3QgYWN0dWFsRnJvbSA9IHBhcmVudFNlcXVlbmNlID8gcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tIDogMDtcbiAgY29uc3QgZHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMsIGR1cmF0aW9uSW5GcmFtZXMpIDogZHVyYXRpb25JbkZyYW1lcztcbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChzcmMpO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VBcHBlbmRWaWRlb0ZyYWdtZW50KHtcbiAgICBhY3R1YWxTcmM6IHByZWxvYWRlZFNyYyxcbiAgICBhY3R1YWxGcm9tLFxuICAgIGR1cmF0aW9uLFxuICAgIGZwc1xuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTEwKHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB2aWRlb1JlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHVzZVN0YXRlMjAoKCkgPT4gcGxheWJhY2tMb2dnaW5nKHtcbiAgICBsb2dMZXZlbCxcbiAgICBtZXNzYWdlOiBgTW91bnRpbmcgdmlkZW8gd2l0aCBzb3VyY2UgPSAke2FjdHVhbFNyY30sIHY9JHtWRVJTSU9OfSwgdXNlciBhZ2VudD0ke3R5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgPyBcInNlcnZlclwiIDogbmF2aWdhdG9yLnVzZXJBZ2VudH1gLFxuICAgIHRhZzogXCJ2aWRlb1wiLFxuICAgIG1vdW50VGltZVxuICB9KSk7XG4gIHVzZUVmZmVjdDE5KCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoY3VycmVudC5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb2NjdXJyZWQgaW4gdmlkZW9cIiwgY3VycmVudD8uZXJyb3IpO1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX06ICR7Y3VycmVudC5lcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvciB3aGlsZSBwbGF5aW5nIHRoZSB2aWRlbyAke3NyY306IENvZGUgJHtjdXJyZW50LmVycm9yLmNvZGV9IC0gJHtjdXJyZW50Py5lcnJvcj8ubWVzc2FnZX0uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL21lZGlhLXBsYXliYWNrLWVycm9yIGZvciBoZWxwLiBQYXNzIGFuIG9uRXJyb3IoKSBwcm9wIHRvIGhhbmRsZSB0aGUgZXJyb3IuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtzcmN9YCk7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvciB3aGlsZSBwbGF5aW5nIHRoZSB2aWRlb1wiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgIH07XG4gIH0sIFtvbkVycm9yLCBzcmNdKTtcbiAgY29uc3QgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjayA9IHVzZVJlZjE2KG9uRHVyYXRpb24pO1xuICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQgPSBvbkR1cmF0aW9uO1xuICB1c2VFbWl0VmlkZW9GcmFtZSh7IHJlZjogdmlkZW9SZWYsIG9uVmlkZW9GcmFtZSB9KTtcbiAgdXNlRWZmZWN0MTkoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LmR1cmF0aW9uKSB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbkxvYWRlZE1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50Py4oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICB9O1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICB9O1xuICB9LCBbc3JjXSk7XG4gIHVzZUVmZmVjdDE5KCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNJb3NTYWZhcmkoKSkge1xuICAgICAgY3VycmVudC5wcmVsb2FkID0gXCJtZXRhZGF0YVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnByZWxvYWQgPSBcImF1dG9cIjtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgYWN0dWFsU3R5bGUgPSB1c2VNZW1vMjkoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIG9wYWNpdHk6IGlzU2VxdWVuY2VIaWRkZW4gPyAwIDogc3R5bGU/Lm9wYWNpdHkgPz8gMVxuICAgIH07XG4gIH0sIFtpc1NlcXVlbmNlSGlkZGVuLCBzdHlsZV0pO1xuICBjb25zdCBjcm9zc09yaWdpblZhbHVlID0gZ2V0Q3Jvc3NPcmlnaW5WYWx1ZSh7XG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgcmVxdWVzdHNWaWRlb0ZyYW1lOiBCb29sZWFuKG9uVmlkZW9GcmFtZSlcbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzAoXCJ2aWRlb1wiLCB7XG4gICAgcmVmOiB2aWRlb1JlZixcbiAgICBtdXRlZDogbXV0ZWQgfHwgbWVkaWFNdXRlZCB8fCBpc1NlcXVlbmNlSGlkZGVuIHx8IHVzZXJQcmVmZXJyZWRWb2x1bWUgPD0gMCxcbiAgICBwbGF5c0lubGluZTogdHJ1ZSxcbiAgICBzcmM6IGFjdHVhbFNyYyxcbiAgICBsb29wOiBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgc3R5bGU6IGFjdHVhbFN0eWxlLFxuICAgIGRpc2FibGVSZW1vdGVQbGF5YmFjazogdHJ1ZSxcbiAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5WYWx1ZSxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9KTtcbn07XG52YXIgVmlkZW9Gb3JQcmV2aWV3ID0gZm9yd2FyZFJlZjkoVmlkZW9Gb3JEZXZlbG9wbWVudFJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5cbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlby50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzMSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIElubmVyT2ZmdGhyZWFkVmlkZW8gPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEZyb20sXG4gICAgZW5kQXQsXG4gICAgdHJpbUJlZm9yZSxcbiAgICB0cmltQWZ0ZXIsXG4gICAgbmFtZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHMyO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3Qgb25EdXJhdGlvbiA9IHVzZUNhbGxiYWNrMTYoKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSwgW10pO1xuICBpZiAodHlwZW9mIHByb3BzMi5zcmMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPE9mZnRocmVhZFZpZGVvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzMi5zcmMpfSBpbnN0ZWFkLmApO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFUcmltUHJvcHMoeyBzdGFydEZyb20sIGVuZEF0LCB0cmltQmVmb3JlLCB0cmltQWZ0ZXIgfSk7XG4gIGNvbnN0IHsgdHJpbUJlZm9yZVZhbHVlLCB0cmltQWZ0ZXJWYWx1ZSB9ID0gcmVzb2x2ZVRyaW1Qcm9wcyh7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdHJpbUFmdGVyXG4gIH0pO1xuICBpZiAodHlwZW9mIHRyaW1CZWZvcmVWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdHJpbUFmdGVyVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtICh0cmltQmVmb3JlVmFsdWUgPz8gMCksXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiB0cmltQWZ0ZXJWYWx1ZSxcbiAgICAgIG5hbWUsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMxKElubmVyT2ZmdGhyZWFkVmlkZW8sIHtcbiAgICAgICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICAgIHRyaW1BZnRlcjogdW5kZWZpbmVkLFxuICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHNob3dJblRpbWVsaW5lLFxuICAgICAgICB0cmltQmVmb3JlOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YWNrOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0RnJvbTogdW5kZWZpbmVkLFxuICAgICAgICBlbmRBdDogdW5kZWZpbmVkXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFQcm9wcyhwcm9wczIsIFwiVmlkZW9cIik7XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzEoT2ZmdGhyZWFkVmlkZW9Gb3JSZW5kZXJpbmcsIHtcbiAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgIHRyaW1BZnRlcjogdW5kZWZpbmVkLFxuICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgc2hvd0luVGltZWxpbmUsXG4gICAgICB0cmltQmVmb3JlOiB1bmRlZmluZWQsXG4gICAgICBzdGFjazogdW5kZWZpbmVkLFxuICAgICAgc3RhcnRGcm9tOiB1bmRlZmluZWQsXG4gICAgICBlbmRBdDogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHRyYW5zcGFyZW50LFxuICAgIHRvbmVNYXBwZWQsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIG9uVmlkZW9GcmFtZSxcbiAgICBjcm9zc09yaWdpbixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgLi4ucHJvcHNGb3JQcmV2aWV3XG4gIH0gPSBvdGhlclByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKFZpZGVvRm9yUHJldmlldywge1xuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgb25EdXJhdGlvbixcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yOiB0cnVlLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgIHNob3dJblRpbWVsaW5lOiBzaG93SW5UaW1lbGluZSA/PyB0cnVlLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IHVuZGVmaW5lZCxcbiAgICBvblZpZGVvRnJhbWU6IG9uVmlkZW9GcmFtZSA/PyBudWxsLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIC4uLnByb3BzRm9yUHJldmlldyxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IGZhbHNlXG4gIH0pO1xufTtcbnZhciBPZmZ0aHJlYWRWaWRlbyA9ICh7XG4gIHNyYyxcbiAgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyxcbiAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICBhdWRpb1N0cmVhbUluZGV4LFxuICBjbGFzc05hbWUsXG4gIGNyb3NzT3JpZ2luLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBpZCxcbiAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gIG11dGVkLFxuICBuYW1lLFxuICBvbkF1dG9QbGF5RXJyb3IsXG4gIG9uRXJyb3IsXG4gIG9uVmlkZW9GcmFtZSxcbiAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICBwbGF5YmFja1JhdGUsXG4gIHNob3dJblRpbWVsaW5lLFxuICBzdHlsZSxcbiAgdG9uZUZyZXF1ZW5jeSxcbiAgdG9uZU1hcHBlZCxcbiAgdHJhbnNwYXJlbnQsXG4gIHRyaW1BZnRlcixcbiAgdHJpbUJlZm9yZSxcbiAgdXNlV2ViQXVkaW9BcGksXG4gIHZvbHVtZSxcbiAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICBlbmRBdCxcbiAgc3RhY2ssXG4gIHN0YXJ0RnJvbSxcbiAgaW1hZ2VGb3JtYXRcbn0pID0+IHtcbiAgaWYgKGltYWdlRm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxPZmZ0aHJlYWRWaWRlbz5cXGAgdGFnIGRvZXMgbm8gbG9uZ2VyIGFjY2VwdCBcXGBpbWFnZUZvcm1hdFxcYC4gVXNlIHRoZSBcXGB0cmFuc3BhcmVudFxcYCBwcm9wIGlmIHlvdSB3YW50IHRvIHJlbmRlciBhIHRyYW5zcGFyZW50IHZpZGVvLmApO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzEoSW5uZXJPZmZ0aHJlYWRWaWRlbywge1xuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgPz8gdHJ1ZSxcbiAgICBhdWRpb1N0cmVhbUluZGV4OiBhdWRpb1N0cmVhbUluZGV4ID8/IDAsXG4gICAgY2xhc3NOYW1lLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBpZCxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcjogbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IgPz8gXCJyZXBlYXRcIixcbiAgICBtdXRlZDogbXV0ZWQgPz8gZmFsc2UsXG4gICAgbmFtZSxcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG9uQXV0b1BsYXlFcnJvciA/PyBudWxsLFxuICAgIG9uRXJyb3IsXG4gICAgb25WaWRlb0ZyYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IHRydWUsXG4gICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICB0b25lRnJlcXVlbmN5OiB0b25lRnJlcXVlbmN5ID8/IDEsXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWUsXG4gICAgc3JjLFxuICAgIHN0YWNrLFxuICAgIHN0YXJ0RnJvbSxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCA/PyBmYWxzZSxcbiAgICBlbmRBdCxcbiAgICBzdHlsZSxcbiAgICB0b25lTWFwcGVkOiB0b25lTWFwcGVkID8/IHRydWUsXG4gICAgdHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50ID8/IGZhbHNlLFxuICAgIHRyaW1BZnRlcixcbiAgICB0cmltQmVmb3JlLFxuICAgIHVzZVdlYkF1ZGlvQXBpOiB1c2VXZWJBdWRpb0FwaSA/PyBmYWxzZSxcbiAgICB2b2x1bWVcbiAgfSk7XG59O1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhPZmZ0aHJlYWRWaWRlbyk7XG5cbi8vIHNyYy93YXRjaC1zdGF0aWMtZmlsZS50c1xudmFyIFdBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUyA9IFwicmVtb3Rpb25fc3RhdGljRmlsZXNDaGFuZ2VkXCI7XG52YXIgd2F0Y2hTdGF0aWNGaWxlID0gKGZpbGVOYW1lLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3YXRjaFN0YXRpY0ZpbGUoKSBoYXMgbW92ZWQgaW50byB0aGUgYEByZW1vdGlvbi9zdHVkaW9gIHBhY2thZ2UuIFVwZGF0ZSB5b3VyIGltcG9ydHMuXCIpO1xuICB9XG4gIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIHdhdGNoU3RhdGljRmlsZSgpIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSB3aGlsZSB1c2luZyB0aGUgUmVtb3Rpb24gU3R1ZGlvLlwiKTtcbiAgICByZXR1cm4geyBjYW5jZWw6ICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9IH07XG4gIH1cbiAgY29uc3Qgd2l0aG91dFN0YXRpY0Jhc2UgPSBmaWxlTmFtZS5zdGFydHNXaXRoKHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlKSA/IGZpbGVOYW1lLnJlcGxhY2Uod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UsIFwiXCIpIDogZmlsZU5hbWU7XG4gIGNvbnN0IHdpdGhvdXRMZWFkaW5nU2xhc2ggPSB3aXRob3V0U3RhdGljQmFzZS5zdGFydHNXaXRoKFwiL1wiKSA/IHdpdGhvdXRTdGF0aWNCYXNlLnNsaWNlKDEpIDogd2l0aG91dFN0YXRpY0Jhc2U7XG4gIGxldCBwcmV2RmlsZURhdGEgPSB3aW5kb3cucmVtb3Rpb25fc3RhdGljRmlsZXMuZmluZCgoZmlsZSkgPT4gZmlsZS5uYW1lID09PSB3aXRob3V0TGVhZGluZ1NsYXNoKTtcbiAgY29uc3QgY2hlY2tGaWxlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3Qgc3RhdGljRmlsZXMgPSBldmVudC5kZXRhaWwuZmlsZXM7XG4gICAgY29uc3QgbmV3RmlsZURhdGEgPSBzdGF0aWNGaWxlcy5maW5kKChmaWxlKSA9PiBmaWxlLm5hbWUgPT09IHdpdGhvdXRMZWFkaW5nU2xhc2gpO1xuICAgIGlmICghbmV3RmlsZURhdGEpIHtcbiAgICAgIGlmIChwcmV2RmlsZURhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgIH1cbiAgICAgIHByZXZGaWxlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZGaWxlRGF0YSA9PT0gdW5kZWZpbmVkIHx8IHByZXZGaWxlRGF0YS5sYXN0TW9kaWZpZWQgIT09IG5ld0ZpbGVEYXRhLmxhc3RNb2RpZmllZCkge1xuICAgICAgY2FsbGJhY2sobmV3RmlsZURhdGEpO1xuICAgICAgcHJldkZpbGVEYXRhID0gbmV3RmlsZURhdGE7XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsIGNoZWNrRmlsZSk7XG4gIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTLCBjaGVja0ZpbGUpO1xuICB9O1xuICByZXR1cm4geyBjYW5jZWwgfTtcbn07XG5cbi8vIHNyYy93cmFwLXJlbW90aW9uLWNvbnRleHQudHN4XG5pbXBvcnQgUmVhY3QzMiwgeyB1c2VNZW1vIGFzIHVzZU1lbW8zMCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDMyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiB1c2VSZW1vdGlvbkNvbnRleHRzKCkge1xuICBjb25zdCBjb21wb3NpdGlvbk1hbmFnZXJDdHggPSBSZWFjdDMyLnVzZUNvbnRleHQoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3QgdGltZWxpbmVDb250ZXh0ID0gUmVhY3QzMi51c2VDb250ZXh0KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dCA9IFJlYWN0MzIudXNlQ29udGV4dChTZXRUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSBSZWFjdDMyLnVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3Qgbm9uY2VDb250ZXh0ID0gUmVhY3QzMi51c2VDb250ZXh0KE5vbmNlQ29udGV4dCk7XG4gIGNvbnN0IGNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0ID0gUmVhY3QzMi51c2VDb250ZXh0KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBjb25zdCBwcmVsb2FkQ29udGV4dCA9IFJlYWN0MzIudXNlQ29udGV4dChQcmVsb2FkQ29udGV4dCk7XG4gIGNvbnN0IHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQgPSBSZWFjdDMyLnVzZUNvbnRleHQoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCk7XG4gIGNvbnN0IHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQgPSBSZWFjdDMyLnVzZUNvbnRleHQoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3Qgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MzIudXNlQ29udGV4dChTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCBidWZmZXJNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MzIudXNlQ29udGV4dChCdWZmZXJpbmdDb250ZXh0UmVhY3QpO1xuICBjb25zdCBsb2dMZXZlbENvbnRleHQgPSBSZWFjdDMyLnVzZUNvbnRleHQoTG9nTGV2ZWxDb250ZXh0KTtcbiAgcmV0dXJuIHVzZU1lbW8zMCgoKSA9PiAoe1xuICAgIGNvbXBvc2l0aW9uTWFuYWdlckN0eCxcbiAgICB0aW1lbGluZUNvbnRleHQsXG4gICAgc2V0VGltZWxpbmVDb250ZXh0LFxuICAgIHNlcXVlbmNlQ29udGV4dCxcbiAgICBub25jZUNvbnRleHQsXG4gICAgY2FuVXNlUmVtb3Rpb25Ib29rc0NvbnRleHQsXG4gICAgcHJlbG9hZENvbnRleHQsXG4gICAgcmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCxcbiAgICByZW5kZXJBc3NldE1hbmFnZXJDb250ZXh0LFxuICAgIHNlcXVlbmNlTWFuYWdlckNvbnRleHQsXG4gICAgYnVmZmVyTWFuYWdlckNvbnRleHQsXG4gICAgbG9nTGV2ZWxDb250ZXh0XG4gIH0pLCBbXG4gICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgIG5vbmNlQ29udGV4dCxcbiAgICBzZXF1ZW5jZUNvbnRleHQsXG4gICAgc2V0VGltZWxpbmVDb250ZXh0LFxuICAgIHRpbWVsaW5lQ29udGV4dCxcbiAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBwcmVsb2FkQ29udGV4dCxcbiAgICByZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LFxuICAgIHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQsXG4gICAgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCxcbiAgICBidWZmZXJNYW5hZ2VyQ29udGV4dCxcbiAgICBsb2dMZXZlbENvbnRleHRcbiAgXSk7XG59XG52YXIgUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIgPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRleHRzIH0gPSBwcm9wczI7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzIoTG9nTGV2ZWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRzLmxvZ0xldmVsQ29udGV4dCxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMyKENhblVzZVJlbW90aW9uSG9va3MuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0cy5jYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzIoTm9uY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0cy5ub25jZUNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzIoUHJlbG9hZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICB2YWx1ZTogY29udGV4dHMucHJlbG9hZENvbnRleHQsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMihDb21wb3NpdGlvbk1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5jb21wb3NpdGlvbk1hbmFnZXJDdHgsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMyKFNlcXVlbmNlTWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMihSZW5kZXJBc3NldE1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMucmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMyKFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5yZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMihUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnRpbWVsaW5lQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMihTZXRUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuc2V0VGltZWxpbmVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzIoU2VxdWVuY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuc2VxdWVuY2VDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMihCdWZmZXJpbmdDb250ZXh0UmVhY3QuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLmJ1ZmZlck1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9pbnRlcm5hbHMudHNcbnZhciBjb21wb3NpdGlvblNlbGVjdG9yUmVmID0gY3JlYXRlUmVmMygpO1xudmFyIEludGVybmFscyA9IHtcbiAgTWF4TWVkaWFDYWNoZVNpemVDb250ZXh0LFxuICB1c2VVbnNhZmVWaWRlb0NvbmZpZyxcbiAgdXNlRnJhbWVGb3JWb2x1bWVQcm9wLFxuICB1c2VUaW1lbGluZVBvc2l0aW9uLFxuICBldmFsdWF0ZVZvbHVtZSxcbiAgZ2V0QWJzb2x1dGVTcmMsXG4gIFRpbWVsaW5lOiBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLFxuICB2YWxpZGF0ZU1lZGlhVHJpbVByb3BzLFxuICB2YWxpZGF0ZU1lZGlhUHJvcHMsXG4gIHJlc29sdmVUcmltUHJvcHMsXG4gIFZpZGVvRm9yUHJldmlldyxcbiAgQ29tcG9zaXRpb25NYW5hZ2VyLFxuICBDb21wb3NpdGlvblNldHRlcnMsXG4gIFNlcXVlbmNlTWFuYWdlcixcbiAgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCxcbiAgUmVtb3Rpb25Sb290Q29udGV4dHMsXG4gIENvbXBvc2l0aW9uTWFuYWdlclByb3ZpZGVyLFxuICB1c2VWaWRlbyxcbiAgZ2V0Um9vdCxcbiAgdXNlTWVkaWFWb2x1bWVTdGF0ZSxcbiAgdXNlTWVkaWFNdXRlZFN0YXRlLFxuICB1c2VNZWRpYUluVGltZWxpbmUsXG4gIHVzZUxhenlDb21wb25lbnQsXG4gIHRydXRoeSxcbiAgU2VxdWVuY2VDb250ZXh0LFxuICB1c2VSZW1vdGlvbkNvbnRleHRzLFxuICBSZW1vdGlvbkNvbnRleHRQcm92aWRlcixcbiAgQ1NTVXRpbHM6IGV4cG9ydHNfZGVmYXVsdF9jc3MsXG4gIHNldHVwRW52VmFyaWFibGVzLFxuICBNZWRpYVZvbHVtZUNvbnRleHQsXG4gIFNldE1lZGlhVm9sdW1lQ29udGV4dCxcbiAgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCxcbiAgU2hhcmVkQXVkaW9Db250ZXh0LFxuICBTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlcixcbiAgaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlLFxuICBjYWxjdWxhdGVNZWRpYUR1cmF0aW9uLFxuICBpc0NvbXBvc2l0aW9uSWRWYWxpZCxcbiAgZ2V0UHJldmlld0RvbUVsZW1lbnQsXG4gIGNvbXBvc2l0aW9uc1JlZixcbiAgcG9ydGFsTm9kZSxcbiAgd2FpdEZvclJvb3QsXG4gIFNldFRpbWVsaW5lQ29udGV4dCxcbiAgQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyLFxuICBDYW5Vc2VSZW1vdGlvbkhvb2tzLFxuICBQcmVmZXRjaFByb3ZpZGVyLFxuICBEdXJhdGlvbnNDb250ZXh0UHJvdmlkZXIsXG4gIElzUGxheWVyQ29udGV4dFByb3ZpZGVyLFxuICB1c2VJc1BsYXllcixcbiAgRWRpdG9yUHJvcHNQcm92aWRlcixcbiAgRWRpdG9yUHJvcHNDb250ZXh0LFxuICB1c2VQcmVsb2FkLFxuICBOb25jZUNvbnRleHQsXG4gIFNldE5vbmNlQ29udGV4dCxcbiAgcmVzb2x2ZVZpZGVvQ29uZmlnLFxuICB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnLFxuICByZXNvbHZlQ29tcG9zaXRpb25zUmVmLFxuICBSZXNvbHZlQ29tcG9zaXRpb25Db25maWdJblN0dWRpbyxcbiAgUkVNT1RJT05fU1RVRElPX0NPTlRBSU5FUl9FTEVNRU5ULFxuICBSZW5kZXJBc3NldE1hbmFnZXIsXG4gIHBlcnNpc3RDdXJyZW50RnJhbWUsXG4gIHVzZVRpbWVsaW5lU2V0RnJhbWUsXG4gIGlzSW9zU2FmYXJpLFxuICBXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsXG4gIGFkZFNlcXVlbmNlU3RhY2tUcmFjZXMsXG4gIHVzZU1lZGlhU3RhcnRzQXQsXG4gIEJ1ZmZlcmluZ1Byb3ZpZGVyLFxuICBCdWZmZXJpbmdDb250ZXh0UmVhY3QsXG4gIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMsXG4gIEN1cnJlbnRTY2FsZUNvbnRleHQsXG4gIFByZXZpZXdTaXplQ29udGV4dCxcbiAgY2FsY3VsYXRlU2NhbGUsXG4gIGVkaXRvclByb3BzUHJvdmlkZXJSZWYsXG4gIFBST1BTX1VQREFURURfRVhURVJOQUxMWSxcbiAgdmFsaWRhdGVSZW5kZXJBc3NldCxcbiAgTG9nLFxuICBMb2dMZXZlbENvbnRleHQsXG4gIHVzZUxvZ0xldmVsLFxuICBwbGF5YmFja0xvZ2dpbmcsXG4gIHRpbWVWYWx1ZVJlZixcbiAgY29tcG9zaXRpb25TZWxlY3RvclJlZixcbiAgUmVtb3Rpb25FbnZpcm9ubWVudENvbnRleHQsXG4gIHdhcm5BYm91dFRvb0hpZ2hWb2x1bWUsXG4gIEF1ZGlvRm9yUHJldmlldyxcbiAgT0JKRUNURklUX0NPTlRBSU5fQ0xBU1NfTkFNRSxcbiAgSW5uZXJPZmZ0aHJlYWRWaWRlbyxcbiAgdXNlQmFzaWNNZWRpYUluVGltZWxpbmUsXG4gIGdldElucHV0UHJvcHNPdmVycmlkZSxcbiAgc2V0SW5wdXRQcm9wc092ZXJyaWRlLFxuICB1c2VWaWRlb0VuYWJsZWQsXG4gIHVzZUF1ZGlvRW5hYmxlZCxcbiAgdXNlSXNQbGF5ZXJCdWZmZXJpbmcsXG4gIFRpbWVsaW5lUG9zaXRpb246IGV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUsXG4gIERlbGF5UmVuZGVyQ29udGV4dFR5cGUsXG4gIFRpbWVsaW5lQ29udGV4dCxcbiAgUmVuZGVyQXNzZXRNYW5hZ2VyUHJvdmlkZXJcbn07XG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICByZXR1cm4gXCJcXFxcKFxcXFxzKihcIiArIGFyZ3Muam9pbihcIilcXFxccyosXFxcXHMqKFwiKSArIFwiKVxcXFxzKlxcXFwpXCI7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVycygpIHtcbiAgY29uc3QgY2FjaGVkTWF0Y2hlcnMgPSB7XG4gICAgcmdiOiB1bmRlZmluZWQsXG4gICAgcmdiYTogdW5kZWZpbmVkLFxuICAgIGhzbDogdW5kZWZpbmVkLFxuICAgIGhzbGE6IHVuZGVmaW5lZCxcbiAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgaGV4NDogdW5kZWZpbmVkLFxuICAgIGhleDU6IHVuZGVmaW5lZCxcbiAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgaGV4ODogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYiA9IG5ldyBSZWdFeHAoXCJyZ2JcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKFwicmdiYVwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2wgPSBuZXcgUmVnRXhwKFwiaHNsXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbGEgPSBuZXcgUmVnRXhwKFwiaHNsYVwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcbiAgfVxuICByZXR1cm4gY2FjaGVkTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCArPSAxO1xuICB9XG4gIGlmICh0ID4gMSkge1xuICAgIHQgLT0gMTtcbiAgfVxuICBpZiAodCA8IDEgLyA2KSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIH1cbiAgaWYgKHQgPCAxIC8gMikge1xuICAgIHJldHVybiBxO1xuICB9XG4gIGlmICh0IDwgMiAvIDMpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICBjb25zdCByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgY29uc3QgYjIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHIgKiAyNTUpIDw8IDI0IHwgTWF0aC5yb3VuZChnICogMjU1KSA8PCAxNiB8IE1hdGgucm91bmQoYjIgKiAyNTUpIDw8IDg7XG59XG5mdW5jdGlvbiBwYXJzZTI1NShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAyNTUpIHtcbiAgICByZXR1cm4gMjU1O1xuICB9XG4gIHJldHVybiBpbnQ7XG59XG5mdW5jdGlvbiBwYXJzZTM2MChzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIChpbnQgJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwO1xufVxuZnVuY3Rpb24gcGFyc2UxKHN0cikge1xuICBjb25zdCBudW0gPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAobnVtIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChudW0gPiAxKSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAyNTUpO1xufVxuZnVuY3Rpb24gcGFyc2VQZXJjZW50YWdlKHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAxMDApIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gaW50IC8gMTAwO1xufVxudmFyIGNvbG9yTmFtZXMgPSB7XG4gIHRyYW5zcGFyZW50OiAwLFxuICBhbGljZWJsdWU6IDQwNDI4NTAzMDMsXG4gIGFudGlxdWV3aGl0ZTogNDIwOTc2MDI1NSxcbiAgYXF1YTogMTY3NzcyMTUsXG4gIGFxdWFtYXJpbmU6IDIxNDc0NzI2MzksXG4gIGF6dXJlOiA0MDQzMzA5MDU1LFxuICBiZWlnZTogNDEyNjUzMDgxNSxcbiAgYmlzcXVlOiA0MjkzMTgyNzE5LFxuICBibGFjazogMjU1LFxuICBibGFuY2hlZGFsbW9uZDogNDI5MzY0Mzc3NSxcbiAgYmx1ZTogNjU1MzUsXG4gIGJsdWV2aW9sZXQ6IDIzMTgxMzE5NjcsXG4gIGJyb3duOiAyNzcxMDA0MTU5LFxuICBidXJseXdvb2Q6IDM3MzY2MzUzOTEsXG4gIGJ1cm50c2llbm5hOiAzOTM0MTUwMTQzLFxuICBjYWRldGJsdWU6IDE2MDQyMzE0MjMsXG4gIGNoYXJ0cmV1c2U6IDIxNDc0MTgzNjcsXG4gIGNob2NvbGF0ZTogMzUzMDEwNDU3NSxcbiAgY29yYWw6IDQyODY1MzM4ODcsXG4gIGNvcm5mbG93ZXJibHVlOiAxNjg3NTQ3MzkxLFxuICBjb3Juc2lsazogNDI5NDQ5OTU4MyxcbiAgY3JpbXNvbjogMzY5MjMxMzg1NSxcbiAgY3lhbjogMTY3NzcyMTUsXG4gIGRhcmtibHVlOiAzNTgzOSxcbiAgZGFya2N5YW46IDkxNDUzNDMsXG4gIGRhcmtnb2xkZW5yb2Q6IDMwOTU3OTI2MzksXG4gIGRhcmtncmF5OiAyODQ2NDY4NjA3LFxuICBkYXJrZ3JlZW46IDY1NTM4NTUsXG4gIGRhcmtncmV5OiAyODQ2NDY4NjA3LFxuICBkYXJra2hha2k6IDMxODI5MTQ1NTksXG4gIGRhcmttYWdlbnRhOiAyMzMyMDY4ODYzLFxuICBkYXJrb2xpdmVncmVlbjogMTQzMzA4Nzk5OSxcbiAgZGFya29yYW5nZTogNDI4NzM2NTM3NSxcbiAgZGFya29yY2hpZDogMjU3MDI0MzMyNyxcbiAgZGFya3JlZDogMjMzMjAzMzI3OSxcbiAgZGFya3NhbG1vbjogMzkxODk1MzIxNSxcbiAgZGFya3NlYWdyZWVuOiAyNDExNDk5NTE5LFxuICBkYXJrc2xhdGVibHVlOiAxMjExOTkzMDg3LFxuICBkYXJrc2xhdGVncmF5OiA3OTM3MjY5NzUsXG4gIGRhcmtzbGF0ZWdyZXk6IDc5MzcyNjk3NSxcbiAgZGFya3R1cnF1b2lzZTogMTM1NTQxNzUsXG4gIGRhcmt2aW9sZXQ6IDI0ODMwODIyMzksXG4gIGRlZXBwaW5rOiA0Mjc5NTM4Njg3LFxuICBkZWVwc2t5Ymx1ZTogMTI1ODI5MTEsXG4gIGRpbWdyYXk6IDE3Njg1MTYwOTUsXG4gIGRpbWdyZXk6IDE3Njg1MTYwOTUsXG4gIGRvZGdlcmJsdWU6IDUxMjgxOTE5OSxcbiAgZmlyZWJyaWNrOiAyOTg4NTgxNjMxLFxuICBmbG9yYWx3aGl0ZTogNDI5NDYzNTc3NSxcbiAgZm9yZXN0Z3JlZW46IDU3OTU0MzgwNyxcbiAgZnVjaHNpYTogNDI3ODI1NTYxNSxcbiAgZ2FpbnNib3JvOiAzNzA1NDYyMDE1LFxuICBnaG9zdHdoaXRlOiA0MTc3MDY4MDMxLFxuICBnb2xkOiA0MjkyMjgwNTc1LFxuICBnb2xkZW5yb2Q6IDM2NjgyNTQ5NzUsXG4gIGdyYXk6IDIxNTU5MDUyNzksXG4gIGdyZWVuOiA4Mzg4ODYzLFxuICBncmVlbnllbGxvdzogMjkxOTE4MjMzNSxcbiAgZ3JleTogMjE1NTkwNTI3OSxcbiAgaG9uZXlkZXc6IDQwNDMzMDUyMTUsXG4gIGhvdHBpbms6IDQyODUxMTc2OTUsXG4gIGluZGlhbnJlZDogMzQ0NTM4MjM5OSxcbiAgaW5kaWdvOiAxMjU4MzI0NzM1LFxuICBpdm9yeTogNDI5NDk2MzQ1NSxcbiAga2hha2k6IDQwNDE2NDEyMTUsXG4gIGxhdmVuZGVyOiAzODczODk3MjE1LFxuICBsYXZlbmRlcmJsdXNoOiA0MjkzOTgxNjk1LFxuICBsYXduZ3JlZW46IDIwOTY4OTAxMTEsXG4gIGxlbW9uY2hpZmZvbjogNDI5NDYyNjgxNSxcbiAgbGlnaHRibHVlOiAyOTE2NjczMjc5LFxuICBsaWdodGNvcmFsOiA0MDM0OTUzNDcxLFxuICBsaWdodGN5YW46IDM3NzQ4NzM1OTksXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiA0MjEwNzQyMDE1LFxuICBsaWdodGdyYXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0Z3JlZW46IDI0MzE1NTM3OTEsXG4gIGxpZ2h0Z3JleTogMzU1Mzg3NDk0MyxcbiAgbGlnaHRwaW5rOiA0MjkwMTY3Mjk1LFxuICBsaWdodHNhbG1vbjogNDI4ODcwNzMyNyxcbiAgbGlnaHRzZWFncmVlbjogNTQ4NTgwMDk1LFxuICBsaWdodHNreWJsdWU6IDIyNzg0ODg4MzEsXG4gIGxpZ2h0c2xhdGVncmF5OiAyMDA1NDQxMDIzLFxuICBsaWdodHNsYXRlZ3JleTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzdGVlbGJsdWU6IDI5NjU2OTIxNTksXG4gIGxpZ2h0eWVsbG93OiA0Mjk0OTU5MzU5LFxuICBsaW1lOiAxNjcxMTkzNSxcbiAgbGltZWdyZWVuOiA4NTIzMDg3MzUsXG4gIGxpbmVuOiA0MjEwMDkxNzc1LFxuICBtYWdlbnRhOiA0Mjc4MjU1NjE1LFxuICBtYXJvb246IDIxNDc0ODM5MDMsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDE3MjQ3NTQ2ODcsXG4gIG1lZGl1bWJsdWU6IDUyNzM1LFxuICBtZWRpdW1vcmNoaWQ6IDMxMjYxODcwMDcsXG4gIG1lZGl1bXB1cnBsZTogMjQ3MzY0NzEwMyxcbiAgbWVkaXVtc2VhZ3JlZW46IDEwMTgzOTMwODcsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMjA3MDQ3NDQ5NSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDE2NDIzNjc5LFxuICBtZWRpdW10dXJxdW9pc2U6IDEyMjE3MDkwNTUsXG4gIG1lZGl1bXZpb2xldHJlZDogMzM0MDA3NjU0MyxcbiAgbWlkbmlnaHRibHVlOiA0MjEwOTc3MjcsXG4gIG1pbnRjcmVhbTogNDEyNzE5Mzg1NSxcbiAgbWlzdHlyb3NlOiA0MjkzMTkwMTQzLFxuICBtb2NjYXNpbjogNDI5MzE3ODg3OSxcbiAgbmF2YWpvd2hpdGU6IDQyOTI3ODM2MTUsXG4gIG5hdnk6IDMzMDIzLFxuICBvbGRsYWNlOiA0MjYwNzUxMTAzLFxuICBvbGl2ZTogMjE1NTg3MjUxMSxcbiAgb2xpdmVkcmFiOiAxODA0NDc3NDM5LFxuICBvcmFuZ2U6IDQyODkwMDM3NzUsXG4gIG9yYW5nZXJlZDogNDI4MjcxMjMxOSxcbiAgb3JjaGlkOiAzNjY0ODI4MTU5LFxuICBwYWxlZ29sZGVucm9kOiA0MDA4MjI1NTM1LFxuICBwYWxlZ3JlZW46IDI1NjY2MjU1MzUsXG4gIHBhbGV0dXJxdW9pc2U6IDI5NTE2NzE1NTEsXG4gIHBhbGV2aW9sZXRyZWQ6IDM2ODE1ODgyMjMsXG4gIHBhcGF5YXdoaXA6IDQyOTM5MDc5NjcsXG4gIHBlYWNocHVmZjogNDI5MjUyNDU0MyxcbiAgcGVydTogMzQ0ODA2MTk1MSxcbiAgcGluazogNDI5MDgyNTIxNSxcbiAgcGx1bTogMzcxODMwNzMyNyxcbiAgcG93ZGVyYmx1ZTogMjk2NzUyOTIxNSxcbiAgcHVycGxlOiAyMTQ3NTE2NjcxLFxuICByZWJlY2NhcHVycGxlOiAxNzE0NjU3NzkxLFxuICByZWQ6IDQyNzgxOTAzMzUsXG4gIHJvc3licm93bjogMzE2MzUyNTExOSxcbiAgcm95YWxibHVlOiAxMDk3NDU4MTc1LFxuICBzYWRkbGVicm93bjogMjMzNjU2MDEyNyxcbiAgc2FsbW9uOiA0MjAyNzIyMDQ3LFxuICBzYW5keWJyb3duOiA0MTA0NDEzNDM5LFxuICBzZWFncmVlbjogNzgwODgzOTY3LFxuICBzZWFzaGVsbDogNDI5NDMwNzU4MyxcbiAgc2llbm5hOiAyNjg5NzQwMjg3LFxuICBzaWx2ZXI6IDMyMzM4NTc3OTEsXG4gIHNreWJsdWU6IDIyNzg0ODQ5OTEsXG4gIHNsYXRlYmx1ZTogMTc4NDMzNTg3MSxcbiAgc2xhdGVncmF5OiAxODg3NDczOTE5LFxuICBzbGF0ZWdyZXk6IDE4ODc0NzM5MTksXG4gIHNub3c6IDQyOTQ2MzgzMzUsXG4gIHNwcmluZ2dyZWVuOiAxNjc0NDQ0NyxcbiAgc3RlZWxibHVlOiAxMTgyOTcxMTM1LFxuICB0YW46IDM1MzUwNDc5MzUsXG4gIHRlYWw6IDg0MjE2MzEsXG4gIHRoaXN0bGU6IDM2MzY0NTE1ODMsXG4gIHRvbWF0bzogNDI4NDY5NjU3NSxcbiAgdHVycXVvaXNlOiAxMDg4NDc1MzkxLFxuICB2aW9sZXQ6IDQwMDE1NTgyNzEsXG4gIHdoZWF0OiA0MTI1MDEyOTkxLFxuICB3aGl0ZTogNDI5NDk2NzI5NSxcbiAgd2hpdGVzbW9rZTogNDEyNjUzNzIxNSxcbiAgeWVsbG93OiA0Mjk0OTAyMDE1LFxuICB5ZWxsb3dncmVlbjogMjU5NzEzOTE5OVxufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMoKTtcbiAgbGV0IG1hdGNoO1xuICBpZiAobWF0Y2hlcnMuaGV4Nikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbG9yTmFtZXNbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JOYW1lc1tjb2xvcl07XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5yZ2JhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4Mykge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg4KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4NCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgbWF0Y2hbNF0gKyBtYXRjaFs0XSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY29sb3Igc3RyaW5nICR7Y29sb3J9IHByb3ZpZGVkYCk7XG59XG52YXIgb3BhY2l0eSA9IChjMikgPT4ge1xuICByZXR1cm4gKGMyID4+IDI0ICYgMjU1KSAvIDI1NTtcbn07XG52YXIgcmVkID0gKGMyKSA9PiB7XG4gIHJldHVybiBjMiA+PiAxNiAmIDI1NTtcbn07XG52YXIgZ3JlZW4gPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyID4+IDggJiAyNTU7XG59O1xudmFyIGJsdWUgPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyICYgMjU1O1xufTtcbnZhciByZ2JhQ29sb3IgPSAociwgZywgYjIsIGFscGhhKSA9PiB7XG4gIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2IyfSwgJHthbHBoYX0pYDtcbn07XG5mdW5jdGlvbiBwcm9jZXNzQ29sb3IoY29sb3IpIHtcbiAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICByZXR1cm4gKG5vcm1hbGl6ZWRDb2xvciA8PCAyNCB8IG5vcm1hbGl6ZWRDb2xvciA+Pj4gOCkgPj4+IDA7XG59XG52YXIgaW50ZXJwb2xhdGVDb2xvcnNSR0IgPSAodmFsdWUsIGlucHV0UmFuZ2UsIGNvbG9ycykgPT4ge1xuICBjb25zdCBbciwgZywgYjIsIGEyXSA9IFtyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5XS5tYXAoKGYpID0+IHtcbiAgICBjb25zdCB1bnJvdW5kZWQgPSBpbnRlcnBvbGF0ZSh2YWx1ZSwgaW5wdXRSYW5nZSwgY29sb3JzLm1hcCgoYzIpID0+IGYoYzIpKSwge1xuICAgICAgZXh0cmFwb2xhdGVMZWZ0OiBcImNsYW1wXCIsXG4gICAgICBleHRyYXBvbGF0ZVJpZ2h0OiBcImNsYW1wXCJcbiAgICB9KTtcbiAgICBpZiAoZiA9PT0gb3BhY2l0eSkge1xuICAgICAgcmV0dXJuIE51bWJlcih1bnJvdW5kZWQudG9GaXhlZCgzKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKHVucm91bmRlZCk7XG4gIH0pO1xuICByZXR1cm4gcmdiYUNvbG9yKHIsIGcsIGIyLCBhMik7XG59O1xudmFyIGludGVycG9sYXRlQ29sb3JzID0gKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImlucHV0IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXRSYW5nZSAoXCIgKyBpbnB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWRPdXRwdXRSYW5nZSA9IG91dHB1dFJhbmdlLm1hcCgoYzIpID0+IHByb2Nlc3NDb2xvcihjMikpO1xuICByZXR1cm4gaW50ZXJwb2xhdGVDb2xvcnNSR0IoaW5wdXQsIGlucHV0UmFuZ2UsIHByb2Nlc3NlZE91dHB1dFJhbmdlKTtcbn07XG4vLyBzcmMvdmFsaWRhdGUtZnJhbWUudHNcbnZhciB2YWxpZGF0ZUZyYW1lID0gKHtcbiAgYWxsb3dGbG9hdHMsXG4gIGR1cmF0aW9uSW5GcmFtZXMsXG4gIGZyYW1lXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgZnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBtaXNzaW5nIGZvciBwYXJhbWV0ZXIgXCJmcmFtZVwiYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcmFtZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IHBhc3NlZCBmb3IgXCJmcmFtZVwiIGlzIG5vdCBhIG51bWJlcjogJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRnJhbWUgJHtmcmFtZX0gaXMgbm90IGZpbml0ZWApO1xuICB9XG4gIGlmIChmcmFtZSAlIDEgIT09IDAgJiYgIWFsbG93RmxvYXRzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEFyZ3VtZW50IGZvciBmcmFtZSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoZnJhbWUgPCAwICYmIGZyYW1lIDwgLWR1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBsb3dlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHstZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZnJhbWUgPiBkdXJhdGlvbkluRnJhbWVzIC0gMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGhpZ2hlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHtkdXJhdGlvbkluRnJhbWVzIC0gMX1gKTtcbiAgfVxufTtcbi8vIHNyYy9zZXJpZXMvaW5kZXgudHN4XG5pbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMTAsIHVzZU1lbW8gYXMgdXNlTWVtbzMxIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9zZXJpZXMvZmxhdHRlbi1jaGlsZHJlbi50c3hcbmltcG9ydCBSZWFjdDMzIGZyb20gXCJyZWFjdFwiO1xudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IChjaGlsZHJlbikgPT4ge1xuICBjb25zdCBjaGlsZHJlbkFycmF5ID0gUmVhY3QzMy5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuQXJyYXkucmVkdWNlKChmbGF0Q2hpbGRyZW4sIGNoaWxkKSA9PiB7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IFJlYWN0MzMuRnJhZ21lbnQpIHtcbiAgICAgIHJldHVybiBmbGF0Q2hpbGRyZW4uY29uY2F0KGZsYXR0ZW5DaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBmbGF0Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgcmV0dXJuIGZsYXRDaGlsZHJlbjtcbiAgfSwgW10pO1xufTtcblxuLy8gc3JjL3Nlcmllcy9pcy1pbnNpZGUtc2VyaWVzLnRzeFxuaW1wb3J0IFJlYWN0MzQsIHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MjEgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gzMyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIElzSW5zaWRlU2VyaWVzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQyMShmYWxzZSk7XG52YXIgSXNJbnNpZGVTZXJpZXNDb250YWluZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzMoSXNJbnNpZGVTZXJpZXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHRydWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIElzTm90SW5zaWRlU2VyaWVzUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzMoSXNJbnNpZGVTZXJpZXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VSZXF1aXJlVG9CZUluc2lkZVNlcmllcyA9ICgpID0+IHtcbiAgY29uc3QgaXNJbnNpZGVTZXJpZXMgPSBSZWFjdDM0LnVzZUNvbnRleHQoSXNJbnNpZGVTZXJpZXNDb250ZXh0KTtcbiAgaWYgKCFpc0luc2lkZVNlcmllcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgY29tcG9uZW50IG11c3QgYmUgaW5zaWRlIGEgPFNlcmllcyAvPiBjb21wb25lbnQuXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvc2VyaWVzL2luZGV4LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDM0IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU2VyaWVzU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAoeyBjaGlsZHJlbiB9LCBfcmVmKSA9PiB7XG4gIHVzZVJlcXVpcmVUb0JlSW5zaWRlU2VyaWVzKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzQoSXNOb3RJbnNpZGVTZXJpZXNQcm92aWRlciwge1xuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciBTZXJpZXNTZXF1ZW5jZSA9IGZvcndhcmRSZWYxMChTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG52YXIgU2VyaWVzID0gKHByb3BzMikgPT4ge1xuICBjb25zdCBjaGlsZHJlblZhbHVlID0gdXNlTWVtbzMxKCgpID0+IHtcbiAgICBsZXQgc3RhcnRGcmFtZSA9IDA7XG4gICAgY29uc3QgZmxhdHRlbmVkQ2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMyLmNoaWxkcmVuKTtcbiAgICByZXR1cm4gQ2hpbGRyZW4ubWFwKGZsYXR0ZW5lZENoaWxkcmVuLCAoY2hpbGQsIGkpID0+IHtcbiAgICAgIGNvbnN0IGNhc3RlZENoaWxkID0gY2hpbGQ7XG4gICAgICBpZiAodHlwZW9mIGNhc3RlZENoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChjYXN0ZWRDaGlsZC50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgPFNlcmllcyAvPiBjb21wb25lbnQgb25seSBhY2NlcHRzIGEgbGlzdCBvZiA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudHMgYXMgaXRzIGNoaWxkcmVuLCBidXQgeW91IHBhc3NlZCBhIHN0cmluZyBcIiR7Y2FzdGVkQ2hpbGR9XCJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXN0ZWRDaGlsZC50eXBlICE9PSBTZXJpZXNTZXF1ZW5jZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgPFNlcmllcyAvPiBjb21wb25lbnQgb25seSBhY2NlcHRzIGEgbGlzdCBvZiA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudHMgYXMgaXRzIGNoaWxkcmVuLCBidXQgZ290ICR7Y2FzdGVkQ2hpbGR9IGluc3RlYWRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlYnVnSW5mbyA9IGBpbmRleCA9ICR7aX0sIGR1cmF0aW9uID0gJHtjYXN0ZWRDaGlsZC5wcm9wcy5kdXJhdGlvbkluRnJhbWVzfWA7XG4gICAgICBpZiAoIWNhc3RlZENoaWxkPy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIDxTZXJpZXMuU2VxdWVuY2UgLz4gY29tcG9uZW50ICgke2RlYnVnSW5mb30pIHdhcyBkZXRlY3RlZCB0byBub3QgaGF2ZSBhbnkgY2hpbGRyZW4uIERlbGV0ZSBpdCB0byBmaXggdGhpcyBlcnJvci5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGR1cmF0aW9uSW5GcmFtZXNQcm9wID0gY2FzdGVkQ2hpbGQucHJvcHMuZHVyYXRpb25JbkZyYW1lcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgY2hpbGRyZW46IF9jaGlsZHJlbixcbiAgICAgICAgZnJvbSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgLi4ucGFzc2VkUHJvcHNcbiAgICAgIH0gPSBjYXN0ZWRDaGlsZC5wcm9wcztcbiAgICAgIGlmIChpICE9PSBmbGF0dGVuZWRDaGlsZHJlbi5sZW5ndGggLSAxIHx8IGR1cmF0aW9uSW5GcmFtZXNQcm9wICE9PSBJbmZpbml0eSkge1xuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoZHVyYXRpb25JbkZyYW1lc1Byb3AsIHtcbiAgICAgICAgICBjb21wb25lbnQ6IGBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gY29tcG9uZW50YCxcbiAgICAgICAgICBhbGxvd0Zsb2F0czogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNldCA9IGNhc3RlZENoaWxkLnByb3BzLm9mZnNldCA/PyAwO1xuICAgICAgaWYgKE51bWJlci5pc05hTihvZmZzZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm9mZnNldFwiIHByb3BlcnR5IG9mIGEgPFNlcmllcy5TZXF1ZW5jZSAvPiBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBnb3QgTmFOICgke2RlYnVnSW5mb30pLmApO1xuICAgICAgfVxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtvZmZzZXR9ICgke2RlYnVnSW5mb30pLmApO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwib2Zmc2V0XCIgcHJvcGVydHkgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7b2Zmc2V0fSAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRTdGFydEZyYW1lID0gc3RhcnRGcmFtZSArIG9mZnNldDtcbiAgICAgIHN0YXJ0RnJhbWUgKz0gZHVyYXRpb25JbkZyYW1lc1Byb3AgKyBvZmZzZXQ7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDM0KFNlcXVlbmNlLCB7XG4gICAgICAgIG5hbWU6IG5hbWUgfHwgXCI8U2VyaWVzLlNlcXVlbmNlPlwiLFxuICAgICAgICBmcm9tOiBjdXJyZW50U3RhcnRGcmFtZSxcbiAgICAgICAgZHVyYXRpb25JbkZyYW1lczogZHVyYXRpb25JbkZyYW1lc1Byb3AsXG4gICAgICAgIC4uLnBhc3NlZFByb3BzLFxuICAgICAgICByZWY6IGNhc3RlZENoaWxkLnJlZixcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW3Byb3BzMi5jaGlsZHJlbl0pO1xuICBpZiAoRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDM0KElzSW5zaWRlU2VyaWVzQ29udGFpbmVyLCB7XG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDM0KFNlcXVlbmNlLCB7XG4gICAgICAgIC4uLnByb3BzMixcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuVmFsdWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNChJc0luc2lkZVNlcmllc0NvbnRhaW5lciwge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlblZhbHVlXG4gIH0pO1xufTtcblNlcmllcy5TZXF1ZW5jZSA9IFNlcmllc1NlcXVlbmNlO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhTZXJpZXNTZXF1ZW5jZSk7XG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0aW9uLXNwcmluZy1kdXJhdGlvbi50c1xudmFyIHZhbGlkYXRlU3ByaW5nRHVyYXRpb24gPSAoZHVyKSA9PiB7XG4gIGlmICh0eXBlb2YgZHVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgbXVzdCBiZSBhIFwibnVtYmVyXCIgYnV0IGlzIFwiJHt0eXBlb2YgZHVyfVwiYCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihkdXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgaXMgTmFOLCB3aGljaCBpdCBtdXN0IG5vdCBiZScpO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICcgKyBkdXIpO1xuICB9XG4gIGlmIChkdXIgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBpcyAnICsgZHVyKTtcbiAgfVxufTtcblxuLy8gc3JjL3NwcmluZy9zcHJpbmctdXRpbHMudHNcbnZhciBkZWZhdWx0U3ByaW5nQ29uZmlnID0ge1xuICBkYW1waW5nOiAxMCxcbiAgbWFzczogMSxcbiAgc3RpZmZuZXNzOiAxMDAsXG4gIG92ZXJzaG9vdENsYW1waW5nOiBmYWxzZVxufTtcbnZhciBhZHZhbmNlQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGFkdmFuY2Uoe1xuICBhbmltYXRpb24sXG4gIG5vdyxcbiAgY29uZmlnXG59KSB7XG4gIGNvbnN0IHsgdG9WYWx1ZSwgbGFzdFRpbWVzdGFtcCwgY3VycmVudCwgdmVsb2NpdHkgfSA9IGFuaW1hdGlvbjtcbiAgY29uc3QgZGVsdGFUaW1lID0gTWF0aC5taW4obm93IC0gbGFzdFRpbWVzdGFtcCwgNjQpO1xuICBpZiAoY29uZmlnLmRhbXBpbmcgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNwcmluZyBkYW1waW5nIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAsIG90aGVyd2lzZSB0aGUgc3ByaW5nKCkgYW5pbWF0aW9uIHdpbGwgbmV2ZXIgZW5kLCBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3AuXCIpO1xuICB9XG4gIGNvbnN0IGMyID0gY29uZmlnLmRhbXBpbmc7XG4gIGNvbnN0IG0gPSBjb25maWcubWFzcztcbiAgY29uc3QgayA9IGNvbmZpZy5zdGlmZm5lc3M7XG4gIGNvbnN0IGNhY2hlS2V5ID0gW1xuICAgIHRvVmFsdWUsXG4gICAgbGFzdFRpbWVzdGFtcCxcbiAgICBjdXJyZW50LFxuICAgIHZlbG9jaXR5LFxuICAgIGMyLFxuICAgIG0sXG4gICAgayxcbiAgICBub3dcbiAgXS5qb2luKFwiLVwiKTtcbiAgaWYgKGFkdmFuY2VDYWNoZVtjYWNoZUtleV0pIHtcbiAgICByZXR1cm4gYWR2YW5jZUNhY2hlW2NhY2hlS2V5XTtcbiAgfVxuICBjb25zdCB2MCA9IC12ZWxvY2l0eTtcbiAgY29uc3QgeDAgPSB0b1ZhbHVlIC0gY3VycmVudDtcbiAgY29uc3QgemV0YSA9IGMyIC8gKDIgKiBNYXRoLnNxcnQoayAqIG0pKTtcbiAgY29uc3Qgb21lZ2EwID0gTWF0aC5zcXJ0KGsgLyBtKTtcbiAgY29uc3Qgb21lZ2ExID0gb21lZ2EwICogTWF0aC5zcXJ0KDEgLSB6ZXRhICoqIDIpO1xuICBjb25zdCB0ID0gZGVsdGFUaW1lIC8gMTAwMDtcbiAgY29uc3Qgc2luMSA9IE1hdGguc2luKG9tZWdhMSAqIHQpO1xuICBjb25zdCBjb3MxID0gTWF0aC5jb3Mob21lZ2ExICogdCk7XG4gIGNvbnN0IHVuZGVyRGFtcGVkRW52ZWxvcGUgPSBNYXRoLmV4cCgtemV0YSAqIG9tZWdhMCAqIHQpO1xuICBjb25zdCB1bmRlckRhbXBlZEZyYWcxID0gdW5kZXJEYW1wZWRFbnZlbG9wZSAqIChzaW4xICogKCh2MCArIHpldGEgKiBvbWVnYTAgKiB4MCkgLyBvbWVnYTEpICsgeDAgKiBjb3MxKTtcbiAgY29uc3QgdW5kZXJEYW1wZWRQb3NpdGlvbiA9IHRvVmFsdWUgLSB1bmRlckRhbXBlZEZyYWcxO1xuICBjb25zdCB1bmRlckRhbXBlZFZlbG9jaXR5ID0gemV0YSAqIG9tZWdhMCAqIHVuZGVyRGFtcGVkRnJhZzEgLSB1bmRlckRhbXBlZEVudmVsb3BlICogKGNvczEgKiAodjAgKyB6ZXRhICogb21lZ2EwICogeDApIC0gb21lZ2ExICogeDAgKiBzaW4xKTtcbiAgY29uc3QgY3JpdGljYWxseURhbXBlZEVudmVsb3BlID0gTWF0aC5leHAoLW9tZWdhMCAqIHQpO1xuICBjb25zdCBjcml0aWNhbGx5RGFtcGVkUG9zaXRpb24gPSB0b1ZhbHVlIC0gY3JpdGljYWxseURhbXBlZEVudmVsb3BlICogKHgwICsgKHYwICsgb21lZ2EwICogeDApICogdCk7XG4gIGNvbnN0IGNyaXRpY2FsbHlEYW1wZWRWZWxvY2l0eSA9IGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSAqICh2MCAqICh0ICogb21lZ2EwIC0gMSkgKyB0ICogeDAgKiBvbWVnYTAgKiBvbWVnYTApO1xuICBjb25zdCBhbmltYXRpb25Ob2RlID0ge1xuICAgIHRvVmFsdWUsXG4gICAgcHJldlBvc2l0aW9uOiBjdXJyZW50LFxuICAgIGxhc3RUaW1lc3RhbXA6IG5vdyxcbiAgICBjdXJyZW50OiB6ZXRhIDwgMSA/IHVuZGVyRGFtcGVkUG9zaXRpb24gOiBjcml0aWNhbGx5RGFtcGVkUG9zaXRpb24sXG4gICAgdmVsb2NpdHk6IHpldGEgPCAxID8gdW5kZXJEYW1wZWRWZWxvY2l0eSA6IGNyaXRpY2FsbHlEYW1wZWRWZWxvY2l0eVxuICB9O1xuICBhZHZhbmNlQ2FjaGVbY2FjaGVLZXldID0gYW5pbWF0aW9uTm9kZTtcbiAgcmV0dXJuIGFuaW1hdGlvbk5vZGU7XG59XG52YXIgY2FsY3VsYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICBmcmFtZSxcbiAgZnBzLFxuICBjb25maWcgPSB7fVxufSkge1xuICBjb25zdCBmcm9tID0gMDtcbiAgY29uc3QgdG8gPSAxO1xuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICBmcmFtZSxcbiAgICBmcHMsXG4gICAgY29uZmlnLmRhbXBpbmcsXG4gICAgY29uZmlnLm1hc3MsXG4gICAgY29uZmlnLm92ZXJzaG9vdENsYW1waW5nLFxuICAgIGNvbmZpZy5zdGlmZm5lc3NcbiAgXS5qb2luKFwiLVwiKTtcbiAgaWYgKGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldO1xuICB9XG4gIGxldCBhbmltYXRpb24gPSB7XG4gICAgbGFzdFRpbWVzdGFtcDogMCxcbiAgICBjdXJyZW50OiBmcm9tLFxuICAgIHRvVmFsdWU6IHRvLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIHByZXZQb3NpdGlvbjogMFxuICB9O1xuICBjb25zdCBmcmFtZUNsYW1wZWQgPSBNYXRoLm1heCgwLCBmcmFtZSk7XG4gIGNvbnN0IHVuZXZlblJlc3QgPSBmcmFtZUNsYW1wZWQgJSAxO1xuICBmb3IgKGxldCBmID0gMDtmIDw9IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKTsgZisrKSB7XG4gICAgaWYgKGYgPT09IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKSkge1xuICAgICAgZiArPSB1bmV2ZW5SZXN0O1xuICAgIH1cbiAgICBjb25zdCB0aW1lID0gZiAvIGZwcyAqIDEwMDA7XG4gICAgYW5pbWF0aW9uID0gYWR2YW5jZSh7XG4gICAgICBhbmltYXRpb24sXG4gICAgICBub3c6IHRpbWUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4uZGVmYXVsdFNwcmluZ0NvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRpb25DYWNoZVtjYWNoZUtleV0gPSBhbmltYXRpb247XG4gIHJldHVybiBhbmltYXRpb247XG59XG5cbi8vIHNyYy9zcHJpbmcvbWVhc3VyZS1zcHJpbmcudHNcbnZhciBjYWNoZSA9IG5ldyBNYXA7XG5mdW5jdGlvbiBtZWFzdXJlU3ByaW5nKHtcbiAgZnBzLFxuICBjb25maWcgPSB7fSxcbiAgdGhyZXNob2xkID0gMC4wMDVcbn0pIHtcbiAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0aHJlc2hvbGQgbXVzdCBiZSBhIG51bWJlciwgZ290ICR7dGhyZXNob2xkfSBvZiB0eXBlICR7dHlwZW9mIHRocmVzaG9sZH1gKTtcbiAgfVxuICBpZiAodGhyZXNob2xkID09PSAwKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIGlmICh0aHJlc2hvbGQgPT09IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNOYU4odGhyZXNob2xkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaHJlc2hvbGQgaXMgTmFOXCIpO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHRocmVzaG9sZCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIG5vdCBmaW5pdGVcIik7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIGJlbG93IDBcIik7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBbXG4gICAgZnBzLFxuICAgIGNvbmZpZy5kYW1waW5nLFxuICAgIGNvbmZpZy5tYXNzLFxuICAgIGNvbmZpZy5vdmVyc2hvb3RDbGFtcGluZyxcbiAgICBjb25maWcuc3RpZmZuZXNzLFxuICAgIHRocmVzaG9sZFxuICBdLmpvaW4oXCItXCIpO1xuICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICB9XG4gIHZhbGlkYXRlRnBzKGZwcywgXCJ0byB0aGUgbWVhc3VyZVNwcmluZygpIGZ1bmN0aW9uXCIsIGZhbHNlKTtcbiAgbGV0IGZyYW1lID0gMDtcbiAgbGV0IGZpbmlzaGVkRnJhbWUgPSAwO1xuICBjb25zdCBjYWxjID0gKCkgPT4ge1xuICAgIHJldHVybiBzcHJpbmdDYWxjdWxhdGlvbih7XG4gICAgICBmcHMsXG4gICAgICBmcmFtZSxcbiAgICAgIGNvbmZpZ1xuICAgIH0pO1xuICB9O1xuICBsZXQgYW5pbWF0aW9uID0gY2FsYygpO1xuICBjb25zdCBjYWxjRGlmZmVyZW5jZSA9ICgpID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYW5pbWF0aW9uLmN1cnJlbnQgLSBhbmltYXRpb24udG9WYWx1ZSk7XG4gIH07XG4gIGxldCBkaWZmZXJlbmNlID0gY2FsY0RpZmZlcmVuY2UoKTtcbiAgd2hpbGUgKGRpZmZlcmVuY2UgPj0gdGhyZXNob2xkKSB7XG4gICAgZnJhbWUrKztcbiAgICBhbmltYXRpb24gPSBjYWxjKCk7XG4gICAgZGlmZmVyZW5jZSA9IGNhbGNEaWZmZXJlbmNlKCk7XG4gIH1cbiAgZmluaXNoZWRGcmFtZSA9IGZyYW1lO1xuICBmb3IgKGxldCBpID0gMDtpIDwgMjA7IGkrKykge1xuICAgIGZyYW1lKys7XG4gICAgYW5pbWF0aW9uID0gY2FsYygpO1xuICAgIGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICAgIGlmIChkaWZmZXJlbmNlID49IHRocmVzaG9sZCkge1xuICAgICAgaSA9IDA7XG4gICAgICBmaW5pc2hlZEZyYW1lID0gZnJhbWUgKyAxO1xuICAgIH1cbiAgfVxuICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbmlzaGVkRnJhbWUpO1xuICByZXR1cm4gZmluaXNoZWRGcmFtZTtcbn1cblxuLy8gc3JjL3NwcmluZy9pbmRleC50c1xuZnVuY3Rpb24gc3ByaW5nKHtcbiAgZnJhbWU6IHBhc3NlZEZyYW1lLFxuICBmcHMsXG4gIGNvbmZpZyA9IHt9LFxuICBmcm9tID0gMCxcbiAgdG8gPSAxLFxuICBkdXJhdGlvbkluRnJhbWVzOiBwYXNzZWREdXJhdGlvbkluRnJhbWVzLFxuICBkdXJhdGlvblJlc3RUaHJlc2hvbGQsXG4gIGRlbGF5ID0gMCxcbiAgcmV2ZXJzZSA9IGZhbHNlXG59KSB7XG4gIHZhbGlkYXRlU3ByaW5nRHVyYXRpb24ocGFzc2VkRHVyYXRpb25JbkZyYW1lcyk7XG4gIHZhbGlkYXRlRnJhbWUoe1xuICAgIGZyYW1lOiBwYXNzZWRGcmFtZSxcbiAgICBkdXJhdGlvbkluRnJhbWVzOiBJbmZpbml0eSxcbiAgICBhbGxvd0Zsb2F0czogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVGcHMoZnBzLCBcInRvIHNwcmluZygpXCIsIGZhbHNlKTtcbiAgY29uc3QgbmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiA9IHJldmVyc2UgfHwgdHlwZW9mIHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IG5hdHVyYWxEdXJhdGlvbiA9IG5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb24gPyBtZWFzdXJlU3ByaW5nKHtcbiAgICBmcHMsXG4gICAgY29uZmlnLFxuICAgIHRocmVzaG9sZDogZHVyYXRpb25SZXN0VGhyZXNob2xkXG4gIH0pIDogdW5kZWZpbmVkO1xuICBjb25zdCBuYXR1cmFsRHVyYXRpb25HZXR0ZXIgPSBuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uID8ge1xuICAgIGdldDogKCkgPT4gbmF0dXJhbER1cmF0aW9uXG4gIH0gOiB7XG4gICAgZ2V0OiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWQgbm90IGNhbGN1bGF0ZSBuYXR1cmFsIGR1cmF0aW9uLCB0aGlzIGlzIGFuIGVycm9yIHdpdGggUmVtb3Rpb24uIFBsZWFzZSByZXBvcnRcIik7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXZlcnNlUHJvY2Vzc2VkID0gcmV2ZXJzZSA/IChwYXNzZWREdXJhdGlvbkluRnJhbWVzID8/IG5hdHVyYWxEdXJhdGlvbkdldHRlci5nZXQoKSkgLSBwYXNzZWRGcmFtZSA6IHBhc3NlZEZyYW1lO1xuICBjb25zdCBkZWxheVByb2Nlc3NlZCA9IHJldmVyc2VQcm9jZXNzZWQgKyAocmV2ZXJzZSA/IGRlbGF5IDogLWRlbGF5KTtcbiAgY29uc3QgZHVyYXRpb25Qcm9jZXNzZWQgPSBwYXNzZWREdXJhdGlvbkluRnJhbWVzID09PSB1bmRlZmluZWQgPyBkZWxheVByb2Nlc3NlZCA6IGRlbGF5UHJvY2Vzc2VkIC8gKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgLyBuYXR1cmFsRHVyYXRpb25HZXR0ZXIuZ2V0KCkpO1xuICBpZiAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyAmJiBkZWxheVByb2Nlc3NlZCA+IHBhc3NlZER1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgY29uc3Qgc3ByID0gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICAgIGZwcyxcbiAgICBmcmFtZTogZHVyYXRpb25Qcm9jZXNzZWQsXG4gICAgY29uZmlnXG4gIH0pO1xuICBjb25zdCBpbm5lciA9IGNvbmZpZy5vdmVyc2hvb3RDbGFtcGluZyA/IHRvID49IGZyb20gPyBNYXRoLm1pbihzcHIuY3VycmVudCwgdG8pIDogTWF0aC5tYXgoc3ByLmN1cnJlbnQsIHRvKSA6IHNwci5jdXJyZW50O1xuICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBmcm9tID09PSAwICYmIHRvID09PSAxID8gaW5uZXIgOiBpbnRlcnBvbGF0ZShpbm5lciwgWzAsIDFdLCBbZnJvbSwgdG9dKTtcbiAgcmV0dXJuIGludGVycG9sYXRlZDtcbn1cbi8vIHNyYy9zdGF0aWMtZmlsZS50c1xudmFyIHByb2JsZW1hdGljQ2hhcmFjdGVycyA9IHtcbiAgXCIlM0FcIjogXCI6XCIsXG4gIFwiJTJGXCI6IFwiL1wiLFxuICBcIiUzRlwiOiBcIj9cIixcbiAgXCIlMjNcIjogXCIjXCIsXG4gIFwiJTVCXCI6IFwiW1wiLFxuICBcIiU1RFwiOiBcIl1cIixcbiAgXCIlNDBcIjogXCJAXCIsXG4gIFwiJTIxXCI6IFwiIVwiLFxuICBcIiUyNFwiOiBcIiRcIixcbiAgXCIlMjZcIjogXCImXCIsXG4gIFwiJTI3XCI6IFwiJ1wiLFxuICBcIiUyOFwiOiBcIihcIixcbiAgXCIlMjlcIjogXCIpXCIsXG4gIFwiJTJBXCI6IFwiKlwiLFxuICBcIiUyQlwiOiBcIitcIixcbiAgXCIlMkNcIjogXCIsXCIsXG4gIFwiJTNCXCI6IFwiO1wiXG59O1xudmFyIGRpZFdhcm4yID0ge307XG52YXIgd2Fybk9uY2UzID0gKG1lc3NhZ2UpID0+IHtcbiAgaWYgKGRpZFdhcm4yW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgZGlkV2FybjJbbWVzc2FnZV0gPSB0cnVlO1xufTtcbnZhciBpbmNsdWRlc0hleE9mVW5zYWZlQ2hhciA9IChwYXRoKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHByb2JsZW1hdGljQ2hhcmFjdGVycykpIHtcbiAgICBpZiAocGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICByZXR1cm4geyBjb250YWluc0hleDogdHJ1ZSwgaGV4Q29kZToga2V5IH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGNvbnRhaW5zSGV4OiBmYWxzZSB9O1xufTtcbnZhciB0cmltTGVhZGluZ1NsYXNoID0gKHBhdGgpID0+IHtcbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gdHJpbUxlYWRpbmdTbGFzaChwYXRoLnN1YnN0cmluZygxKSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xudmFyIGlubmVyID0gKHBhdGgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdmFsdWUgXCIke3BhdGh9XCIgaXMgYWxyZWFkeSBwcmVmaXhlZCB3aXRoIHRoZSBzdGF0aWMgYmFzZSAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCBzdGF0aWNGaWxlKCkgb24gaXQuYCk7XG4gICAgfVxuICAgIHJldHVybiBgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0vJHt0cmltTGVhZGluZ1NsYXNoKHBhdGgpfWA7XG4gIH1cbiAgcmV0dXJuIGAvJHt0cmltTGVhZGluZ1NsYXNoKHBhdGgpfWA7XG59O1xudmFyIGVuY29kZUJ5U3BsaXR0aW5nID0gKHBhdGgpID0+IHtcbiAgY29uc3Qgc3BsaXRCeVNsYXNoID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGNvbnN0IGVuY29kZWRBcnJheSA9IHNwbGl0QnlTbGFzaC5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVsZW1lbnQpO1xuICB9KTtcbiAgY29uc3QgbWVyZ2VkID0gZW5jb2RlZEFycmF5LmpvaW4oXCIvXCIpO1xuICByZXR1cm4gbWVyZ2VkO1xufTtcbnZhciBzdGF0aWNGaWxlID0gKHBhdGgpID0+IHtcbiAgaWYgKHBhdGggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibnVsbCB3YXMgcGFzc2VkIHRvIHN0YXRpY0ZpbGUoKVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHBhdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidW5kZWZpbmVkIHdhcyBwYXNzZWQgdG8gc3RhdGljRmlsZSgpXCIpO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVtb3RlIFVSTHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIFVSTCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHN0YXRpY0ZpbGUoKS4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVtb3RlLXVybHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi5cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCByZWxhdGl2ZSBwYXRocyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgbmFtZSBvZiBhIGZpbGUgdGhhdCBpcyBpbnNpZGUgdGhlIHB1YmxpYy8gZm9sZGVyLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIvVXNlcnNcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL2hvbWVcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL3RtcFwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvZXRjXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9vcHRcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL3ZhclwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJDOlwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJEOlwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJFOlwiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IGFic29sdXRlIHBhdGhzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBuYW1lIG9mIGEgZmlsZSB0aGF0IGlzIGluc2lkZSB0aGUgcHVibGljLyBmb2xkZXIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcInB1YmxpYy9cIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBEbyBub3QgaW5jbHVkZSB0aGUgcHVibGljLyBwcmVmaXggd2hlbiB1c2luZyBzdGF0aWNGaWxlKCkgLSBnb3QgXCIke3BhdGh9XCIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gIH1cbiAgY29uc3QgaW5jbHVkZXNIZXggPSBpbmNsdWRlc0hleE9mVW5zYWZlQ2hhcihwYXRoKTtcbiAgaWYgKGluY2x1ZGVzSGV4LmNvbnRhaW5zSGV4KSB7XG4gICAgd2Fybk9uY2UzKGBXQVJOSU5HOiBZb3Ugc2VlbSB0byBwYXNzIGFuIGFscmVhZHkgZW5jb2RlZCBwYXRoIChwYXRoIGNvbnRhaW5zICR7aW5jbHVkZXNIZXguaGV4Q29kZX0pLiBTaW5jZSBSZW1vdGlvbiA0LjAsIHRoZSBlbmNvZGluZyBpcyBkb25lIGJ5IHN0YXRpY0ZpbGUoKSBpdHNlbGYuIFlvdSBtYXkgd2FudCB0byByZW1vdmUgYSBlbmNvZGVVUklDb21wb25lbnQoKSB3cmFwcGluZy5gKTtcbiAgfVxuICBjb25zdCBwcmVwcm9jZXNzZWQgPSBlbmNvZGVCeVNwbGl0dGluZyhwYXRoKTtcbiAgY29uc3QgcHJlcGFyc2VkID0gaW5uZXIocHJlcHJvY2Vzc2VkKTtcbiAgaWYgKCFwcmVwYXJzZWQuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gYC8ke3ByZXBhcnNlZH1gO1xuICB9XG4gIHJldHVybiBwcmVwYXJzZWQ7XG59O1xuLy8gc3JjL1N0aWxsLnRzeFxuaW1wb3J0IFJlYWN0MzYgZnJvbSBcInJlYWN0XCI7XG52YXIgU3RpbGwgPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IG5ld1Byb3BzID0ge1xuICAgIC4uLnByb3BzMixcbiAgICBkdXJhdGlvbkluRnJhbWVzOiAxLFxuICAgIGZwczogMVxuICB9O1xuICByZXR1cm4gUmVhY3QzNi5jcmVhdGVFbGVtZW50KENvbXBvc2l0aW9uLCBuZXdQcm9wcyk7XG59O1xuLy8gc3JjL3ZpZGVvL1ZpZGVvLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMTIsIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTcsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDM1IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclJlbmRlcmluZy50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjExLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzNCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIwLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUxMSxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDExLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8zMixcbiAgdXNlUmVmIGFzIHVzZVJlZjE3XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vc2Vlay11bnRpbC1yaWdodC50c1xudmFyIHJvdW5kVG82Q29tbWFzID0gKG51bSkgPT4ge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAxZTUpIC8gMWU1O1xufTtcbnZhciBzZWVrVG9UaW1lID0gKHtcbiAgZWxlbWVudCxcbiAgZGVzaXJlZFRpbWUsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgaWYgKGlzQXBwcm94aW1hdGVseVRoZVNhbWUoZWxlbWVudC5jdXJyZW50VGltZSwgZGVzaXJlZFRpbWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhaXQ6IFByb21pc2UucmVzb2x2ZShkZXNpcmVkVGltZSksXG4gICAgICBjYW5jZWw6ICgpID0+IHt9XG4gICAgfTtcbiAgfVxuICBzZWVrKHtcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZjogZWxlbWVudCxcbiAgICB0aW1lOiBkZXNpcmVkVGltZSxcbiAgICB3aHk6IFwiU2Vla2luZyBkdXJpbmcgcmVuZGVyaW5nXCIsXG4gICAgbW91bnRUaW1lXG4gIH0pO1xuICBsZXQgY2FuY2VsO1xuICBsZXQgY2FuY2VsU2Vla2VkID0gbnVsbDtcbiAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY2FuY2VsID0gZWxlbWVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChub3csIG1ldGFkYXRhKSA9PiB7XG4gICAgICBjb25zdCBkaXNwbGF5SW4gPSBtZXRhZGF0YS5leHBlY3RlZERpc3BsYXlUaW1lIC0gbm93O1xuICAgICAgaWYgKGRpc3BsYXlJbiA8PSAwKSB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgIH0sIGRpc3BsYXlJbiArIDE1MCk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCB3YWl0Rm9yU2Vla2VkRXZlbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IG9uRG9uZSA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvbkRvbmUsIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBjYW5jZWxTZWVrZWQgPSAoKSA9PiB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgb25Eb25lKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB3YWl0OiBQcm9taXNlLmFsbChbcHJvbSwgd2FpdEZvclNlZWtlZEV2ZW50XSkudGhlbigoW3RpbWVdKSA9PiB0aW1lKSxcbiAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIGNhbmNlbFNlZWtlZD8uKCk7XG4gICAgICBlbGVtZW50LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhjYW5jZWwpO1xuICAgIH1cbiAgfTtcbn07XG52YXIgc2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCA9ICh7XG4gIGVsZW1lbnQsXG4gIGRlc2lyZWRUaW1lLFxuICBmcHMsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgdGhyZXNob2xkID0gMSAvIGZwcyAvIDI7XG4gIGxldCBjdXJyZW50Q2FuY2VsID0gKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfTtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShlbGVtZW50LmR1cmF0aW9uKSAmJiBlbGVtZW50LmN1cnJlbnRUaW1lID49IGVsZW1lbnQuZHVyYXRpb24gJiYgZGVzaXJlZFRpbWUgPj0gZWxlbWVudC5kdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9tOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgIGNhbmNlbDogKCkgPT4ge31cbiAgICB9O1xuICB9XG4gIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmlyc3RTZWVrID0gc2Vla1RvVGltZSh7XG4gICAgICBlbGVtZW50LFxuICAgICAgZGVzaXJlZFRpbWU6IGRlc2lyZWRUaW1lICsgdGhyZXNob2xkLFxuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtb3VudFRpbWVcbiAgICB9KTtcbiAgICBmaXJzdFNlZWsud2FpdC50aGVuKChzZWVrZWRUbykgPT4ge1xuICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGRlc2lyZWRUaW1lIC0gc2Vla2VkVG8pO1xuICAgICAgaWYgKGRpZmZlcmVuY2UgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduID0gZGVzaXJlZFRpbWUgPiBzZWVrZWRUbyA/IDEgOiAtMTtcbiAgICAgIGNvbnN0IG5ld1NlZWsgPSBzZWVrVG9UaW1lKHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgZGVzaXJlZFRpbWU6IHNlZWtlZFRvICsgdGhyZXNob2xkICogc2lnbixcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50Q2FuY2VsID0gbmV3U2Vlay5jYW5jZWw7XG4gICAgICBuZXdTZWVrLndhaXQudGhlbigobmV3VGltZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdEaWZmZXJlbmNlID0gTWF0aC5hYnMoZGVzaXJlZFRpbWUgLSBuZXdUaW1lKTtcbiAgICAgICAgaWYgKHJvdW5kVG82Q29tbWFzKG5ld0RpZmZlcmVuY2UpIDw9IHJvdW5kVG82Q29tbWFzKHRocmVzaG9sZCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoaXJkU2VlayA9IHNlZWtUb1RpbWUoe1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgZGVzaXJlZFRpbWU6IGRlc2lyZWRUaW1lICsgdGhyZXNob2xkLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudENhbmNlbCA9IHRoaXJkU2Vlay5jYW5jZWw7XG4gICAgICAgIHJldHVybiB0aGlyZFNlZWsud2FpdC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3VycmVudENhbmNlbCA9IGZpcnN0U2Vlay5jYW5jZWw7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb20sXG4gICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICBjdXJyZW50Q2FuY2VsKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDM1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24gPSAoe1xuICBvbkVycm9yLFxuICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgcGxheWJhY2tSYXRlLFxuICBvbkR1cmF0aW9uLFxuICB0b25lRnJlcXVlbmN5LFxuICBuYW1lLFxuICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgYXVkaW9TdHJlYW1JbmRleCxcbiAgb25WaWRlb0ZyYW1lLFxuICAuLi5wcm9wczJcbn0sIHJlZikgPT4ge1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHZpZGVvUmVmID0gdXNlUmVmMTcobnVsbCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQzNChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgY29uc3QgeyBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyLCBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDM0KFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IGlkID0gdXNlTWVtbzMyKCgpID0+IGB2aWRlby0ke3JhbmRvbShwcm9wczIuc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9YCwgW1xuICAgIHByb3BzMi5zcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc1xuICBdKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIG1lZGlhVm9sdW1lOiAxXG4gIH0pO1xuICB3YXJuQWJvdXRUb29IaWdoVm9sdW1lKHZvbHVtZSk7XG4gIHVzZUVmZmVjdDIwKCgpID0+IHtcbiAgICBpZiAoIXByb3BzMi5zcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmIChwcm9wczIubXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMyLnNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgdG9uZUZyZXF1ZW5jeTogdG9uZUZyZXF1ZW5jeSA/PyAxLFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKSxcbiAgICAgIGF1ZGlvU3RyZWFtSW5kZXg6IGF1ZGlvU3RyZWFtSW5kZXggPz8gMFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgcHJvcHMyLm11dGVkLFxuICAgIHByb3BzMi5zcmMsXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICBpZCxcbiAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgdm9sdW1lLFxuICAgIGZyYW1lLFxuICAgIGFic29sdXRlRnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgYXVkaW9TdHJlYW1JbmRleFxuICBdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTExKHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB2aWRlb1JlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDIwKCgpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgICAgZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSB8fCAxLFxuICAgICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzXG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlID0gZGVsYXlSZW5kZXIyKGBSZW5kZXJpbmcgPEh0bWw1VmlkZW8gLz4gd2l0aCBzcmM9XCIke3Byb3BzMi5zcmN9XCIgYXQgdGltZSAke2N1cnJlbnRUaW1lfWAsIHtcbiAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyMihoYW5kbGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShjdXJyZW50LmN1cnJlbnRUaW1lLCBjdXJyZW50VGltZSkpIHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkRGF0YUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihoYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgbG9hZGVkRGF0YUhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgbG9hZGVkRGF0YUhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29udGludWVSZW5kZXIyKGhhbmRsZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZWVrMiA9IHNlZWtUb1RpbWVNdWx0aXBsZVVudGlsUmlnaHQoe1xuICAgICAgZWxlbWVudDogY3VycmVudCxcbiAgICAgIGRlc2lyZWRUaW1lOiBjdXJyZW50VGltZSxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzLFxuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtb3VudFRpbWVcbiAgICB9KTtcbiAgICBzZWVrMi5wcm9tLnRoZW4oKCkgPT4ge1xuICAgICAgY29udGludWVSZW5kZXIyKGhhbmRsZSk7XG4gICAgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQ/LmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCBpbiB2aWRlb1wiLCBjdXJyZW50Py5lcnJvcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtwcm9wczIuc3JjfTogQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX0gLSAke2N1cnJlbnQ/LmVycm9yPy5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNlZWsyLmNhbmNlbCgpO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbXG4gICAgdm9sdW1lUHJvcHNGcmFtZSxcbiAgICBwcm9wczIuc3JjLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICB2aWRlb0NvbmZpZy5mcHMsXG4gICAgZnJhbWUsXG4gICAgbWVkaWFTdGFydHNBdCxcbiAgICBvbkVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb2dMZXZlbCxcbiAgICBtb3VudFRpbWUsXG4gICAgY29udGludWVSZW5kZXIyLFxuICAgIGRlbGF5UmVuZGVyMlxuICBdKTtcbiAgY29uc3QgeyBzcmMgfSA9IHByb3BzMjtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0MTEoKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcjIoXCJMb2FkaW5nIDxIdG1sNVZpZGVvPiBkdXJhdGlvbiB3aXRoIHNyYz1cIiArIHNyYywge1xuICAgICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgICAgY29uc3QgZGlkTG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICAgICAgb25EdXJhdGlvbihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICBvbkR1cmF0aW9uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkKTtcbiAgICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgIH0sIFtcbiAgICAgIHNyYyxcbiAgICAgIG9uRHVyYXRpb24sXG4gICAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAgIGNvbnRpbnVlUmVuZGVyMixcbiAgICAgIGRlbGF5UmVuZGVyMlxuICAgIF0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzUoXCJ2aWRlb1wiLCB7XG4gICAgcmVmOiB2aWRlb1JlZixcbiAgICBkaXNhYmxlUmVtb3RlUGxheWJhY2s6IHRydWUsXG4gICAgLi4ucHJvcHMyXG4gIH0pO1xufTtcbnZhciBWaWRlb0ZvclJlbmRlcmluZyA9IGZvcndhcmRSZWYxMShWaWRlb0ZvclJlbmRlcmluZ0ZvcndhcmRGdW5jdGlvbik7XG5cbi8vIHNyYy92aWRlby9WaWRlby50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzNiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFZpZGVvRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzMiwgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEZyb20sXG4gICAgZW5kQXQsXG4gICAgdHJpbUJlZm9yZSxcbiAgICB0cmltQWZ0ZXIsXG4gICAgbmFtZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc3RhY2ssXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSBwcm9wczI7XG4gIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wczI7XG4gIGNvbnN0IHsgZnBzIH0gPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgeyBkdXJhdGlvbnMsIHNldER1cmF0aW9ucyB9ID0gdXNlQ29udGV4dDM1KER1cmF0aW9uc0NvbnRleHQpO1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZWZzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMyLnNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8SHRtbDVWaWRlbz5cXGAgdGFnIHJlcXVpcmVzIGEgc3RyaW5nIGZvciBcXGBzcmNcXGAsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShwcm9wczIuc3JjKX0gaW5zdGVhZC5gKTtcbiAgfVxuICBjb25zdCBwcmVsb2FkZWRTcmMgPSB1c2VQcmVsb2FkKHByb3BzMi5zcmMpO1xuICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2sxNygoc3JjLCBkdXJhdGlvbkluU2Vjb25kcykgPT4ge1xuICAgIHNldER1cmF0aW9ucyh7IHR5cGU6IFwiZ290LWR1cmF0aW9uXCIsIGR1cmF0aW9uSW5TZWNvbmRzLCBzcmMgfSk7XG4gIH0sIFtzZXREdXJhdGlvbnNdKTtcbiAgY29uc3Qgb25WaWRlb0ZyYW1lID0gdXNlQ2FsbGJhY2sxNygoKSA9PiB7fSwgW10pO1xuICBjb25zdCBkdXJhdGlvbkZldGNoZWQgPSBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJlbG9hZGVkU3JjKV0gPz8gZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByb3BzMi5zcmMpXTtcbiAgdmFsaWRhdGVNZWRpYVRyaW1Qcm9wcyh7IHN0YXJ0RnJvbSwgZW5kQXQsIHRyaW1CZWZvcmUsIHRyaW1BZnRlciB9KTtcbiAgY29uc3QgeyB0cmltQmVmb3JlVmFsdWUsIHRyaW1BZnRlclZhbHVlIH0gPSByZXNvbHZlVHJpbVByb3BzKHtcbiAgICBzdGFydEZyb20sXG4gICAgZW5kQXQsXG4gICAgdHJpbUJlZm9yZSxcbiAgICB0cmltQWZ0ZXJcbiAgfSk7XG4gIGlmIChsb29wICYmIGR1cmF0aW9uRmV0Y2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb25GZXRjaGVkKSkge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNihIdG1sNVZpZGVvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gZHVyYXRpb25GZXRjaGVkICogZnBzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzYoTG9vcCwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lczogY2FsY3VsYXRlTWVkaWFEdXJhdGlvbih7XG4gICAgICAgIHRyaW1BZnRlcjogdHJpbUFmdGVyVmFsdWUsXG4gICAgICAgIG1lZGlhRHVyYXRpb25JbkZyYW1lczogbWVkaWFEdXJhdGlvbixcbiAgICAgICAgcGxheWJhY2tSYXRlOiBwcm9wczIucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHRyaW1CZWZvcmU6IHRyaW1CZWZvcmVWYWx1ZVxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzYoSHRtbDVWaWRlbywge1xuICAgICAgICAuLi5wcm9wc090aGVyVGhhbkxvb3AsXG4gICAgICAgIHJlZixcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiB0cnVlXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgdHJpbUJlZm9yZVZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmltQWZ0ZXJWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzYoU2VxdWVuY2UsIHtcbiAgICAgIGxheW91dDogXCJub25lXCIsXG4gICAgICBmcm9tOiAwIC0gKHRyaW1CZWZvcmVWYWx1ZSA/PyAwKSxcbiAgICAgIHNob3dJblRpbWVsaW5lOiBmYWxzZSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IHRyaW1BZnRlclZhbHVlLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzYoSHRtbDVWaWRlbywge1xuICAgICAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgICAgcmVmXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFQcm9wcyh7IHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSwgdm9sdW1lOiBwcm9wczIudm9sdW1lIH0sIFwiSHRtbDVWaWRlb1wiKTtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNihWaWRlb0ZvclJlbmRlcmluZywge1xuICAgICAgb25EdXJhdGlvbixcbiAgICAgIG9uVmlkZW9GcmFtZTogb25WaWRlb0ZyYW1lID8/IG51bGwsXG4gICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgcmVmXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNihWaWRlb0ZvclByZXZpZXcsIHtcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yOiBmYWxzZSxcbiAgICAuLi5vdGhlclByb3BzLFxuICAgIHJlZixcbiAgICBvblZpZGVvRnJhbWU6IG51bGwsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgb25EdXJhdGlvbixcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrOiBzdGFjayA/PyBudWxsLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkID8/IGZhbHNlLFxuICAgIHNob3dJblRpbWVsaW5lOiBzaG93SW5UaW1lbGluZSA/PyB0cnVlLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IHVuZGVmaW5lZFxuICB9KTtcbn07XG52YXIgSHRtbDVWaWRlbyA9IGZvcndhcmRSZWYxMihWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbik7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKEh0bWw1VmlkZW8pO1xudmFyIFZpZGVvID0gSHRtbDVWaWRlbztcbi8vIHNyYy9pbmRleC50c1xuY2hlY2tNdWx0aXBsZVJlbW90aW9uVmVyc2lvbnMoKTtcbnZhciBFeHBlcmltZW50YWwgPSB7XG4gIENsaXBwZXIsXG4gIE51bGwsXG4gIHVzZUlzUGxheWVyXG59O1xudmFyIHByb3h5T2JqID0ge307XG52YXIgQ29uZmlnID0gbmV3IFByb3h5KHByb3h5T2JqLCB7XG4gIGdldChfLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IFwiQnVuZGxpbmdcIiB8fCBwcm9wID09PSBcIlJlbmRlcmluZ1wiIHx8IHByb3AgPT09IFwiTG9nXCIgfHwgcHJvcCA9PT0gXCJQdXBwZXRlZXJcIiB8fCBwcm9wID09PSBcIk91dHB1dFwiKSB7XG4gICAgICByZXR1cm4gQ29uZmlnO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPICBUaGUgQ0xJIGNvbmZpZ3VyYXRpb24gaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gUmVtb3Rpb24gQ29yZS5cIik7XG4gICAgICBjb25zb2xlLndhcm4oXCJVcGRhdGUgdGhlIGltcG9ydCBmcm9tIHRoZSBjb25maWcgZmlsZTpcIik7XG4gICAgICBjb25zb2xlLndhcm4oKTtcbiAgICAgIGNvbnNvbGUud2FybihcIi0gRGVsZXRlOlwiKTtcbiAgICAgIGNvbnNvbGUud2FybignaW1wb3J0IHtDb25maWd9IGZyb20gXCJyZW1vdGlvblwiOycpO1xuICAgICAgY29uc29sZS53YXJuKFwiKyBSZXBsYWNlOlwiKTtcbiAgICAgIGNvbnNvbGUud2FybignaW1wb3J0IHtDb25maWd9IGZyb20gXCJAcmVtb3Rpb24vY2xpL2NvbmZpZ1wiOycpO1xuICAgICAgY29uc29sZS53YXJuKCk7XG4gICAgICBjb25zb2xlLndhcm4oXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzLzQtMC1taWdyYXRpb24uXCIpO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH07XG4gIH1cbn0pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhTZXF1ZW5jZSk7XG5leHBvcnQge1xuICB3YXRjaFN0YXRpY0ZpbGUsXG4gIHVzZVZpZGVvQ29uZmlnLFxuICB1c2VSZW1vdGlvbkVudmlyb25tZW50LFxuICB1c2VEZWxheVJlbmRlcixcbiAgdXNlQ3VycmVudFNjYWxlLFxuICB1c2VDdXJyZW50RnJhbWUsXG4gIHVzZUJ1ZmZlclN0YXRlLFxuICBzdGF0aWNGaWxlLFxuICBzcHJpbmcsXG4gIHJlZ2lzdGVyUm9vdCxcbiAgcmFuZG9tLFxuICBwcmVmZXRjaCxcbiAgbWVhc3VyZVNwcmluZyxcbiAgaW50ZXJwb2xhdGVDb2xvcnMsXG4gIGludGVycG9sYXRlLFxuICBnZXRTdGF0aWNGaWxlcyxcbiAgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCxcbiAgZ2V0SW5wdXRQcm9wcyxcbiAgZGVsYXlSZW5kZXIsXG4gIGNvbnRpbnVlUmVuZGVyLFxuICBjYW5jZWxSZW5kZXIsXG4gIFZpZGVvLFxuICBWRVJTSU9OLFxuICBTdGlsbCxcbiAgU2VyaWVzLFxuICBTZXF1ZW5jZSxcbiAgT2ZmdGhyZWFkVmlkZW8sXG4gIExvb3AsXG4gIEludGVybmFscyxcbiAgSW1nLFxuICBJRnJhbWUsXG4gIEh0bWw1VmlkZW8sXG4gIEh0bWw1QXVkaW8sXG4gIEZyZWV6ZSxcbiAgRm9sZGVyQ29udGV4dCxcbiAgRm9sZGVyLFxuICBFeHBlcmltZW50YWwsXG4gIEVhc2luZyxcbiAgQ29uZmlnLFxuICBDb21wb3NpdGlvbixcbiAgQXVkaW8sXG4gIEFydGlmYWN0LFxuICBBbmltYXRlZEltYWdlLFxuICBBYnNvbHV0ZUZpbGxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/remotion/dist/esm/no-react.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/remotion/dist/esm/no-react.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoReactInternals: () => (/* binding */ NoReactInternals),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n  const { extrapolateLeft, extrapolateRight, easing } = options;\n  let result = input;\n  const [inputMin, inputMax] = inputRange;\n  const [outputMin, outputMax] = outputRange;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\") {\n      return result;\n    }\n    if (extrapolateLeft === \"clamp\") {\n      result = inputMin;\n    } else if (extrapolateLeft === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateLeft === \"extend\") {}\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\") {\n      return result;\n    }\n    if (extrapolateRight === \"clamp\") {\n      result = inputMax;\n    } else if (extrapolateRight === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateRight === \"extend\") {}\n  }\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n  result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\nfunction findRange(input, inputRange) {\n  let i;\n  for (i = 1;i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\nfunction checkValidInputRange(arr) {\n  for (let i = 1;i < arr.length; ++i) {\n    if (!(arr[i] > arr[i - 1])) {\n      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction checkInfiniteRange(name, arr) {\n  if (arr.length < 2) {\n    throw new Error(name + \" must have at least 2 elements\");\n  }\n  for (const element of arr) {\n    if (typeof element !== \"number\") {\n      throw new Error(`${name} must contain only numbers`);\n    }\n    if (!Number.isFinite(element)) {\n      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n  if (typeof input === \"undefined\") {\n    throw new Error(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new Error(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new Error(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n  }\n  checkInfiniteRange(\"inputRange\", inputRange);\n  checkInfiniteRange(\"outputRange\", outputRange);\n  checkValidInputRange(inputRange);\n  const easing = options?.easing ?? ((num) => num);\n  let extrapolateLeft = \"extend\";\n  if (options?.extrapolateLeft !== undefined) {\n    extrapolateLeft = options.extrapolateLeft;\n  }\n  let extrapolateRight = \"extend\";\n  if (options?.extrapolateRight !== undefined) {\n    extrapolateRight = options.extrapolateRight;\n  }\n  if (typeof input !== \"number\") {\n    throw new TypeError(\"Cannot interpolate an input which is not a number\");\n  }\n  const range = findRange(input, inputRange);\n  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {\n    easing,\n    extrapolateLeft,\n    extrapolateRight\n  });\n}\n// src/random.ts\nfunction mulberry32(a) {\n  let t = a + 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n  let i = 0;\n  let chr = 0;\n  let hash = 0;\n  for (i = 0;i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0;\n  }\n  return hash;\n}\nvar random = (seed, dummy) => {\n  if (dummy !== undefined) {\n    throw new TypeError(\"random() takes only one argument\");\n  }\n  if (seed === null) {\n    return Math.random();\n  }\n  if (typeof seed === \"string\") {\n    return mulberry32(hashCode(seed));\n  }\n  if (typeof seed === \"number\") {\n    return mulberry32(seed * 10000000000);\n  }\n  throw new Error(\"random() argument must be a number or a string\");\n};\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/delay-render.ts\nif (typeof window !== \"undefined\") {\n  window.remotion_renderReady = false;\n  if (!window.remotion_delayRenderTimeouts) {\n    window.remotion_delayRenderTimeouts = {};\n  }\n}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\n\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithSpecialTypes = ({\n  data,\n  indent,\n  staticBase\n}) => {\n  let customDateUsed = false;\n  let customFileUsed = false;\n  let mapUsed = false;\n  let setUsed = false;\n  try {\n    const serializedString = JSON.stringify(data, function(key, value) {\n      const item = this[key];\n      if (item instanceof Date) {\n        customDateUsed = true;\n        return `${DATE_TOKEN}${item.toISOString()}`;\n      }\n      if (item instanceof Map) {\n        mapUsed = true;\n        return value;\n      }\n      if (item instanceof Set) {\n        setUsed = true;\n        return value;\n      }\n      if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n        customFileUsed = true;\n        return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n      }\n      return value;\n    }, indent);\n    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };\n  } catch (err) {\n    throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n  }\n};\nvar deserializeJSONWithSpecialTypes = (data) => {\n  return JSON.parse(data, (_, value) => {\n    if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n      return new Date(value.replace(DATE_TOKEN, \"\"));\n    }\n    if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n      return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n    }\n    return value;\n  });\n};\n\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n  return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n  const cachedMatchers = {\n    rgb: undefined,\n    rgba: undefined,\n    hsl: undefined,\n    hsla: undefined,\n    hex3: undefined,\n    hex4: undefined,\n    hex5: undefined,\n    hex6: undefined,\n    hex8: undefined\n  };\n  if (cachedMatchers.rgb === undefined) {\n    cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n    cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n    cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n    cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n  }\n  return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\nfunction parse255(str) {\n  const int = Number.parseInt(str, 10);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 255) {\n    return 255;\n  }\n  return int;\n}\nfunction parse360(str) {\n  const int = Number.parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n  const num = Number.parseFloat(str);\n  if (num < 0) {\n    return 0;\n  }\n  if (num > 1) {\n    return 255;\n  }\n  return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n  const int = Number.parseFloat(str);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 100) {\n    return 1;\n  }\n  return int / 100;\n}\nvar colorNames = {\n  transparent: 0,\n  aliceblue: 4042850303,\n  antiquewhite: 4209760255,\n  aqua: 16777215,\n  aquamarine: 2147472639,\n  azure: 4043309055,\n  beige: 4126530815,\n  bisque: 4293182719,\n  black: 255,\n  blanchedalmond: 4293643775,\n  blue: 65535,\n  blueviolet: 2318131967,\n  brown: 2771004159,\n  burlywood: 3736635391,\n  burntsienna: 3934150143,\n  cadetblue: 1604231423,\n  chartreuse: 2147418367,\n  chocolate: 3530104575,\n  coral: 4286533887,\n  cornflowerblue: 1687547391,\n  cornsilk: 4294499583,\n  crimson: 3692313855,\n  cyan: 16777215,\n  darkblue: 35839,\n  darkcyan: 9145343,\n  darkgoldenrod: 3095792639,\n  darkgray: 2846468607,\n  darkgreen: 6553855,\n  darkgrey: 2846468607,\n  darkkhaki: 3182914559,\n  darkmagenta: 2332068863,\n  darkolivegreen: 1433087999,\n  darkorange: 4287365375,\n  darkorchid: 2570243327,\n  darkred: 2332033279,\n  darksalmon: 3918953215,\n  darkseagreen: 2411499519,\n  darkslateblue: 1211993087,\n  darkslategray: 793726975,\n  darkslategrey: 793726975,\n  darkturquoise: 13554175,\n  darkviolet: 2483082239,\n  deeppink: 4279538687,\n  deepskyblue: 12582911,\n  dimgray: 1768516095,\n  dimgrey: 1768516095,\n  dodgerblue: 512819199,\n  firebrick: 2988581631,\n  floralwhite: 4294635775,\n  forestgreen: 579543807,\n  fuchsia: 4278255615,\n  gainsboro: 3705462015,\n  ghostwhite: 4177068031,\n  gold: 4292280575,\n  goldenrod: 3668254975,\n  gray: 2155905279,\n  green: 8388863,\n  greenyellow: 2919182335,\n  grey: 2155905279,\n  honeydew: 4043305215,\n  hotpink: 4285117695,\n  indianred: 3445382399,\n  indigo: 1258324735,\n  ivory: 4294963455,\n  khaki: 4041641215,\n  lavender: 3873897215,\n  lavenderblush: 4293981695,\n  lawngreen: 2096890111,\n  lemonchiffon: 4294626815,\n  lightblue: 2916673279,\n  lightcoral: 4034953471,\n  lightcyan: 3774873599,\n  lightgoldenrodyellow: 4210742015,\n  lightgray: 3553874943,\n  lightgreen: 2431553791,\n  lightgrey: 3553874943,\n  lightpink: 4290167295,\n  lightsalmon: 4288707327,\n  lightseagreen: 548580095,\n  lightskyblue: 2278488831,\n  lightslategray: 2005441023,\n  lightslategrey: 2005441023,\n  lightsteelblue: 2965692159,\n  lightyellow: 4294959359,\n  lime: 16711935,\n  limegreen: 852308735,\n  linen: 4210091775,\n  magenta: 4278255615,\n  maroon: 2147483903,\n  mediumaquamarine: 1724754687,\n  mediumblue: 52735,\n  mediumorchid: 3126187007,\n  mediumpurple: 2473647103,\n  mediumseagreen: 1018393087,\n  mediumslateblue: 2070474495,\n  mediumspringgreen: 16423679,\n  mediumturquoise: 1221709055,\n  mediumvioletred: 3340076543,\n  midnightblue: 421097727,\n  mintcream: 4127193855,\n  mistyrose: 4293190143,\n  moccasin: 4293178879,\n  navajowhite: 4292783615,\n  navy: 33023,\n  oldlace: 4260751103,\n  olive: 2155872511,\n  olivedrab: 1804477439,\n  orange: 4289003775,\n  orangered: 4282712319,\n  orchid: 3664828159,\n  palegoldenrod: 4008225535,\n  palegreen: 2566625535,\n  paleturquoise: 2951671551,\n  palevioletred: 3681588223,\n  papayawhip: 4293907967,\n  peachpuff: 4292524543,\n  peru: 3448061951,\n  pink: 4290825215,\n  plum: 3718307327,\n  powderblue: 2967529215,\n  purple: 2147516671,\n  rebeccapurple: 1714657791,\n  red: 4278190335,\n  rosybrown: 3163525119,\n  royalblue: 1097458175,\n  saddlebrown: 2336560127,\n  salmon: 4202722047,\n  sandybrown: 4104413439,\n  seagreen: 780883967,\n  seashell: 4294307583,\n  sienna: 2689740287,\n  silver: 3233857791,\n  skyblue: 2278484991,\n  slateblue: 1784335871,\n  slategray: 1887473919,\n  slategrey: 1887473919,\n  snow: 4294638335,\n  springgreen: 16744447,\n  steelblue: 1182971135,\n  tan: 3535047935,\n  teal: 8421631,\n  thistle: 3636451583,\n  tomato: 4284696575,\n  turquoise: 1088475391,\n  violet: 4001558271,\n  wheat: 4125012991,\n  white: 4294967295,\n  whitesmoke: 4126537215,\n  yellow: 4294902015,\n  yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n  const matchers = getMatchers();\n  let match;\n  if (matchers.hex6) {\n    if (match = matchers.hex6.exec(color)) {\n      return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (colorNames[color] !== undefined) {\n    return colorNames[color];\n  }\n  if (matchers.rgb) {\n    if (match = matchers.rgb.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n    }\n  }\n  if (matchers.rgba) {\n    if (match = matchers.rgba.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n    }\n  }\n  if (matchers.hex3) {\n    if (match = matchers.hex3.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (matchers.hex8) {\n    if (match = matchers.hex8.exec(color)) {\n      return Number.parseInt(match[1], 16) >>> 0;\n    }\n  }\n  if (matchers.hex4) {\n    if (match = matchers.hex4.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n    }\n  }\n  if (matchers.hsl) {\n    if (match = matchers.hsl.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n    }\n  }\n  if (matchers.hsla) {\n    if (match = matchers.hsla.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n    }\n  }\n  throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n  const normalizedColor = normalizeColor(color);\n  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\n\n// src/prores-profile.ts\nvar proResProfileOptions = [\n  \"4444-xq\",\n  \"4444\",\n  \"hq\",\n  \"standard\",\n  \"light\",\n  \"proxy\"\n];\n\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n\n// src/validate-frame.ts\nvar validateFrame = ({\n  allowFloats,\n  durationInFrames,\n  frame\n}) => {\n  if (typeof frame === \"undefined\") {\n    throw new TypeError(`Argument missing for parameter \"frame\"`);\n  }\n  if (typeof frame !== \"number\") {\n    throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n  }\n  if (!Number.isFinite(frame)) {\n    throw new RangeError(`Frame ${frame} is not finite`);\n  }\n  if (frame % 1 !== 0 && !allowFloats) {\n    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n  }\n  if (frame < 0 && frame < -durationInFrames) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n  }\n  if (frame > durationInFrames - 1) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n  }\n};\n\n// src/codec.ts\nvar validCodecs = [\n  \"h264\",\n  \"h265\",\n  \"vp8\",\n  \"vp9\",\n  \"mp3\",\n  \"aac\",\n  \"wav\",\n  \"prores\",\n  \"h264-mkv\",\n  \"h264-ts\",\n  \"gif\"\n];\n\n// src/validation/validate-default-codec.ts\nfunction validateCodec(defaultCodec, location, name) {\n  if (typeof defaultCodec === \"undefined\") {\n    return;\n  }\n  if (typeof defaultCodec !== \"string\") {\n    throw new TypeError(`The \"${name}\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n  }\n  if (!validCodecs.includes(defaultCodec)) {\n    throw new Error(`The \"${name}\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n  }\n}\n\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId) => {\n  if (!defaultProps) {\n    return;\n  }\n  if (typeof defaultProps !== \"object\") {\n    throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n  }\n  if (Array.isArray(defaultProps)) {\n    throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n  }\n};\n\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n  if (typeof amount !== \"number\") {\n    throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n  }\n  if (isNaN(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n  }\n  if (!Number.isFinite(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n  }\n  if (amount % 1 !== 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n  }\n  if (amount <= 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n  }\n}\n\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n  const { allowFloats, component } = options;\n  if (typeof durationInFrames === \"undefined\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n  }\n  if (!allowFloats && durationInFrames % 1 !== 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n  }\n  if (!Number.isFinite(durationInFrames)) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n  }\n}\n\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n  if (typeof fps !== \"number\") {\n    throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n  }\n  if (!Number.isFinite(fps)) {\n    throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n  }\n  if (isNaN(fps)) {\n    throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n  }\n  if (fps <= 0) {\n    throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n  }\n  if (isGif && fps > 50) {\n    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n  }\n}\n\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);\n};\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc) => {\n  if (typeof window === \"undefined\") {\n    return relativeSrc;\n  }\n  if (relativeSrc.startsWith(\"http://\") || relativeSrc.startsWith(\"https://\") || relativeSrc.startsWith(\"file://\") || relativeSrc.startsWith(\"blob:\") || relativeSrc.startsWith(\"data:\")) {\n    return relativeSrc;\n  }\n  return new URL(relativeSrc, window.origin).href;\n};\n\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({\n  src,\n  transparent,\n  currentTime,\n  toneMapped\n}) => {\n  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n\n// src/no-react.ts\nvar NoReactInternals = {\n  processColor,\n  truthy,\n  validateFps,\n  validateDimension,\n  validateDurationInFrames,\n  validateDefaultAndInputProps,\n  validateFrame,\n  serializeJSONWithSpecialTypes,\n  bundleName: \"bundle.js\",\n  bundleMapName: \"bundle.js.map\",\n  deserializeJSONWithSpecialTypes,\n  DELAY_RENDER_CALLSTACK_TOKEN,\n  DELAY_RENDER_RETRY_TOKEN,\n  DELAY_RENDER_CLEAR_TOKEN,\n  DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,\n  getOffthreadVideoSource,\n  getExpectedMediaFrameUncorrected,\n  ENABLE_V5_BREAKING_CHANGES,\n  MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,\n  MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? \"1.1.3\" : \"1.0.3\",\n  colorNames,\n  DATE_TOKEN,\n  FILE_TOKEN,\n  validateCodec,\n  proResProfileOptions\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQSx1RkFBdUYsY0FBYztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0EseUJBQXlCLE1BQU0sNkNBQTZDLGNBQWM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRSxtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEVBQUUsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCLEdBQUcsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDNUUsMENBQTBDLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDNUYsMENBQTBDLEVBQUU7QUFDNUMsMENBQTBDLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE1BQU07QUFDOUU7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSwyRUFBMkUsTUFBTTtBQUNqRjtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sK0JBQStCLGlCQUFpQix1REFBdUQsa0JBQWtCO0FBQzVLO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTSwrQkFBK0IsaUJBQWlCLHdEQUF3RCxxQkFBcUI7QUFDaEw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLFNBQVMsVUFBVSxtREFBbUQsb0JBQW9CO0FBQy9IO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxTQUFTLFVBQVUsaUJBQWlCLHVCQUF1QixtQkFBbUIsYUFBYTtBQUM1SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLLHNEQUFzRCxvQkFBb0I7QUFDdkc7QUFDQTtBQUNBLHdCQUF3QixLQUFLLDJDQUEyQyxvQ0FBb0MsY0FBYyxRQUFRO0FBQ2xJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVcsU0FBUyxVQUFVLG1EQUFtRCxjQUFjO0FBQzNIO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxTQUFTLFVBQVU7QUFDOUQ7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLFNBQVMsVUFBVSx5QkFBeUIsT0FBTztBQUM5RjtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsU0FBUyxVQUFVLDZCQUE2QixPQUFPO0FBQ2xHO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxTQUFTLFVBQVUsNEJBQTRCLE9BQU87QUFDakc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0EsbURBQW1ELFdBQVcsbURBQW1ELHdCQUF3QjtBQUN6STtBQUNBO0FBQ0EsdURBQXVELFdBQVcsNEJBQTRCLGlCQUFpQjtBQUMvRztBQUNBO0FBQ0EsdURBQXVELFdBQVcsOEJBQThCLGlCQUFpQjtBQUNqSDtBQUNBO0FBQ0EsdURBQXVELFdBQVcsMEJBQTBCLGlCQUFpQjtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxZQUFZLEVBQUUsU0FBUztBQUNyRztBQUNBO0FBQ0EsOERBQThELEtBQUssRUFBRSxTQUFTO0FBQzlFO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxFQUFFLFNBQVM7QUFDdEU7QUFDQTtBQUNBLDJEQUEyRCxLQUFLLEVBQUUsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkJBQTZCLDBCQUEwQixhQUFhLHdDQUF3QyxRQUFRLDZDQUE2QyxlQUFlLG9CQUFvQixjQUFjLG1CQUFtQjtBQUNyTzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FwdGlvbi1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZW1vdGlvbi9kaXN0L2VzbS9uby1yZWFjdC5tanM/YzYzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW50ZXJwb2xhdGUudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZXh0cmFwb2xhdGVMZWZ0LCBleHRyYXBvbGF0ZVJpZ2h0LCBlYXNpbmcgfSA9IG9wdGlvbnM7XG4gIGxldCByZXN1bHQgPSBpbnB1dDtcbiAgY29uc3QgW2lucHV0TWluLCBpbnB1dE1heF0gPSBpbnB1dFJhbmdlO1xuICBjb25zdCBbb3V0cHV0TWluLCBvdXRwdXRNYXhdID0gb3V0cHV0UmFuZ2U7XG4gIGlmIChyZXN1bHQgPCBpbnB1dE1pbikge1xuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImV4dGVuZFwiKSB7fVxuICB9XG4gIGlmIChyZXN1bHQgPiBpbnB1dE1heCkge1xuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImNsYW1wXCIpIHtcbiAgICAgIHJlc3VsdCA9IGlucHV0TWF4O1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJleHRlbmRcIikge31cbiAgfVxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpIHtcbiAgICByZXR1cm4gb3V0cHV0TWluO1xuICB9XG4gIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIHJlc3VsdCA9IGVhc2luZyhyZXN1bHQpO1xuICByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSkge1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTtpIDwgaW5wdXRSYW5nZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpIC0gMTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGFycikge1xuICBmb3IgKGxldCBpID0gMTtpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCEoYXJyW2ldID4gYXJyW2kgLSAxXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRSYW5nZSBtdXN0IGJlIHN0cmljdGx5IG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBidXQgZ290IFske2Fyci5qb2luKFwiLFwiKX1dYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0luZmluaXRlUmFuZ2UobmFtZSwgYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXCIgbXVzdCBoYXZlIGF0IGxlYXN0IDIgZWxlbWVudHNcIik7XG4gIH1cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycikge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgY29udGFpbiBvbmx5IG51bWJlcnNgKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBmaW5pdGUgbnVtYmVycywgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoaW5wdXRSYW5nZS5sZW5ndGggIT09IG91dHB1dFJhbmdlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0UmFuZ2UgKFwiICsgaW5wdXRSYW5nZS5sZW5ndGggKyBcIikgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICB9XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcImlucHV0UmFuZ2VcIiwgaW5wdXRSYW5nZSk7XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcIm91dHB1dFJhbmdlXCIsIG91dHB1dFJhbmdlKTtcbiAgY2hlY2tWYWxpZElucHV0UmFuZ2UoaW5wdXRSYW5nZSk7XG4gIGNvbnN0IGVhc2luZyA9IG9wdGlvbnM/LmVhc2luZyA/PyAoKG51bSkgPT4gbnVtKTtcbiAgbGV0IGV4dHJhcG9sYXRlTGVmdCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZUxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlTGVmdCA9IG9wdGlvbnMuZXh0cmFwb2xhdGVMZWZ0O1xuICB9XG4gIGxldCBleHRyYXBvbGF0ZVJpZ2h0ID0gXCJleHRlbmRcIjtcbiAgaWYgKG9wdGlvbnM/LmV4dHJhcG9sYXRlUmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlUmlnaHQgPSBvcHRpb25zLmV4dHJhcG9sYXRlUmlnaHQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW50ZXJwb2xhdGUgYW4gaW5wdXQgd2hpY2ggaXMgbm90IGEgbnVtYmVyXCIpO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKTtcbiAgcmV0dXJuIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIFtpbnB1dFJhbmdlW3JhbmdlXSwgaW5wdXRSYW5nZVtyYW5nZSArIDFdXSwgW291dHB1dFJhbmdlW3JhbmdlXSwgb3V0cHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIHtcbiAgICBlYXNpbmcsXG4gICAgZXh0cmFwb2xhdGVMZWZ0LFxuICAgIGV4dHJhcG9sYXRlUmlnaHRcbiAgfSk7XG59XG4vLyBzcmMvcmFuZG9tLnRzXG5mdW5jdGlvbiBtdWxiZXJyeTMyKGEpIHtcbiAgbGV0IHQgPSBhICsgMTgzMTU2NTgxMztcbiAgdCA9IE1hdGguaW11bCh0IF4gdCA+Pj4gMTUsIHQgfCAxKTtcbiAgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiB0ID4+PiA3LCB0IHwgNjEpO1xuICByZXR1cm4gKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG59XG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hyID0gMDtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGkgPSAwO2kgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgIGhhc2ggfD0gMDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbnZhciByYW5kb20gPSAoc2VlZCwgZHVtbXkpID0+IHtcbiAgaWYgKGR1bW15ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmFuZG9tKCkgdGFrZXMgb25seSBvbmUgYXJndW1lbnRcIik7XG4gIH1cbiAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihoYXNoQ29kZShzZWVkKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoc2VlZCAqIDEwMDAwMDAwMDAwKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb20oKSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xufTtcbi8vIHNyYy90cnV0aHkudHNcbmZ1bmN0aW9uIHRydXRoeSh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59XG5cbi8vIHNyYy9kZWxheS1yZW5kZXIudHNcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IGZhbHNlO1xuICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzKSB7XG4gICAgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMgPSB7fTtcbiAgfVxufVxudmFyIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4gPSBcIlRoZSBkZWxheVJlbmRlciB3YXMgY2FsbGVkOlwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgPSBcIlJldHJpZXMgbGVmdDogXCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOID0gXCItIFJlbmRlcmluZyB0aGUgZnJhbWUgd2lsbCBiZSByZXRyaWVkLlwiO1xudmFyIERFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTiA9IFwiaGFuZGxlIHdhcyBjbGVhcmVkIGFmdGVyXCI7XG5cbi8vIHNyYy9pbnB1dC1wcm9wcy1zZXJpYWxpemF0aW9uLnRzXG52YXIgREFURV9UT0tFTiA9IFwicmVtb3Rpb24tZGF0ZTpcIjtcbnZhciBGSUxFX1RPS0VOID0gXCJyZW1vdGlvbi1maWxlOlwiO1xudmFyIHNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzID0gKHtcbiAgZGF0YSxcbiAgaW5kZW50LFxuICBzdGF0aWNCYXNlXG59KSA9PiB7XG4gIGxldCBjdXN0b21EYXRlVXNlZCA9IGZhbHNlO1xuICBsZXQgY3VzdG9tRmlsZVVzZWQgPSBmYWxzZTtcbiAgbGV0IG1hcFVzZWQgPSBmYWxzZTtcbiAgbGV0IHNldFVzZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXNba2V5XTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjdXN0b21EYXRlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtEQVRFX1RPS0VOfSR7aXRlbS50b0lTT1N0cmluZygpfWA7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBtYXBVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgc2V0VXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiAmJiBzdGF0aWNCYXNlICE9PSBudWxsICYmIGl0ZW0uc3RhcnRzV2l0aChzdGF0aWNCYXNlKSkge1xuICAgICAgICBjdXN0b21GaWxlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtGSUxFX1RPS0VOfSR7aXRlbS5yZXBsYWNlKHN0YXRpY0Jhc2UgKyBcIi9cIiwgXCJcIil9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBpbmRlbnQpO1xuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRTdHJpbmcsIGN1c3RvbURhdGVVc2VkLCBjdXN0b21GaWxlVXNlZCwgbWFwVXNlZCwgc2V0VXNlZCB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc2VyaWFsaXplIHRoZSBwYXNzZWQgaW5wdXQgcHJvcHMgdG8gSlNPTjogXCIgKyBlcnIubWVzc2FnZSk7XG4gIH1cbn07XG52YXIgZGVzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyA9IChkYXRhKSA9PiB7XG4gIHJldHVybiBKU09OLnBhcnNlKGRhdGEsIChfLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChEQVRFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLnJlcGxhY2UoREFURV9UT0tFTiwgXCJcIikpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoRklMRV9UT0tFTikpIHtcbiAgICAgIHJldHVybiBgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0vJHt2YWx1ZS5yZXBsYWNlKEZJTEVfVE9LRU4sIFwiXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICByZXR1cm4gXCJcXFxcKFxcXFxzKihcIiArIGFyZ3Muam9pbihcIilcXFxccyosXFxcXHMqKFwiKSArIFwiKVxcXFxzKlxcXFwpXCI7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVycygpIHtcbiAgY29uc3QgY2FjaGVkTWF0Y2hlcnMgPSB7XG4gICAgcmdiOiB1bmRlZmluZWQsXG4gICAgcmdiYTogdW5kZWZpbmVkLFxuICAgIGhzbDogdW5kZWZpbmVkLFxuICAgIGhzbGE6IHVuZGVmaW5lZCxcbiAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgaGV4NDogdW5kZWZpbmVkLFxuICAgIGhleDU6IHVuZGVmaW5lZCxcbiAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgaGV4ODogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYiA9IG5ldyBSZWdFeHAoXCJyZ2JcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKFwicmdiYVwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2wgPSBuZXcgUmVnRXhwKFwiaHNsXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbGEgPSBuZXcgUmVnRXhwKFwiaHNsYVwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcbiAgfVxuICByZXR1cm4gY2FjaGVkTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCArPSAxO1xuICB9XG4gIGlmICh0ID4gMSkge1xuICAgIHQgLT0gMTtcbiAgfVxuICBpZiAodCA8IDEgLyA2KSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIH1cbiAgaWYgKHQgPCAxIC8gMikge1xuICAgIHJldHVybiBxO1xuICB9XG4gIGlmICh0IDwgMiAvIDMpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICBjb25zdCByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgY29uc3QgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQociAqIDI1NSkgPDwgMjQgfCBNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2IHwgTWF0aC5yb3VuZChiICogMjU1KSA8PCA4O1xufVxuZnVuY3Rpb24gcGFyc2UyNTUoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMjU1KSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gaW50O1xufVxuZnVuY3Rpb24gcGFyc2UzNjAoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiAoaW50ICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKG51bSA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAobnVtID4gMSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudGFnZShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMTAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cbnZhciBjb2xvck5hbWVzID0ge1xuICB0cmFuc3BhcmVudDogMCxcbiAgYWxpY2VibHVlOiA0MDQyODUwMzAzLFxuICBhbnRpcXVld2hpdGU6IDQyMDk3NjAyNTUsXG4gIGFxdWE6IDE2Nzc3MjE1LFxuICBhcXVhbWFyaW5lOiAyMTQ3NDcyNjM5LFxuICBhenVyZTogNDA0MzMwOTA1NSxcbiAgYmVpZ2U6IDQxMjY1MzA4MTUsXG4gIGJpc3F1ZTogNDI5MzE4MjcxOSxcbiAgYmxhY2s6IDI1NSxcbiAgYmxhbmNoZWRhbG1vbmQ6IDQyOTM2NDM3NzUsXG4gIGJsdWU6IDY1NTM1LFxuICBibHVldmlvbGV0OiAyMzE4MTMxOTY3LFxuICBicm93bjogMjc3MTAwNDE1OSxcbiAgYnVybHl3b29kOiAzNzM2NjM1MzkxLFxuICBidXJudHNpZW5uYTogMzkzNDE1MDE0MyxcbiAgY2FkZXRibHVlOiAxNjA0MjMxNDIzLFxuICBjaGFydHJldXNlOiAyMTQ3NDE4MzY3LFxuICBjaG9jb2xhdGU6IDM1MzAxMDQ1NzUsXG4gIGNvcmFsOiA0Mjg2NTMzODg3LFxuICBjb3JuZmxvd2VyYmx1ZTogMTY4NzU0NzM5MSxcbiAgY29ybnNpbGs6IDQyOTQ0OTk1ODMsXG4gIGNyaW1zb246IDM2OTIzMTM4NTUsXG4gIGN5YW46IDE2Nzc3MjE1LFxuICBkYXJrYmx1ZTogMzU4MzksXG4gIGRhcmtjeWFuOiA5MTQ1MzQzLFxuICBkYXJrZ29sZGVucm9kOiAzMDk1NzkyNjM5LFxuICBkYXJrZ3JheTogMjg0NjQ2ODYwNyxcbiAgZGFya2dyZWVuOiA2NTUzODU1LFxuICBkYXJrZ3JleTogMjg0NjQ2ODYwNyxcbiAgZGFya2toYWtpOiAzMTgyOTE0NTU5LFxuICBkYXJrbWFnZW50YTogMjMzMjA2ODg2MyxcbiAgZGFya29saXZlZ3JlZW46IDE0MzMwODc5OTksXG4gIGRhcmtvcmFuZ2U6IDQyODczNjUzNzUsXG4gIGRhcmtvcmNoaWQ6IDI1NzAyNDMzMjcsXG4gIGRhcmtyZWQ6IDIzMzIwMzMyNzksXG4gIGRhcmtzYWxtb246IDM5MTg5NTMyMTUsXG4gIGRhcmtzZWFncmVlbjogMjQxMTQ5OTUxOSxcbiAgZGFya3NsYXRlYmx1ZTogMTIxMTk5MzA4NyxcbiAgZGFya3NsYXRlZ3JheTogNzkzNzI2OTc1LFxuICBkYXJrc2xhdGVncmV5OiA3OTM3MjY5NzUsXG4gIGRhcmt0dXJxdW9pc2U6IDEzNTU0MTc1LFxuICBkYXJrdmlvbGV0OiAyNDgzMDgyMjM5LFxuICBkZWVwcGluazogNDI3OTUzODY4NyxcbiAgZGVlcHNreWJsdWU6IDEyNTgyOTExLFxuICBkaW1ncmF5OiAxNzY4NTE2MDk1LFxuICBkaW1ncmV5OiAxNzY4NTE2MDk1LFxuICBkb2RnZXJibHVlOiA1MTI4MTkxOTksXG4gIGZpcmVicmljazogMjk4ODU4MTYzMSxcbiAgZmxvcmFsd2hpdGU6IDQyOTQ2MzU3NzUsXG4gIGZvcmVzdGdyZWVuOiA1Nzk1NDM4MDcsXG4gIGZ1Y2hzaWE6IDQyNzgyNTU2MTUsXG4gIGdhaW5zYm9ybzogMzcwNTQ2MjAxNSxcbiAgZ2hvc3R3aGl0ZTogNDE3NzA2ODAzMSxcbiAgZ29sZDogNDI5MjI4MDU3NSxcbiAgZ29sZGVucm9kOiAzNjY4MjU0OTc1LFxuICBncmF5OiAyMTU1OTA1Mjc5LFxuICBncmVlbjogODM4ODg2MyxcbiAgZ3JlZW55ZWxsb3c6IDI5MTkxODIzMzUsXG4gIGdyZXk6IDIxNTU5MDUyNzksXG4gIGhvbmV5ZGV3OiA0MDQzMzA1MjE1LFxuICBob3RwaW5rOiA0Mjg1MTE3Njk1LFxuICBpbmRpYW5yZWQ6IDM0NDUzODIzOTksXG4gIGluZGlnbzogMTI1ODMyNDczNSxcbiAgaXZvcnk6IDQyOTQ5NjM0NTUsXG4gIGtoYWtpOiA0MDQxNjQxMjE1LFxuICBsYXZlbmRlcjogMzg3Mzg5NzIxNSxcbiAgbGF2ZW5kZXJibHVzaDogNDI5Mzk4MTY5NSxcbiAgbGF3bmdyZWVuOiAyMDk2ODkwMTExLFxuICBsZW1vbmNoaWZmb246IDQyOTQ2MjY4MTUsXG4gIGxpZ2h0Ymx1ZTogMjkxNjY3MzI3OSxcbiAgbGlnaHRjb3JhbDogNDAzNDk1MzQ3MSxcbiAgbGlnaHRjeWFuOiAzNzc0ODczNTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogNDIxMDc0MjAxNSxcbiAgbGlnaHRncmF5OiAzNTUzODc0OTQzLFxuICBsaWdodGdyZWVuOiAyNDMxNTUzNzkxLFxuICBsaWdodGdyZXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0cGluazogNDI5MDE2NzI5NSxcbiAgbGlnaHRzYWxtb246IDQyODg3MDczMjcsXG4gIGxpZ2h0c2VhZ3JlZW46IDU0ODU4MDA5NSxcbiAgbGlnaHRza3libHVlOiAyMjc4NDg4ODMxLFxuICBsaWdodHNsYXRlZ3JheTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c3RlZWxibHVlOiAyOTY1NjkyMTU5LFxuICBsaWdodHllbGxvdzogNDI5NDk1OTM1OSxcbiAgbGltZTogMTY3MTE5MzUsXG4gIGxpbWVncmVlbjogODUyMzA4NzM1LFxuICBsaW5lbjogNDIxMDA5MTc3NSxcbiAgbWFnZW50YTogNDI3ODI1NTYxNSxcbiAgbWFyb29uOiAyMTQ3NDgzOTAzLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAxNzI0NzU0Njg3LFxuICBtZWRpdW1ibHVlOiA1MjczNSxcbiAgbWVkaXVtb3JjaGlkOiAzMTI2MTg3MDA3LFxuICBtZWRpdW1wdXJwbGU6IDI0NzM2NDcxMDMsXG4gIG1lZGl1bXNlYWdyZWVuOiAxMDE4MzkzMDg3LFxuICBtZWRpdW1zbGF0ZWJsdWU6IDIwNzA0NzQ0OTUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAxNjQyMzY3OSxcbiAgbWVkaXVtdHVycXVvaXNlOiAxMjIxNzA5MDU1LFxuICBtZWRpdW12aW9sZXRyZWQ6IDMzNDAwNzY1NDMsXG4gIG1pZG5pZ2h0Ymx1ZTogNDIxMDk3NzI3LFxuICBtaW50Y3JlYW06IDQxMjcxOTM4NTUsXG4gIG1pc3R5cm9zZTogNDI5MzE5MDE0MyxcbiAgbW9jY2FzaW46IDQyOTMxNzg4NzksXG4gIG5hdmFqb3doaXRlOiA0MjkyNzgzNjE1LFxuICBuYXZ5OiAzMzAyMyxcbiAgb2xkbGFjZTogNDI2MDc1MTEwMyxcbiAgb2xpdmU6IDIxNTU4NzI1MTEsXG4gIG9saXZlZHJhYjogMTgwNDQ3NzQzOSxcbiAgb3JhbmdlOiA0Mjg5MDAzNzc1LFxuICBvcmFuZ2VyZWQ6IDQyODI3MTIzMTksXG4gIG9yY2hpZDogMzY2NDgyODE1OSxcbiAgcGFsZWdvbGRlbnJvZDogNDAwODIyNTUzNSxcbiAgcGFsZWdyZWVuOiAyNTY2NjI1NTM1LFxuICBwYWxldHVycXVvaXNlOiAyOTUxNjcxNTUxLFxuICBwYWxldmlvbGV0cmVkOiAzNjgxNTg4MjIzLFxuICBwYXBheWF3aGlwOiA0MjkzOTA3OTY3LFxuICBwZWFjaHB1ZmY6IDQyOTI1MjQ1NDMsXG4gIHBlcnU6IDM0NDgwNjE5NTEsXG4gIHBpbms6IDQyOTA4MjUyMTUsXG4gIHBsdW06IDM3MTgzMDczMjcsXG4gIHBvd2RlcmJsdWU6IDI5Njc1MjkyMTUsXG4gIHB1cnBsZTogMjE0NzUxNjY3MSxcbiAgcmViZWNjYXB1cnBsZTogMTcxNDY1Nzc5MSxcbiAgcmVkOiA0Mjc4MTkwMzM1LFxuICByb3N5YnJvd246IDMxNjM1MjUxMTksXG4gIHJveWFsYmx1ZTogMTA5NzQ1ODE3NSxcbiAgc2FkZGxlYnJvd246IDIzMzY1NjAxMjcsXG4gIHNhbG1vbjogNDIwMjcyMjA0NyxcbiAgc2FuZHlicm93bjogNDEwNDQxMzQzOSxcbiAgc2VhZ3JlZW46IDc4MDg4Mzk2NyxcbiAgc2Vhc2hlbGw6IDQyOTQzMDc1ODMsXG4gIHNpZW5uYTogMjY4OTc0MDI4NyxcbiAgc2lsdmVyOiAzMjMzODU3NzkxLFxuICBza3libHVlOiAyMjc4NDg0OTkxLFxuICBzbGF0ZWJsdWU6IDE3ODQzMzU4NzEsXG4gIHNsYXRlZ3JheTogMTg4NzQ3MzkxOSxcbiAgc2xhdGVncmV5OiAxODg3NDczOTE5LFxuICBzbm93OiA0Mjk0NjM4MzM1LFxuICBzcHJpbmdncmVlbjogMTY3NDQ0NDcsXG4gIHN0ZWVsYmx1ZTogMTE4Mjk3MTEzNSxcbiAgdGFuOiAzNTM1MDQ3OTM1LFxuICB0ZWFsOiA4NDIxNjMxLFxuICB0aGlzdGxlOiAzNjM2NDUxNTgzLFxuICB0b21hdG86IDQyODQ2OTY1NzUsXG4gIHR1cnF1b2lzZTogMTA4ODQ3NTM5MSxcbiAgdmlvbGV0OiA0MDAxNTU4MjcxLFxuICB3aGVhdDogNDEyNTAxMjk5MSxcbiAgd2hpdGU6IDQyOTQ5NjcyOTUsXG4gIHdoaXRlc21va2U6IDQxMjY1MzcyMTUsXG4gIHllbGxvdzogNDI5NDkwMjAxNSxcbiAgeWVsbG93Z3JlZW46IDI1OTcxMzkxOTlcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICBjb25zdCBtYXRjaGVycyA9IGdldE1hdGNoZXJzKCk7XG4gIGxldCBtYXRjaDtcbiAgaWYgKG1hdGNoZXJzLmhleDYpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChjb2xvck5hbWVzW2NvbG9yXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbG9yTmFtZXNbY29sb3JdO1xuICB9XG4gIGlmIChtYXRjaGVycy5yZ2IpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2IuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMucmdiYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYmEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDMpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgbWF0Y2hbMV0gKyBtYXRjaFsyXSArIG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFszXSArIFwiZmZcIiwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4OCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDQpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg0LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgbWF0Y2hbMV0gKyBtYXRjaFsyXSArIG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFszXSArIG1hdGNoWzRdICsgbWF0Y2hbNF0sIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhzbCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSkpIHwgMjU1KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhzbGEpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2xhLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNvbG9yIHN0cmluZyAke2NvbG9yfSBwcm92aWRlZGApO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0NvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IG5vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcbiAgcmV0dXJuIChub3JtYWxpemVkQ29sb3IgPDwgMjQgfCBub3JtYWxpemVkQ29sb3IgPj4+IDgpID4+PiAwO1xufVxuXG4vLyBzcmMvcHJvcmVzLXByb2ZpbGUudHNcbnZhciBwcm9SZXNQcm9maWxlT3B0aW9ucyA9IFtcbiAgXCI0NDQ0LXhxXCIsXG4gIFwiNDQ0NFwiLFxuICBcImhxXCIsXG4gIFwic3RhbmRhcmRcIixcbiAgXCJsaWdodFwiLFxuICBcInByb3h5XCJcbl07XG5cbi8vIHNyYy92NS1mbGFnLnRzXG52YXIgRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPSBmYWxzZTtcblxuLy8gc3JjL3ZhbGlkYXRlLWZyYW1lLnRzXG52YXIgdmFsaWRhdGVGcmFtZSA9ICh7XG4gIGFsbG93RmxvYXRzLFxuICBkdXJhdGlvbkluRnJhbWVzLFxuICBmcmFtZVxufSkgPT4ge1xuICBpZiAodHlwZW9mIGZyYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgbWlzc2luZyBmb3IgcGFyYW1ldGVyIFwiZnJhbWVcImApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJhbWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBwYXNzZWQgZm9yIFwiZnJhbWVcIiBpcyBub3QgYSBudW1iZXI6ICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEZyYW1lICR7ZnJhbWV9IGlzIG5vdCBmaW5pdGVgKTtcbiAgfVxuICBpZiAoZnJhbWUgJSAxICE9PSAwICYmICFhbGxvd0Zsb2F0cykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBBcmd1bWVudCBmb3IgZnJhbWUgbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKGZyYW1lIDwgMCAmJiBmcmFtZSA8IC1kdXJhdGlvbkluRnJhbWVzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgbG93ZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7LWR1cmF0aW9uSW5GcmFtZXN9YCk7XG4gIH1cbiAgaWYgKGZyYW1lID4gZHVyYXRpb25JbkZyYW1lcyAtIDEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBoaWdoZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7ZHVyYXRpb25JbkZyYW1lcyAtIDF9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb2RlYy50c1xudmFyIHZhbGlkQ29kZWNzID0gW1xuICBcImgyNjRcIixcbiAgXCJoMjY1XCIsXG4gIFwidnA4XCIsXG4gIFwidnA5XCIsXG4gIFwibXAzXCIsXG4gIFwiYWFjXCIsXG4gIFwid2F2XCIsXG4gIFwicHJvcmVzXCIsXG4gIFwiaDI2NC1ta3ZcIixcbiAgXCJoMjY0LXRzXCIsXG4gIFwiZ2lmXCJcbl07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtY29kZWMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlQ29kZWMoZGVmYXVsdENvZGVjLCBsb2NhdGlvbiwgbmFtZSkge1xuICBpZiAodHlwZW9mIGRlZmF1bHRDb2RlYyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRDb2RlYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZX1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBzdHJpbmcsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0Q29kZWN9LmApO1xuICB9XG4gIGlmICghdmFsaWRDb2RlY3MuaW5jbHVkZXMoZGVmYXVsdENvZGVjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtuYW1lfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBvbmUgb2YgJHt2YWxpZENvZGVjcy5qb2luKFwiLCBcIil9LCBidXQgeW91IHBhc3NlZCAke2RlZmF1bHRDb2RlY30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGVmYXVsdC1wcm9wcy50c1xudmFyIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMgPSAoZGVmYXVsdFByb3BzLCBuYW1lLCBjb21wb3NpdGlvbklkKSA9PiB7XG4gIGlmICghZGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmYXVsdFByb3BzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGRlZmF1bHRQcm9wc31gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0UHJvcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGFuIG9iamVjdCwgYW4gYXJyYXkgd2FzIHBhc3NlZCAke2NvbXBvc2l0aW9uSWQgPyBgZm9yIGNvbXBvc2l0aW9uIFwiJHtjb21wb3NpdGlvbklkfVwiYCA6IFwiXCJ9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRpbWVuc2lvbnMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9uKGFtb3VudCwgbmFtZU9mUHJvcCwgbG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBhbW91bnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhbW91bnR9YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgZmluaXRlLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHthbW91bnR9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWR1cmF0aW9uLWluLWZyYW1lcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhbGxvd0Zsb2F0cywgY29tcG9uZW50IH0gPSBvcHRpb25zO1xuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBpcyBtaXNzaW5nLmApO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghYWxsb3dGbG9hdHMgJiYgZHVyYXRpb25JbkZyYW1lcyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb25JbkZyYW1lcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1mcHMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRnBzKGZwcywgbG9jYXRpb24sIGlzR2lmKSB7XG4gIGlmICh0eXBlb2YgZnBzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgZmluaXRlLCBidXQgeW91IHBhc3NlZCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNOYU4oZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGZwcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJmcHNcIiBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChpc0dpZiAmJiBmcHMgPiA1MCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBGUFMgZm9yIGEgR0lGIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiA1MC4gVXNlIHRoZSAtLWV2ZXJ5LW50aC1mcmFtZSBvcHRpb24gdG8gbG93ZXIgdGhlIEZQUzogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9yZW5kZXItYXMtZ2lmYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZpZGVvL2dldC1jdXJyZW50LXRpbWUudHNcbnZhciBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCA9ICh7XG4gIGZyYW1lLFxuICBwbGF5YmFja1JhdGUsXG4gIHN0YXJ0RnJvbVxufSkgPT4ge1xuICByZXR1cm4gaW50ZXJwb2xhdGUoZnJhbWUsIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyAxXSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIHBsYXliYWNrUmF0ZV0pO1xufTtcblxuLy8gc3JjL2Fic29sdXRlLXNyYy50c1xudmFyIGdldEFic29sdXRlU3JjID0gKHJlbGF0aXZlU3JjKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlU3JjO1xuICB9XG4gIGlmIChyZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCByZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikgfHwgcmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikgfHwgcmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpIHx8IHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIHJldHVybiByZWxhdGl2ZVNyYztcbiAgfVxuICByZXR1cm4gbmV3IFVSTChyZWxhdGl2ZVNyYywgd2luZG93Lm9yaWdpbikuaHJlZjtcbn07XG5cbi8vIHNyYy92aWRlby9vZmZ0aHJlYWQtdmlkZW8tc291cmNlLnRzXG52YXIgZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UgPSAoe1xuICBzcmMsXG4gIHRyYW5zcGFyZW50LFxuICBjdXJyZW50VGltZSxcbiAgdG9uZU1hcHBlZFxufSkgPT4ge1xuICByZXR1cm4gYGh0dHA6Ly9sb2NhbGhvc3Q6JHt3aW5kb3cucmVtb3Rpb25fcHJveHlQb3J0fS9wcm94eT9zcmM9JHtlbmNvZGVVUklDb21wb25lbnQoZ2V0QWJzb2x1dGVTcmMoc3JjKSl9JnRpbWU9JHtlbmNvZGVVUklDb21wb25lbnQoTWF0aC5tYXgoMCwgY3VycmVudFRpbWUpKX0mdHJhbnNwYXJlbnQ9JHtTdHJpbmcodHJhbnNwYXJlbnQpfSZ0b25lTWFwcGVkPSR7U3RyaW5nKHRvbmVNYXBwZWQpfWA7XG59O1xuXG4vLyBzcmMvbm8tcmVhY3QudHNcbnZhciBOb1JlYWN0SW50ZXJuYWxzID0ge1xuICBwcm9jZXNzQ29sb3IsXG4gIHRydXRoeSxcbiAgdmFsaWRhdGVGcHMsXG4gIHZhbGlkYXRlRGltZW5zaW9uLFxuICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMsXG4gIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMsXG4gIHZhbGlkYXRlRnJhbWUsXG4gIHNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzLFxuICBidW5kbGVOYW1lOiBcImJ1bmRsZS5qc1wiLFxuICBidW5kbGVNYXBOYW1lOiBcImJ1bmRsZS5qcy5tYXBcIixcbiAgZGVzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyxcbiAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOLFxuICBERUxBWV9SRU5ERVJfQ0xFQVJfVE9LRU4sXG4gIERFTEFZX1JFTkRFUl9BVFRFTVBUX1RPS0VOOiBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZULFxuICBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSxcbiAgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQsXG4gIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTLFxuICBNSU5fTk9ERV9WRVJTSU9OOiBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyA/IDE4IDogMTYsXG4gIE1JTl9CVU5fVkVSU0lPTjogRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPyBcIjEuMS4zXCIgOiBcIjEuMC4zXCIsXG4gIGNvbG9yTmFtZXMsXG4gIERBVEVfVE9LRU4sXG4gIEZJTEVfVE9LRU4sXG4gIHZhbGlkYXRlQ29kZWMsXG4gIHByb1Jlc1Byb2ZpbGVPcHRpb25zXG59O1xuZXhwb3J0IHtcbiAgcmFuZG9tLFxuICBpbnRlcnBvbGF0ZSxcbiAgTm9SZWFjdEludGVybmFsc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/no-react.mjs\n");

/***/ })

};
;